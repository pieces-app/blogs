![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd72b769c93f3974477eb6_reactvideoplayer_e4e65a9c9cefccb7d75cf3a9b8518031_2000.jpeg)
"react-7; video; tutorial"
# Developing a React Video Player with Personalized Controls
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Stylized image of a React video player." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd72b869c93f033a477ebf_reactvideoplayer_0d017568f463d243eb6202d0a2a6b870_800.jpeg"><div.new.line><figure.new.line><p>Web technology has developed a lot over the years; Javascript, in particular, has played an enormous role in it. By involving React, the development and use of UI have become better and more efficient. With React, including an audio-video player on any website is easy. A simple React player plugin may assist you in performing the task in a few minutes. In this article, we&#x27;ll talk about how to build a customizable React video player from scratch.<p.new.line><h2 id="b2i5k">Introduction<h2.new.line><p><a href="https://www.npmjs.com/package/react-player" target="_blank" rel="noopener noreferrer">React-Player</a> is a React component that <a href="https://code.pieces.app/blog/the-encrypted-media-extension-api-and-watching-protected-video-content-on-the-web" target="_blank" rel="noopener noreferrer">plays audio-visual files from various URLs</a>, including file paths, YouTube links, Facebook links, Twitch links, SoundCloud links, Streamable links, Vimeo links, Wistia links, Mixcloud links, DailyMotion links, Kaltura links, and so on.<p.new.line><p>In this post, we&#x27;ll use the React-Player component to build a video player (which you can install with the React Player npm), while focusing more on its functionalities than its appearance. To follow this tutorial, you&#x27;ll need to have Node.js installed locally on your machine and have some familiarity with Material UI, Javascript, and React.<p.new.line><h3 id="1t6ch">Features of React-Player<h3.new.line><ul><li>Customizable and easy-to-use<li.new.line><li>Runs on diffrent URLs, including file paths<li.new.line><li>Supports video looping and play back rates<li.new.line><ul.new.line><h2 id="4adj9">Installing Dependencies<h2.new.line><p>Running the following commands in the terminal allows us to start by setting up the project and installing the necessary dependencies:<p.new.line><pre>yarn create react-app react-video-player<br><br>cd react-video-player<br><br>yarn add @mui/material @emotion/react @emotion/styled @mui/icons-material react-player screenfull<br><br>yarn start</pre><p>Let&#x27;s start by importing <code>ReactPlayer</code> into our App.js file and updating it.<p.new.line><pre>import ReactPlayer from &quot;react-player&quot;;<br>import &quot;./App.css&quot;;<br>import ReactPlayer from &quot;react-player&quot;;<br>import { Container } from &quot;@mui/material&quot;;<br><br>function App() {<br> return (<br> &lt;div className=&quot;video_container&quot;&gt;<br> &lt;div&gt;<br> &lt;h2&gt;React player&lt;/h2&gt;<br> &lt;/div&gt;<br> &lt;Container maxWidth=&quot;md&quot; justify=&quot;center&quot;&gt;<br> &lt;div className=&quot;player__wrapper&quot;&gt;<br> &lt;ReactPlayer<br>           className=&quot;player&quot;<br>       url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={true}<br>           muted={true}<br>         /&gt;<br> &lt;Control /&gt;<br> &lt;/div&gt;<br> &lt;/Container&gt;<br> &lt;/div&gt;<br> );<br>}</pre><p>The <code>react-player</code> component is now inside a <code>Container</code> wrapper. Additionally, we supplied the link to the example video as the URL prop&#x27;s value. Finally, we also provided the player with a set <code>width</code><strong> </strong>and <code>height</code> of 100%, so it will be responsive.<p.new.line><p>Then, add the following code to your App.css file.<p.new.line><pre>.App {<br> text-align: center;<br>}<br>.video_container {<br> display: flex;<br> flex-direction: column;<br> justify-content: center;<br> align-items: center;<br> width: 100%;<br>}<br><br>.player__wrapper {<br> position: relative;<br>}<br><br>.player {<br> border: 2px solid #7b2cbf;<br> object-fit: cover;<br> padding: 0;<br> margin: 0;<br>}<br><br>h2 {<br> color: #7b2cbf;<br>}</pre><p>To enable playback within our video player React, we added the <code>playing</code> and <code>muted</code> props to the preceding code. In addition, we set a value of <code>true</code> in place of the default value of <code>false</code> for the props. As a result, the <code>playing</code> footage created by the above code is shown in the picture below:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Beautiful nature scenes in our React player." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3c4ab97637d9b427dd_image8_559f0156e52b82dbc54f485ff3b822a9_800.png"><div.new.line><figure.new.line><p>Observe that the video player is not interactive and lacks any controls. The <code>react-player</code> package contains a prop called <code>control</code> that, by default, has a value of <code>false</code>. When the value is modified to <code>true</code>, the React player controls are automatically added.<p.new.line><h2 id="clih5">React Player Functionalities<h2.new.line><p>Let&#x27;s begin by creating a new folder in the <code>src</code> folder named <code>Components</code>. Then, create the Control.jsx and Control.css files as two new files inside the newly formed folder.<p.new.line><pre>src<br>    ├── App.css<br>    ├── App.js<br>    ├── Components <br>             ├── Control.css<br>             ├──Control.jsx</pre><h3 id="phgp">Let’s Code<h3.new.line><p>First, we’ll import the required packages for our Control.jsx file:<p.new.line><pre>import React from &quot;react&quot;;<br>import { makeStyles, Slider, withStyles, Button,  Tooltip,  Popover,Grid<br><br>} from &quot;@material-ui/core&quot;;<br>import {<br> FastForward,<br> FastRewind,<br> Pause,<br> PlayArrow,<br> SkipNext,<br>  VolumeUp,<br>} from &quot;@material-ui/icons&quot;;<br>import &quot;./Control.css&quot;;</pre><p>The control.jsx file is made up of three containers:<p.new.line><ol type="1"><li>The heading container<li.new.line><li>The middle container (Contains the Play, Rewind and Fast forward buttons)<li.new.line><li>The bottom container (Contains the Slider, volume and playback rate buttons)<li.new.line></ol><h4 id="c36j5">The Heading Container<h4.new.line><pre>&lt;div className=&quot;top_container&quot;&gt;<br> &lt;h2&gt;Video PLayer&lt;/h2&gt;<br> &lt;/div&gt;</pre><h4 id="9b3ro">The Middle Container<h4.new.line><pre>&lt;div className=&quot;mid__container&quot;&gt;<br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;FastRewind fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br><br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;Pause fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br><br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;FastForward fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;</pre><h4 id="46t7f">The Bottom Container<h4.new.line><pre>&lt;div className=&quot;bottom__container&quot;&gt;<br> &lt;div className=&quot;slider__container&quot;&gt;<br> &lt;PrettoSlider /&gt;<br> &lt;/div&gt;<br> &lt;div className=&quot;control__box&quot;&gt;<br> &lt;div className=&quot;inner__controls&quot;&gt;<br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;PlayArrow fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;SkipNext fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;VolumeUp fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br><br> &lt;Slider<br>             className={&#x60;${classes.volumeSlider}&#x60;} /&gt;<br> &lt;span&gt;5/20&lt;/span&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;</pre><p>Our control.jsx React player component will be like this:<p.new.line><pre>const Control = () =&gt; {<br> return(<br> &lt;div className=&quot;control_Container&quot;&gt;<br>       // &lt;-- The Heading Container --&gt; <br> // &lt;-- The Middle Container --&gt; <br> // &lt;-- The Bottom Container --&gt; <br> &lt;/div&gt;<br>   )<br>     }</pre><p>Let&#x27;s discuss the <code>.control container</code> class-named <code>div</code> element. It’s a distinct container that, if hovered above the custom video player, appears as an overlay.<p.new.line><p>The following are the styles for our Control.jsx file:<p.new.line><pre>.control_Container {<br> background-color: rgba(0, 0, 0, 0.6);<br> position: absolute;<br> top: 0;<br> bottom: 0;<br> right: 0;<br> left: 0;<br> flex-direction: column;<br> z-index: 1;<br> display: flex;<br> justify-content: space-between;<br>}<br><br>.top_container {<br> display: flex;<br> align-items: center;<br> justify-content: space-between;<br> margin: 5px 20px;<br>}<br><br>.mid__container {<br> display: flex;<br> justify-content: center;<br> align-items: center;<br>}<br><br>.icon__btn {<br> padding: 0 10px;<br> color: #7b2cbf;<br>}<br><br>.slider__container {<br> /* width: 100%; */<br> display: flex;<br> align-items: center;<br> padding: 0 16px;<br>}<br><br>.control__box {<br> display: flex;<br> align-items: center;<br> justify-content: space-between;<br>}<br><br>.inner__controls {<br> display: flex;<br> padding: 10px 0;<br> align-items: center;<br> width: 50%;<br>}<br><br>span {<br> color: #9556cc;<br> font-size: 0.8rem;<br> margin-left: 10px;<br>}<br><br>.second__control {<br> display: flex;<br> align-items: center;<br>}</pre><p>Additionally, we style some of the components by adding the Material UI&#x27;s <code>makeStyles</code> and <code>withStyles</code> to our Control. Jsx<p.new.line><pre>const useStyles = makeStyles({<br> volumeSlider: {<br>   width: &quot;100px&quot;,<br>   color: &quot;#9556CC&quot;,<br> },<br><br> bottomIcons: {<br>   color: &quot;#999&quot;,<br>   padding: &quot;12px 8px&quot;,<br> <br><br> &quot;&amp;:hover&quot;: {<br>     color: &quot;#fff&quot;,<br>   },<br> },<br>});<br><br>const PrettoSlider = withStyles({<br> root: {<br>   height: &quot;20px&quot;,<br>   color: &quot;#9556CC&quot;,<br>   display: &quot;flex&quot;,<br>   justifyContent: &quot;center&quot;,<br>   alignItems: &quot;center&quot;,<br> },<br> thumb: {<br>   height: 20,<br>   width: 20,<br>   backgroundColor: &quot;#9556CC&quot;,<br>   border: &quot;2px solid currentColor&quot;,<br>   marginTop: -3,<br>   marginLeft: -12,<br> &quot;&amp;:focus, &amp;:hover, &amp;$active&quot;: {<br>     boxShadow: &quot;inherit&quot;,<br>   },<br> },<br> active: {},<br> valueLabel: {<br>   left: &quot;calc(-50% + 4px)&quot;,<br> },<br> track: {<br>   height: 5,<br>   borderRadius: 4,<br>   width: &quot;100%&quot;,<br> },<br> rail: {<br>   height: 5,<br>   borderRadius: 4,<br> },<br>})(Slider);</pre><p>Adding the following code to your App.js file will import React’s <code>Controls</code> component, which we also need to do:<p.new.line><pre>import &quot;./App.css&quot;;<br>import ReactPlayer from &quot;react-player&quot;;<br>import { Container } from &quot;@material-ui/core&quot;;<br>import Control from &quot;./Components/Control&quot;;<br><br>function App() {<br> return (<br> &lt;div className=&quot;video_container&quot;&gt;<br> &lt;div&gt;<br> &lt;h2&gt;React player&lt;/h2&gt;<br> &lt;/div&gt;<br> &lt;Container maxWidth=&quot;md&quot; justify=&quot;center&quot;&gt;<br> &lt;div className=&quot;player__wrapper&quot;&gt;<br> &lt;ReactPlayer<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={true}<br>           muted={true}<br>         /&gt;<br> &lt;Control /&gt;<br> &lt;/div&gt;<br> &lt;/Container&gt;<br> &lt;/div&gt;<br> );<br>}<br><br>export default App;</pre><p>If you followed closely, our React custom video player ought to appear like this:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Our finished custom React player." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab976ea2fb42692_image3_935201d0bb867675494d0cd76d957b32_800.png"><div.new.line><figure.new.line><h2 id="a5da8">Handling Play and Pause<h2.new.line><p>In this section, we&#x27;ll concentrate on the capabilities and logic of the custom controls for the React player, starting with playing and pausing.<p.new.line><p>Navigate to the App.js file, where we&#x27;ll begin by defining a state named <code>videoState</code>. An object with different properties represents this state:<p.new.line><pre>const [videoState, setVideoState] = useState({<br>   playing: true,<br>   muted: false,<br>   volume: 0.5,<br>   played: 0,<br>   seeking: false,<br>Buffer : true<br> });</pre><pre>//Destructuring the properties from the videoState<br> const {playing, muted, volume, playbackRate, played, seeking, buffer} = videoState</pre><p>We destructure the <code>videoState</code> using the ES6 syntax to get its properties.<p.new.line><p>Following that, we need to create a function that toggles the play and pause capabilities. To do this, we&#x27;ll spread the previous state and toggle the necessary state.<p.new.line><pre>const playPauseHandler = () =&gt; {<br> //plays and pause the video (toggling)<br>   setVideoState({ ...videoState, playing: !videoState.playing });<br> };</pre><p>Replace the <code>true</code> values for the <code>playing</code> and <code>muted</code><strong> </strong>properties with the appropriate values of <code>playing</code> and <code>mute</code> from the destructured <code>videoState</code> in the <code>ReactPlayer</code> component.<p.new.line><pre>&lt;div className=&quot;player__wrapper&quot;&gt;<br> &lt;ReactPlayer<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           muted={muted}<br>         /&gt;<br> &lt;Control onPlayPause={playPauseHandler} playing={playing}/&gt;<br> &lt;/div&gt;</pre><p>The <code>playing</code> prop in <code>ReactPlayer</code> is used to set the value to <code>true</code> or <code>false</code>, playing or pausing the video.<p.new.line><p>To allow the play and pause buttons to access this feature, we pass in the function to the <code>Control</code> component as a prop in the example above.<p.new.line><p>We’d also update our Control.jsx file by passing the <code>onPlayPause</code> into the <code>onClick</code> of our pause button.<p.new.line><pre>&lt;div className=&quot;icon__btn&quot; onClick={onPlayPause}&gt;<br> &lt;Pause fontSize=&quot;medium&quot;  /&gt;<br> &lt;/div&gt;</pre><p>The playing attribute value provided within the <code>videoState</code>, which we passed as a prop to the <code>Control</code> component, is used to render the icon using the ternary operator conditionally. For example, the play icon should appear when the video is paused, and when it is playing, the pause icon should appear.<p.new.line><pre>&lt;div className=&quot;icon__btn&quot; onClick={onPlayPause}&gt;<br>         {playing ? (<br> &lt;Pause fontSize=&quot;medium&quot; /&gt;<br>         ) : (<br> &lt;PlayArrow fontSize=&quot;medium&quot; /&gt;<br>         )}{&quot; &quot;}<br> &lt;/div&gt;</pre><p>With the addition of these functionalities, we can easily play and pause our video, like so:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The React player, now capable of being played and paused." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/6384e888061a320f255264f8_ezgif_com-gif-maker28_1da03c70af754e02b897eed266f1f167.gif"><div.new.line><figure.new.line><h2 id="9apgb">Handling Rewind and Fast Forward<h2.new.line><p>We want to fast-forward the video by 10 seconds and rewind it by 5 seconds, much like with other video players. The <code>ReactPlayer</code> must be referenced using the <code>useRef</code> hook to obtain the video&#x27;s current time before implementing this feature.<p.new.line><p>We’ll begin by importing the <code>useRef</code> hook and creating a reference for the <code>React Player</code>.<p.new.line><pre>import ReactPlayer from &quot;react-player&quot;;<br>import { useRef } from &quot;react&quot;;<br><br>function App() {<br> //react player reference<br> const videoPlayerRef = useRef(null);<br> return (<br> &lt;ReactPlayer<br>           ref={videoPlayerRef} //updating the react player ref<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           muted={muted}<br>         /&gt;<br> );<br>}<br><br>export default App;</pre><p>Let&#x27;s implement a <code>rewindHandler</code> function that we&#x27;ll call anytime the rewind button is double-tapped. This function will use two methods for the rewind and fast-forward features obtained from the <code>videoPlayerRef</code>.<p.new.line><ul><li><code>seekTo</code>: Seek the given number of seconds, or a fraction if the amount is between 0 and 1<li.new.line><li><code>getCurrentTime()</code>: Returns the number of seconds that have been played<li.new.line><ul.new.line><pre>const rewindHandler = () =&gt; {<br> //Rewinds the video player reducing 5<br>   videoPlayerRef.current.seekTo(videoPlayerRef.current.getCurrentTime() - 5);<br> };</pre><p>The <code>rewindHandler</code> subtracts 5 seconds from the current video time, which is  what you&#x27;re thinking about when you think about the <code>fastForwardHandler</code> adding 10 seconds to the current video time.<p.new.line><pre>const fastFowardHandler = () =&gt; {<br> //FastFowards the video player by adding 10<br>   videoPlayerRef.current.seekTo(videoPlayerRef.current.getCurrentTime() + 10);<br> };</pre><p>Next, we pass the functions as props to the <code>Control</code> component:<p.new.line><pre>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward ={handleFastFoward }<br>         /&gt;</pre><p>Then, we receive the props and pass the two functions into their respective buttons.<p.new.line><pre>&lt;div className=&quot;icon__btn&quot; onDoubleClick={onRewind}&gt;<br> &lt;FastRewind fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br><br><br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;FastForward fontSize=&quot;medium&quot; onDoubleClick={onForward}/&gt;<br> &lt;/div&gt;</pre><p>We can now fast-forward and rewind our video using the code above. However, you&#x27;ll also notice that the video player&#x27;s slider doesn&#x27;t move to the current time when we rewind or fast-forward the video. Let&#x27;s fix that, since we&#x27;re problem solvers, right?<p.new.line><h3 id="da5s1">Seek Functionality<h3.new.line><p>The <code>ReactPlayer</code> has an <code>onProgress</code> prop callback for this feature, which is a <code>Callback</code> that contains played and loaded progress as a fraction as well as <code>playedSeconds</code> and loaded seconds.<p.new.line><pre>const progressHandler = (state) =&gt; {<br> <br>   if (!seeking) {<br> setVideoState({ ...videoState, ...state });<br>   }<br> };</pre><p>The <code>progressHandler</code> function accepts an argument called <code>state</code>. This <code>state</code> argument indicates an object with contained states. Every time the video player seek bar (the player&#x27;s timing) updates, some sets of states are altered, and new values are returned. We keep the values of the previously modified States and our <code>videoState</code> properties in this function. We want this to happen, but only when the value of the seeking property in our <code>videoState</code> is negated.<p.new.line><p>Next, we pass in the <code>progressHandler</code> function to the <code>onProgess</code> prop in the <code>ReactPlayer</code>:<p.new.line><pre>&lt;ReactPlayer<br>           ref={videoPlayerRef}<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           muted={muted}<br>           onProgress = {progressHandler}<br>         /&gt;</pre><p>Then, to update our seek slider to the appropriate time of the video, we pass the <code>played</code> state that we&#x27;ve destructured from the <code>videoState</code> to the control component as a prop.<p.new.line><pre>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward ={handleFastFoward }<br>           played ={played}<br>/&gt;</pre><p>The <code>PrettoSlider</code> in our <code>control</code> component then has to be updated. The maximum value for our <code>PrettoSlider</code> must be 100, and the minimum value must be set to 0. The value prop is the slider&#x27;s <code>current e.target.value</code>, which multiplies the value of the <code>played</code> props by 100.<p.new.line><pre>&lt;PrettoSlider<br>         min = {0}<br>         max = {100}<br>         value = {played * 100}<br>/&gt;</pre><p>Furthermore, we need to write functions that will enable us to use the video player slider to look for a specific moment. To do this, we&#x27;d create a <code>seekHandler</code> and a <code>seekMouseUpHandler</code> to help us achieve this feature.<p.new.line><pre>const seekHandler = (e, value) =&gt; {<br>   setVideoState({ ...videoState, played: parseFloat(value) / 100 });<br> };<br><br> const seekMouseUpHandler = (e, value ) =&gt; {<br>   setVideoState({ ...videoState, seeking: false });<br>   videoPlayerRef.current.seekTo(value / 100);<br> };</pre><p>We then pass these functions as props to the <code>control</code> component. The parameter given to the function is the value we immediately receive whenever the slider moves. Then, since <code>played</code> only accepts values between 0 and 1, we only updated the <code>played</code> value to the value argument divided by 100 when updating the <code>videoState</code>.<p.new.line><p>Additionally, we gave the <code>mouseSeekUpHandler</code> function an argument called <code>value</code>. Spreading the previous state and changing only the <code>seeking</code><strong> </strong>state value to <code>false</code>, which allows us to update the <code>videoState</code>. Then, we change the video&#x27;s current time to the desired time.<p.new.line><pre>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward ={handleFastFoward }<br>           played ={played}<br>           onSeek ={seekHandler}<br>           onSeekMouseUp ={seekMouseUpHandler}<br>         /&gt;</pre><p>To use these two functions, the <code>PrettoSlider</code> has two props which we can use for this functionality: <code>onChange</code><strong> </strong>and <code>onChangeCommitted</code><strong>. </strong>According to the <u><a href="https://mui.com/material-ui/api/slider/" target="_blank" rel="noopener noreferrer">MUI docs, </a></u>the <code>onChange</code> prop is a Callback function that fires whenever the slider&#x27;s value changes, while the <code>onChangeCommitted</code><strong> </strong>is a<strong> </strong>Callback function that fires when the mouse moves up.<p.new.line><p>This is what our video player should look like now:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The current functions of our video player." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab97690f9b426a9_image2_937acdde5d84b19a9ed571a7a27c68b3.gif"><div.new.line><figure.new.line><h2 id="36cv8">Volume Functionality<h2.new.line><p>We should have the option to mute and increase/decrease the video’s volume in our React player. The icon should then change to ‘muted’ or ‘volume-up’, depending on the volume setting in that situation.<p.new.line><p>Let’s head over to our App.js file.<p.new.line><pre>const volumeChangeHandler = (e, value) =&gt; {<br> const newVolume = parseFloat(value) / 100;<br>   setVideoState({<br>     ...videoState,<br>     volume: newVolume,<br>     muted: Number(newVolume) === 0 ? true : false, // volume === 0 then muted<br>   })<br><br>};<br><br>const volumeSeekUpHandler = (e, value) =&gt; {<br> const newVolume = parseFloat(value) / 100;<br>   setVideoState({<br>     ...videoState,<br>     volume: newVolume,<br>     muted: newVolume === 0 ? true : false,<br>   })};</pre><p>There is a volume prop for this functionality in the <code>ReactPlayer</code> where we pass the destructured <code>volume</code><strong> </strong>from our <code>videoState</code>.<p.new.line><pre>&lt;ReactPlayer<br>           ref={videoPlayerRef}<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           volume = {volume}<br>           muted={muted}<br>           onProgress={progressHandler}<br>         /&gt;</pre><p>The volume slider needs to define two functions, one for the <code>onChange</code> event and the other for the <code>onChangeCommitted</code> event, just like the <code>PrettoSlider</code>.<p.new.line><p>Now, we pass them as props to the <code>control</code> component:<p.new.line><pre>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br><br>Volume={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>         /&gt;</pre><p>The volume slider is then updated by including new props, the <code>onChange</code> event, the <code>onChangeCommitted</code> event, and <code>value</code>, and passing the <code>onVolumeChangeHandler</code><strong>,</strong> <code>onVolumeSeekUp</code><strong>, </strong>and <code>volume</code> props. <p.new.line><pre>&lt;Slider<br>             className={&#x60;${classes.volumeSlider}&#x60;}<br>             onChange={onVolumeChangeHandler}<br> value={volume * 100}<br>             onChangeCommitted={onVolumeSeekUp}<br>           /&gt;</pre><h3 id="d8jdq">Handling the Muted State<h3.new.line><p>We ought to be able to choose between <code>muted</code> and <code>volume up</code> whenever the mute button is clicked. The symbol should switch to ‘muted’ or ‘volume-up’ depending on the volume level.<p.new.line><p>We’ll start by writing a function that handles the mute functionality in our App.js file.<p.new.line><pre>const muteHandler = () =&gt; {<br> //Mutes the video player<br>   setVideoState({ ...videoState, muted: !videoState.muted });<br> };</pre><p>In the <code>muteHandler</code><strong>, </strong>we retained everything in the <code>videoState</code> and changed the <code>muted</code> property to have a value opposite of the current <code>muted</code> state, thereby toggling it and then passing the <code>muted</code> props to the <code>control</code> component.<p.new.line><pre>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br>           volume ={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>           mute = {muted}<br>           onMute = {muteHandler}<br>         /&gt;<br><br>&lt;div className=&quot;icon__btn&quot; onClick={onMute} &gt;<br>           {mute ? (<br> &lt;VolumeOff fontSize=&quot;medium&quot; /&gt;<br>               ) : (<br> &lt;VolumeUp fontSize=&quot;medium&quot; /&gt;<br>               )}<br> &lt;/div&gt;</pre><p>The value of the <code>videoState</code> field&#x27;s <code>muted</code> state determines how the two icons in the above code would render conditionally. It also passes in a function to the wrapper, which toggles the mute functionality.<p.new.line><p>This is how our video should function:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Raising and lowering the volume of our video." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab9767aceb42693_image6_f5491d002e8bb4ebeec2977724064f6c.gif"><div.new.line><figure.new.line><h3 id="6mmgt">Video Time Functionality<h3.new.line><p>Video players, as we all know, typically show the video&#x27;s current time. To accomplish this, we use some instance methods that <u><a href="https://www.npmjs.com/package/react-player" target="_blank" rel="noopener noreferrer">React Player</a></u> offers:<p.new.line><ul><li><code>getCurrentTime</code>: Returns the number of seconds that have been played.<li.new.line><li><code>getDuration</code>: Returns the currently playing media’s total duration (in seconds).<li.new.line><li><code>getSecondsLoaded</code>: Returns the number of seconds that have been loaded.<li.new.line><ul.new.line><pre>const currentTime = videoPlayerRef.current? videoPlayerRef.current.getCurrentTime(): &quot;00:00&quot;;<br><br>const duration = videoPlayerRef.current? videoPlayerRef.current.getDuration(): &quot;00:00&quot;;</pre><p>We still need to format the returned time according to our preferences, even though the <code>currentTime</code> and <code>duration</code> are rendered conditionally using ternary operators.<p.new.line><p>A function that formats the timing must be created. After accepting an argument, this function will return the time in a specific format.<p.new.line><p>To use the function in App.js, we create a new file called Format.js inside the component folder.<p.new.line><pre>export const formatTime = (time) =&gt; {<br> //formarting duration of video<br> if (isNaN(time)) {<br> return &quot;00:00&quot;;<br>   }<br><br> const date = new Date(time * 1000);<br> const hours = date.getUTCHours();<br> const minutes = date.getUTCMinutes();<br> const seconds = date.getUTCSeconds().toString().padStart(2, &quot;0&quot;);<br> if (hours) {<br> //if video have hours<br> return &#x60;${hours}:${minutes.toString().padStart(2, &quot;0&quot;)} &#x60;;<br>   } else return &#x60;${minutes}:${seconds}&#x60;;<br> };</pre><p>Following that, import the <code>formatTime</code><strong> </strong>method found in the Format.js file. Therefore, in the App.js file, we can use it. Then, two <code>formatTime</code> calls are made, with the <code>currentTime</code> and <code>duration</code> being passed as arguments.<p.new.line><pre>const formatCurrentTime = formatTime(currentTime)<br><br>const formatDuration = formatTime(duration)</pre><p>We then pass the <code>formatCurrentTime</code><strong> </strong>and <code>formatDuration</code><strong> </strong>as props to the <code>control</code><strong> </strong>component.<p.new.line><pre>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br>           volume ={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>           mute = {muted}<br>           onMute = {muteHandler}<br>           duration = {formatDuration}<br>           currentTime = {formatCurrentTime}<br>         /&gt;</pre><p>Finally, modify the default timing value to this:<p.new.line><pre>&lt;span&gt;{ currentTime} : {duration}&lt;/span&gt;</pre><p>Now, you can watch the length of the video as it plays and see how much time has passed. Watch the timing as the seek bar is dragged.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Adjusting the time in our custom video player." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab976606bb42691_image1_235e2e72f5ac6a241fd2c46a4d9d4284.gif"><div.new.line><figure.new.line><p>The <code>Control</code> container div is frequently resting on the player, as you can see. Let&#x27;s make it more interesting by having it resemble other video players— let’s make it visible whenever we hover on the video player.<p.new.line><h4 id="78bnp">Creating a Disappearing Seek Bar<h4.new.line><p>To achieve this feature, we also need to create a reference of the <code>div</code><strong> </strong>with classname of <code>control_Container</code><strong> </strong>in the App.js file:<p.new.line><pre>const controlRef = useRef(null)</pre><p>And pass it to the <code>control</code><strong> </strong>component:<p.new.line><pre>&lt;Control<br>         controlRef = {controlRef}<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br>           volume ={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>           mute = {muted}<br>           onMute = {muteHandler}<br>           playRate = {playbackRate}<br>           onPlayRate = {playBackRateHandler}<br>           duration = {formatDuration}<br>           currentTime = {formatCurrentTime}<br>         /&gt;</pre><p>We then pass it to the <code>ref</code> property on the <code>control_Container</code><strong> </strong>div in the <code>control</code><strong> </strong>component:<p.new.line><pre>const Control = ({controlRef}) =&gt; {<br> return (<br> &lt;div className=&quot;control_Container&quot; ref ={controlRef}&gt;<br>    // &lt;-- body of the control component ---&gt;<br> <br> &lt;/div&gt;<br> );<br>};<br><br>export default Control;</pre><p>Next, we head over to our App.js and declare a new variable called <code>count</code><strong> </strong>which will be equal to 0:<p.new.line><pre>Let count = 0<br><br>const App = () =&gt; {<br> return (<br> &lt;div&gt;<br>    // &lt;-- body of the App component ---&gt;<br> <br> &lt;/div&gt;<br> );<br>};<br><br>export default App;</pre><p>We include an <code>if</code> statement inside the <code>progressHandler</code> function to determine whether the <code>count</code> exceeds 3, at which point we use the <code>controlRef</code><strong> </strong>and set the visibility to <code>hidden</code>. By doing so, the <code>control</code> component div is hidden.<p.new.line><pre>const progressHandler = (state) =&gt; {<br>   if (count &gt; 3)<br><br>// toggling player control container<br><br>controlRef.current.style.visibility = &quot;hidden&quot;;<br>   } else if (controlRef.current.style.visibility === &quot;visible&quot;) {<br>     count += 1;<br>   }<br><br>   if (!seeking) {<br> setVideoState({ ...videoState, ...state });<br>   }<br> };</pre><p>We must create another function to make the control div visible whenever the player is hovered over.<p.new.line><pre>const mouseMoveHandler = () =&gt; {<br>   controlRef.current.style.visibility = &quot;visible&quot;;<br> count = 0;<br> };<br><br>const App = () =&gt; {<br> return (<br> &lt;div&gt;<br>    // &lt;-- body of the App component ---&gt;<br> &lt;div onMouseDown = {mouseMoveHandler} &gt; <br> &lt;ReactPlayer/&gt;<br> &lt;Control/&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> );<br>};<br><br>export default App;</pre><p>Our player now looks like this:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The React player with a disappearing seek bar." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab976922fb42685_image4_9a975ad265973fadcd05a97d63bd56fd.gif"><div.new.line><figure.new.line><h3 id="8391u">Buffering Functionality in our React Player<h3.new.line><p>When we watch videos online, they frequently stall, primarily because of poor network connections. Let&#x27;s add a similar feature to our video player.<p.new.line><p>The ReactPlayer provides two props that accept a callback for this feature: <code>onBuffer</code><strong> </strong>and<strong> </strong><code>onBufferEnd</code>.<p.new.line><pre>const bufferStartHandler = () =&gt; {<br> console.log(&quot;Bufering.......&quot;);<br>   setVideoState({...videoState , buffer: true})<br> };<br><br> const bufferEndHandler = () =&gt; {<br> console.log(&quot;buffering stoped ,,,,,,play&quot;);<br>   setVideoState({...videoState , buffer: false})<br> };</pre><p>These two functions will be passed to the <code>onBuffer</code><strong> </strong>and<strong> </strong><code>onBufferEnd</code>.<p.new.line><pre>&lt;ReactPlayer<br>           ref={videoPlayerRef}<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           volume={volume}<br>           muted={muted}<br>           onProgress={progressHandler}<br>           playbackRate={playBackRateHandler}<br>           onBuffer={bufferStartHandler}<br>           onBufferEnd={bufferEndHandler}<br>         /&gt;</pre><p>The last step alerts users when a video freezes. The buffer state must be <code>true</code> to render a load effectively.<p.new.line><pre>{buffer &amp;&amp; &lt;p&gt;Loading&lt;/p&gt;}</pre><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Our buffering video." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/6384e805fbd9788099ce91dc_ezgif_com-gif-maker27_bfeb3b5692616426a6939401225efe6a.gif"><div.new.line><figure.new.line><p>Observe the <code>Loading</code><strong> </strong>text when the video freezes.<p.new.line><h2 id="dc6id">Conclusion<h2.new.line><p>This post taught us how to construct and modify a video player using the <code>react-player</code> package and <code>Material UI</code><strong> </strong>to style and import the required icons. Of course, you can always improve the build by including a few special features to make the player entirely custom.<p.new.line><p>Here is the <u><a href="https://github.com/wesley-codes/React-player.git" target="_blank" rel="noopener noreferrer">URL</a></u> to the GitHub 
Web technology has developed a lot over the years; Javascript, in particular, has played an enormous role in it. By involving React, the development and use of UI have become better and more efficient. With React, including an audio-video player on any website is easy. A simple React player plugin may assist you in performing the task in a few minutes. In this article, we&#x27;ll talk about how to build a customizable React video player from scratch.
## Introduction
<a href="https://www.npmjs.com/package/react-player" target="_blank" rel="noopener noreferrer">React-Player</a> is a React component that <a href="https://code.pieces.app/blog/the-encrypted-media-extension-api-and-watching-protected-video-content-on-the-web" target="_blank" rel="noopener noreferrer">plays audio-visual files from various URLs</a>, including file paths, YouTube links, Facebook links, Twitch links, SoundCloud links, Streamable links, Vimeo links, Wistia links, Mixcloud links, DailyMotion links, Kaltura links, and so on.
In this post, we&#x27;ll use the React-Player component to build a video player (which you can install with the React Player npm), while focusing more on its functionalities than its appearance. To follow this tutorial, you&#x27;ll need to have Node.js installed locally on your machine and have some familiarity with Material UI, Javascript, and React.
### Features of React-Player
- Customizable and easy-to-use
- Runs on diffrent URLs, including file paths
- Supports video looping and play back rates
## Installing Dependencies
Running the following commands in the terminal allows us to start by setting up the project and installing the necessary dependencies:
e>yarn create react-app react-video-player<br><br>cd react-video-player<br><br>yarn add @mui/material @emotion/react @emotion/styled @mui/icons-material react-player screenfull<br><br>yarn start</pre><p>Let&#x27;s start by importing <code>ReactPlayer</code> into our App.js file and updating it.
e>import ReactPlayer from &quot;react-player&quot;;<br>import &quot;./App.css&quot;;<br>import ReactPlayer from &quot;react-player&quot;;<br>import { Container } from &quot;@mui/material&quot;;<br><br>function App() {<br> return (<br> &lt;div className=&quot;video_container&quot;&gt;<br> &lt;div&gt;<br> &lt;h2&gt;React player&lt;/h2&gt;<br> &lt;/div&gt;<br> &lt;Container maxWidth=&quot;md&quot; justify=&quot;center&quot;&gt;<br> &lt;div className=&quot;player__wrapper&quot;&gt;<br> &lt;ReactPlayer<br>           className=&quot;player&quot;<br>       url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={true}<br>           muted={true}<br>         /&gt;<br> &lt;Control /&gt;<br> &lt;/div&gt;<br> &lt;/Container&gt;<br> &lt;/div&gt;<br> );<br>}</pre><p>The <code>react-player</code> component is now inside a <code>Container</code> wrapper. Additionally, we supplied the link to the example video as the URL prop&#x27;s value. Finally, we also provided the player with a set <code>width</code><strong> </strong>and <code>height</code> of 100%, so it will be responsive.
Then, add the following code to your App.css file.
e>.App {<br> text-align: center;<br>}<br>.video_container {<br> display: flex;<br> flex-direction: column;<br> justify-content: center;<br> align-items: center;<br> width: 100%;<br>}<br><br>.player__wrapper {<br> position: relative;<br>}<br><br>.player {<br> border: 2px solid #7b2cbf;<br> object-fit: cover;<br> padding: 0;<br> margin: 0;<br>}<br><br>h2 {<br> color: #7b2cbf;<br>}</pre><p>To enable playback within our video player React, we added the <code>playing</code> and <code>muted</code> props to the preceding code. In addition, we set a value of <code>true</code> in place of the default value of <code>false</code> for the props. As a result, the <code>playing</code> footage created by the above code is shown in the picture below:
![](tps://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3c4ab97637d9b427dd_image8_559f0156e52b82dbc54f485ff3b822a9_800.p)
Observe that the video player is not interactive and lacks any controls. The <code>react-player</code> package contains a prop called <code>control</code> that, by default, has a value of <code>false</code>. When the value is modified to <code>true</code>, the React player controls are automatically added.
## React Player Functionalities
Let&#x27;s begin by creating a new folder in the <code>src</code> folder named <code>Components</code>. Then, create the Control.jsx and Control.css files as two new files inside the newly formed folder.
First, we’ll import the required packages for our Control.jsx file:
e>import React from &quot;react&quot;;<br>import { makeStyles, Slider, withStyles, Button,  Tooltip,  Popover,Grid<br><br>} from &quot;@material-ui/core&quot;;<br>import {<br> FastForward,<br> FastRewind,<br> Pause,<br> PlayArrow,<br> SkipNext,<br>  VolumeUp,<br>} from &quot;@material-ui/icons&quot;;<br>import &quot;./Control.css&quot;;</pre><p>The control.jsx file is made up of three containers:
- The middle container (Contains the Play, Rewind and Fast forward buttons)
- The bottom container (Contains the Slider, volume and playback rate buttons)
e>&lt;div className=&quot;bottom__container&quot;&gt;<br> &lt;div className=&quot;slider__container&quot;&gt;<br> &lt;PrettoSlider /&gt;<br> &lt;/div&gt;<br> &lt;div className=&quot;control__box&quot;&gt;<br> &lt;div className=&quot;inner__controls&quot;&gt;<br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;PlayArrow fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;SkipNext fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;VolumeUp fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br><br> &lt;Slider<br>             className={&#x60;${classes.volumeSlider}&#x60;} /&gt;<br> &lt;span&gt;5/20&lt;/span&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;</pre><p>Our control.jsx React player component will be like this:
e>const Control = () =&gt; {<br> return(<br> &lt;div className=&quot;control_Container&quot;&gt;<br>       // &lt;-- The Heading Container --&gt; <br> // &lt;-- The Middle Container --&gt; <br> // &lt;-- The Bottom Container --&gt; <br> &lt;/div&gt;<br>   )<br>     }</pre><p>Let&#x27;s discuss the <code>.control container</code> class-named <code>div</code> element. It’s a distinct container that, if hovered above the custom video player, appears as an overlay.
The following are the styles for our Control.jsx file:
e>.control_Container {<br> background-color: rgba(0, 0, 0, 0.6);<br> position: absolute;<br> top: 0;<br> bottom: 0;<br> right: 0;<br> left: 0;<br> flex-direction: column;<br> z-index: 1;<br> display: flex;<br> justify-content: space-between;<br>}<br><br>.top_container {<br> display: flex;<br> align-items: center;<br> justify-content: space-between;<br> margin: 5px 20px;<br>}<br><br>.mid__container {<br> display: flex;<br> justify-content: center;<br> align-items: center;<br>}<br><br>.icon__btn {<br> padding: 0 10px;<br> color: #7b2cbf;<br>}<br><br>.slider__container {<br> /* width: 100%; */<br> display: flex;<br> align-items: center;<br> padding: 0 16px;<br>}<br><br>.control__box {<br> display: flex;<br> align-items: center;<br> justify-content: space-between;<br>}<br><br>.inner__controls {<br> display: flex;<br> padding: 10px 0;<br> align-items: center;<br> width: 50%;<br>}<br><br>span {<br> color: #9556cc;<br> font-size: 0.8rem;<br> margin-left: 10px;<br>}<br><br>.second__control {<br> display: flex;<br> align-items: center;<br>}</pre><p>Additionally, we style some of the components by adding the Material UI&#x27;s <code>makeStyles</code> and <code>withStyles</code> to our Control. Jsx
e>const useStyles = makeStyles({<br> volumeSlider: {<br>   width: &quot;100px&quot;,<br>   color: &quot;#9556CC&quot;,<br> },<br><br> bottomIcons: {<br>   color: &quot;#999&quot;,<br>   padding: &quot;12px 8px&quot;,<br> <br><br> &quot;&amp;:hover&quot;: {<br>     color: &quot;#fff&quot;,<br>   },<br> },<br>});<br><br>const PrettoSlider = withStyles({<br> root: {<br>   height: &quot;20px&quot;,<br>   color: &quot;#9556CC&quot;,<br>   display: &quot;flex&quot;,<br>   justifyContent: &quot;center&quot;,<br>   alignItems: &quot;center&quot;,<br> },<br> thumb: {<br>   height: 20,<br>   width: 20,<br>   backgroundColor: &quot;#9556CC&quot;,<br>   border: &quot;2px solid currentColor&quot;,<br>   marginTop: -3,<br>   marginLeft: -12,<br> &quot;&amp;:focus, &amp;:hover, &amp;$active&quot;: {<br>     boxShadow: &quot;inherit&quot;,<br>   },<br> },<br> active: {},<br> valueLabel: {<br>   left: &quot;calc(-50% + 4px)&quot;,<br> },<br> track: {<br>   height: 5,<br>   borderRadius: 4,<br>   width: &quot;100%&quot;,<br> },<br> rail: {<br>   height: 5,<br>   borderRadius: 4,<br> },<br>})(Slider);</pre><p>Adding the following code to your App.js file will import React’s <code>Controls</code> component, which we also need to do:
e>import &quot;./App.css&quot;;<br>import ReactPlayer from &quot;react-player&quot;;<br>import { Container } from &quot;@material-ui/core&quot;;<br>import Control from &quot;./Components/Control&quot;;<br><br>function App() {<br> return (<br> &lt;div className=&quot;video_container&quot;&gt;<br> &lt;div&gt;<br> &lt;h2&gt;React player&lt;/h2&gt;<br> &lt;/div&gt;<br> &lt;Container maxWidth=&quot;md&quot; justify=&quot;center&quot;&gt;<br> &lt;div className=&quot;player__wrapper&quot;&gt;<br> &lt;ReactPlayer<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={true}<br>           muted={true}<br>         /&gt;<br> &lt;Control /&gt;<br> &lt;/div&gt;<br> &lt;/Container&gt;<br> &lt;/div&gt;<br> );<br>}<br><br>export default App;</pre><p>If you followed closely, our React custom video player ought to appear like this:
![](ds-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab976ea2fb42692_image3_935201d0bb867675494d0cd76d957b32_800.p)
## Handling Play and Pause
In this section, we&#x27;ll concentrate on the capabilities and logic of the custom controls for the React player, starting with playing and pausing.
Navigate to the App.js file, where we&#x27;ll begin by defining a state named <code>videoState</code>. An object with different properties represents this state:
e>const [videoState, setVideoState] = useState({<br>   playing: true,<br>   muted: false,<br>   volume: 0.5,<br>   played: 0,<br>   seeking: false,<br>Buffer : true<br> });</pre><pre>//Destructuring the properties from the videoState<br> const {playing, muted, volume, playbackRate, played, seeking, buffer} = videoState</pre><p>We destructure the <code>videoState</code> using the ES6 syntax to get its properties.
Following that, we need to create a function that toggles the play and pause capabilities. To do this, we&#x27;ll spread the previous state and toggle the necessary state.
e>const playPauseHandler = () =&gt; {<br> //plays and pause the video (toggling)<br>   setVideoState({ ...videoState, playing: !videoState.playing });<br> };</pre><p>Replace the <code>true</code> values for the <code>playing</code> and <code>muted</code><strong> </strong>properties with the appropriate values of <code>playing</code> and <code>mute</code> from the destructured <code>videoState</code> in the <code>ReactPlayer</code> component.
e>&lt;div className=&quot;player__wrapper&quot;&gt;<br> &lt;ReactPlayer<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           muted={muted}<br>         /&gt;<br> &lt;Control onPlayPause={playPauseHandler} playing={playing}/&gt;<br> &lt;/div&gt;</pre><p>The <code>playing</code> prop in <code>ReactPlayer</code> is used to set the value to <code>true</code> or <code>false</code>, playing or pausing the video.
To allow the play and pause buttons to access this feature, we pass in the function to the <code>Control</code> component as a prop in the example above.
We’d also update our Control.jsx file by passing the <code>onPlayPause</code> into the <code>onClick</code> of our pause button.
e>&lt;div className=&quot;icon__btn&quot; onClick={onPlayPause}&gt;<br> &lt;Pause fontSize=&quot;medium&quot;  /&gt;<br> &lt;/div&gt;</pre><p>The playing attribute value provided within the <code>videoState</code>, which we passed as a prop to the <code>Control</code> component, is used to render the icon using the ternary operator conditionally. For example, the play icon should appear when the video is paused, and when it is playing, the pause icon should appear.
e>&lt;div className=&quot;icon__btn&quot; onClick={onPlayPause}&gt;<br>         {playing ? (<br> &lt;Pause fontSize=&quot;medium&quot; /&gt;<br>         ) : (<br> &lt;PlayArrow fontSize=&quot;medium&quot; /&gt;<br>         )}{&quot; &quot;}<br> &lt;/div&gt;</pre><p>With the addition of these functionalities, we can easily play and pause our video, like so:
![](sed." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/6384e888061a320f255264f8_ezgif_com-gif-maker28_1da03c70af754e02b897eed266f1f167.g)
## Handling Rewind and Fast Forward
We want to fast-forward the video by 10 seconds and rewind it by 5 seconds, much like with other video players. The <code>ReactPlayer</code> must be referenced using the <code>useRef</code> hook to obtain the video&#x27;s current time before implementing this feature.
We’ll begin by importing the <code>useRef</code> hook and creating a reference for the <code>React Player</code>.
e>import ReactPlayer from &quot;react-player&quot;;<br>import { useRef } from &quot;react&quot;;<br><br>function App() {<br> //react player reference<br> const videoPlayerRef = useRef(null);<br> return (<br> &lt;ReactPlayer<br>           ref={videoPlayerRef} //updating the react player ref<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           muted={muted}<br>         /&gt;<br> );<br>}<br><br>export default App;</pre><p>Let&#x27;s implement a <code>rewindHandler</code> function that we&#x27;ll call anytime the rewind button is double-tapped. This function will use two methods for the rewind and fast-forward features obtained from the <code>videoPlayerRef</code>.
- <code>seekTo</code>: Seek the given number of seconds, or a fraction if the amount is between 0 and 1
- <code>getCurrentTime()</code>: Returns the number of seconds that have been played
e>const rewindHandler = () =&gt; {<br> //Rewinds the video player reducing 5<br>   videoPlayerRef.current.seekTo(videoPlayerRef.current.getCurrentTime() - 5);<br> };</pre><p>The <code>rewindHandler</code> subtracts 5 seconds from the current video time, which is  what you&#x27;re thinking about when you think about the <code>fastForwardHandler</code> adding 10 seconds to the current video time.
e>const fastFowardHandler = () =&gt; {<br> //FastFowards the video player by adding 10<br>   videoPlayerRef.current.seekTo(videoPlayerRef.current.getCurrentTime() + 10);<br> };</pre><p>Next, we pass the functions as props to the <code>Control</code> component:
e>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward ={handleFastFoward }<br>         /&gt;</pre><p>Then, we receive the props and pass the two functions into their respective buttons.
e>&lt;div className=&quot;icon__btn&quot; onDoubleClick={onRewind}&gt;<br> &lt;FastRewind fontSize=&quot;medium&quot; /&gt;<br> &lt;/div&gt;<br><br><br> &lt;div className=&quot;icon__btn&quot;&gt;<br> &lt;FastForward fontSize=&quot;medium&quot; onDoubleClick={onForward}/&gt;<br> &lt;/div&gt;</pre><p>We can now fast-forward and rewind our video using the code above. However, you&#x27;ll also notice that the video player&#x27;s slider doesn&#x27;t move to the current time when we rewind or fast-forward the video. Let&#x27;s fix that, since we&#x27;re problem solvers, right?
### Seek Functionality
The <code>ReactPlayer</code> has an <code>onProgress</code> prop callback for this feature, which is a <code>Callback</code> that contains played and loaded progress as a fraction as well as <code>playedSeconds</code> and loaded seconds.
e>const progressHandler = (state) =&gt; {<br> <br>   if (!seeking) {<br> setVideoState({ ...videoState, ...state });<br>   }<br> };</pre><p>The <code>progressHandler</code> function accepts an argument called <code>state</code>. This <code>state</code> argument indicates an object with contained states. Every time the video player seek bar (the player&#x27;s timing) updates, some sets of states are altered, and new values are returned. We keep the values of the previously modified States and our <code>videoState</code> properties in this function. We want this to happen, but only when the value of the seeking property in our <code>videoState</code> is negated.
Next, we pass in the <code>progressHandler</code> function to the <code>onProgess</code> prop in the <code>ReactPlayer</code>:
e>&lt;ReactPlayer<br>           ref={videoPlayerRef}<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           muted={muted}<br>           onProgress = {progressHandler}<br>         /&gt;</pre><p>Then, to update our seek slider to the appropriate time of the video, we pass the <code>played</code> state that we&#x27;ve destructured from the <code>videoState</code> to the control component as a prop.
e>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward ={handleFastFoward }<br>           played ={played}<br>/&gt;</pre><p>The <code>PrettoSlider</code> in our <code>control</code> component then has to be updated. The maximum value for our <code>PrettoSlider</code> must be 100, and the minimum value must be set to 0. The value prop is the slider&#x27;s <code>current e.target.value</code>, which multiplies the value of the <code>played</code> props by 100.
e>&lt;PrettoSlider<br>         min = {0}<br>         max = {100}<br>         value = {played * 100}<br>/&gt;</pre><p>Furthermore, we need to write functions that will enable us to use the video player slider to look for a specific moment. To do this, we&#x27;d create a <code>seekHandler</code> and a <code>seekMouseUpHandler</code> to help us achieve this feature.
e>const seekHandler = (e, value) =&gt; {<br>   setVideoState({ ...videoState, played: parseFloat(value) / 100 });<br> };<br><br> const seekMouseUpHandler = (e, value ) =&gt; {<br>   setVideoState({ ...videoState, seeking: false });<br>   videoPlayerRef.current.seekTo(value / 100);<br> };</pre><p>We then pass these functions as props to the <code>control</code> component. The parameter given to the function is the value we immediately receive whenever the slider moves. Then, since <code>played</code> only accepts values between 0 and 1, we only updated the <code>played</code> value to the value argument divided by 100 when updating the <code>videoState</code>.
Additionally, we gave the <code>mouseSeekUpHandler</code> function an argument called <code>value</code>. Spreading the previous state and changing only the <code>seeking</code><strong> </strong>state value to <code>false</code>, which allows us to update the <code>videoState</code>. Then, we change the video&#x27;s current time to the desired time.
e>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward ={handleFastFoward }<br>           played ={played}<br>           onSeek ={seekHandler}<br>           onSeekMouseUp ={seekMouseUpHandler}<br>         /&gt;</pre><p>To use these two functions, the <code>PrettoSlider</code> has two props which we can use for this functionality: <code>onChange</code><strong> </strong>and <code>onChangeCommitted</code><strong>. </strong>According to the <u><a href="https://mui.com/material-ui/api/slider/" target="_blank" rel="noopener noreferrer">MUI docs, </a></u>the <code>onChange</code> prop is a Callback function that fires whenever the slider&#x27;s value changes, while the <code>onChangeCommitted</code><strong> </strong>is a<strong> </strong>Callback function that fires when the mouse moves up.
This is what our video player should look like now:
![](s://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab97690f9b426a9_image2_937acdde5d84b19a9ed571a7a27c68b3.g)
## Volume Functionality
We should have the option to mute and increase/decrease the video’s volume in our React player. The icon should then change to ‘muted’ or ‘volume-up’, depending on the volume setting in that situation.
Let’s head over to our App.js file.
e>const volumeChangeHandler = (e, value) =&gt; {<br> const newVolume = parseFloat(value) / 100;<br>   setVideoState({<br>     ...videoState,<br>     volume: newVolume,<br>     muted: Number(newVolume) === 0 ? true : false, // volume === 0 then muted<br>   })<br><br>};<br><br>const volumeSeekUpHandler = (e, value) =&gt; {<br> const newVolume = parseFloat(value) / 100;<br>   setVideoState({<br>     ...videoState,<br>     volume: newVolume,<br>     muted: newVolume === 0 ? true : false,<br>   })};</pre><p>There is a volume prop for this functionality in the <code>ReactPlayer</code> where we pass the destructured <code>volume</code><strong> </strong>from our <code>videoState</code>.
e>&lt;ReactPlayer<br>           ref={videoPlayerRef}<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           volume = {volume}<br>           muted={muted}<br>           onProgress={progressHandler}<br>         /&gt;</pre><p>The volume slider needs to define two functions, one for the <code>onChange</code> event and the other for the <code>onChangeCommitted</code> event, just like the <code>PrettoSlider</code>.
Now, we pass them as props to the <code>control</code> component:
e>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br><br>Volume={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>         /&gt;</pre><p>The volume slider is then updated by including new props, the <code>onChange</code> event, the <code>onChangeCommitted</code> event, and <code>value</code>, and passing the <code>onVolumeChangeHandler</code><strong>,</strong> <code>onVolumeSeekUp</code><strong>, </strong>and <code>volume</code> props. 
We ought to be able to choose between <code>muted</code> and <code>volume up</code> whenever the mute button is clicked. The symbol should switch to ‘muted’ or ‘volume-up’ depending on the volume level.
We’ll start by writing a function that handles the mute functionality in our App.js file.
e>const muteHandler = () =&gt; {<br> //Mutes the video player<br>   setVideoState({ ...videoState, muted: !videoState.muted });<br> };</pre><p>In the <code>muteHandler</code><strong>, </strong>we retained everything in the <code>videoState</code> and changed the <code>muted</code> property to have a value opposite of the current <code>muted</code> state, thereby toggling it and then passing the <code>muted</code> props to the <code>control</code> component.
e>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br>           volume ={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>           mute = {muted}<br>           onMute = {muteHandler}<br>         /&gt;<br><br>&lt;div className=&quot;icon__btn&quot; onClick={onMute} &gt;<br>           {mute ? (<br> &lt;VolumeOff fontSize=&quot;medium&quot; /&gt;<br>               ) : (<br> &lt;VolumeUp fontSize=&quot;medium&quot; /&gt;<br>               )}<br> &lt;/div&gt;</pre><p>The value of the <code>videoState</code> field&#x27;s <code>muted</code> state determines how the two icons in the above code would render conditionally. It also passes in a function to the wrapper, which toggles the mute functionality.
This is how our video should function:
![](ttps://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab9767aceb42693_image6_f5491d002e8bb4ebeec2977724064f6c.g)
### Video Time Functionality
Video players, as we all know, typically show the video&#x27;s current time. To accomplish this, we use some instance methods that <u><a href="https://www.npmjs.com/package/react-player" target="_blank" rel="noopener noreferrer">React Player</a></u> offers:
- <code>getCurrentTime</code>: Returns the number of seconds that have been played.
- <code>getDuration</code>: Returns the currently playing media’s total duration (in seconds).
- <code>getSecondsLoaded</code>: Returns the number of seconds that have been loaded.
e>const currentTime = videoPlayerRef.current? videoPlayerRef.current.getCurrentTime(): &quot;00:00&quot;;<br><br>const duration = videoPlayerRef.current? videoPlayerRef.current.getDuration(): &quot;00:00&quot;;</pre><p>We still need to format the returned time according to our preferences, even though the <code>currentTime</code> and <code>duration</code> are rendered conditionally using ternary operators.
A function that formats the timing must be created. After accepting an argument, this function will return the time in a specific format.
To use the function in App.js, we create a new file called Format.js inside the component folder.
e>export const formatTime = (time) =&gt; {<br> //formarting duration of video<br> if (isNaN(time)) {<br> return &quot;00:00&quot;;<br>   }<br><br> const date = new Date(time * 1000);<br> const hours = date.getUTCHours();<br> const minutes = date.getUTCMinutes();<br> const seconds = date.getUTCSeconds().toString().padStart(2, &quot;0&quot;);<br> if (hours) {<br> //if video have hours<br> return &#x60;${hours}:${minutes.toString().padStart(2, &quot;0&quot;)} &#x60;;<br>   } else return &#x60;${minutes}:${seconds}&#x60;;<br> };</pre><p>Following that, import the <code>formatTime</code><strong> </strong>method found in the Format.js file. Therefore, in the App.js file, we can use it. Then, two <code>formatTime</code> calls are made, with the <code>currentTime</code> and <code>duration</code> being passed as arguments.
e>const formatCurrentTime = formatTime(currentTime)<br><br>const formatDuration = formatTime(duration)</pre><p>We then pass the <code>formatCurrentTime</code><strong> </strong>and <code>formatDuration</code><strong> </strong>as props to the <code>control</code><strong> </strong>component.
e>&lt;Control<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br>           volume ={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>           mute = {muted}<br>           onMute = {muteHandler}<br>           duration = {formatDuration}<br>           currentTime = {formatCurrentTime}<br>         /&gt;</pre><p>Finally, modify the default timing value to this:
e>&lt;span&gt;{ currentTime} : {duration}&lt;/span&gt;</pre><p>Now, you can watch the length of the video as it plays and see how much time has passed. Watch the timing as the seek bar is dragged.
![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab976606bb42691_image1_235e2e72f5ac6a241fd2c46a4d9d4284.g)
The <code>Control</code> container div is frequently resting on the player, as you can see. Let&#x27;s make it more interesting by having it resemble other video players— let’s make it visible whenever we hover on the video player.
To achieve this feature, we also need to create a reference of the <code>div</code><strong> </strong>with classname of <code>control_Container</code><strong> </strong>in the App.js file:
e>const controlRef = useRef(null)</pre><p>And pass it to the <code>control</code><strong> </strong>component:
e>&lt;Control<br>         controlRef = {controlRef}<br>           onPlayPause={playPauseHandler}<br>           playing={playing}<br>           onRewind={rewindHandler}<br>           onForward={handleFastFoward}<br>           played={played}<br>           onSeek={seekHandler}<br>           onSeekMouseUp={seekMouseUpHandler}<br>           volume ={volume}<br>           onVolumeChangeHandler = {volumeChangeHandler}<br>           onVolumeSeekUp = {volumeSeekUpHandler}<br>           mute = {muted}<br>           onMute = {muteHandler}<br>           playRate = {playbackRate}<br>           onPlayRate = {playBackRateHandler}<br>           duration = {formatDuration}<br>           currentTime = {formatCurrentTime}<br>         /&gt;</pre><p>We then pass it to the <code>ref</code> property on the <code>control_Container</code><strong> </strong>div in the <code>control</code><strong> </strong>component:
e>const Control = ({controlRef}) =&gt; {<br> return (<br> &lt;div className=&quot;control_Container&quot; ref ={controlRef}&gt;<br>    // &lt;-- body of the control component ---&gt;<br> <br> &lt;/div&gt;<br> );<br>};<br><br>export default Control;</pre><p>Next, we head over to our App.js and declare a new variable called <code>count</code><strong> </strong>which will be equal to 0:
e>Let count = 0<br><br>const App = () =&gt; {<br> return (<br> &lt;div&gt;<br>    // &lt;-- body of the App component ---&gt;<br> <br> &lt;/div&gt;<br> );<br>};<br><br>export default App;</pre><p>We include an <code>if</code> statement inside the <code>progressHandler</code> function to determine whether the <code>count</code> exceeds 3, at which point we use the <code>controlRef</code><strong> </strong>and set the visibility to <code>hidden</code>. By doing so, the <code>control</code> component div is hidden.
e>const progressHandler = (state) =&gt; {<br>   if (count &gt; 3)<br><br>// toggling player control container<br><br>controlRef.current.style.visibility = &quot;hidden&quot;;<br>   } else if (controlRef.current.style.visibility === &quot;visible&quot;) {<br>     count += 1;<br>   }<br><br>   if (!seeking) {<br> setVideoState({ ...videoState, ...state });<br>   }<br> };</pre><p>We must create another function to make the control div visible whenever the player is hovered over.
e>const mouseMoveHandler = () =&gt; {<br>   controlRef.current.style.visibility = &quot;visible&quot;;<br> count = 0;<br> };<br><br>const App = () =&gt; {<br> return (<br> &lt;div&gt;<br>    // &lt;-- body of the App component ---&gt;<br> &lt;div onMouseDown = {mouseMoveHandler} &gt; <br> &lt;ReactPlayer/&gt;<br> &lt;Control/&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br> );<br>};<br><br>export default App;</pre><p>Our player now looks like this:
![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/637f8e3b4ab976922fb42685_image4_9a975ad265973fadcd05a97d63bd56fd.g)
### Buffering Functionality in our React Player
When we watch videos online, they frequently stall, primarily because of poor network connections. Let&#x27;s add a similar feature to our video player.
The ReactPlayer provides two props that accept a callback for this feature: <code>onBuffer</code><strong> </strong>and<strong> </strong><code>onBufferEnd</code>.
e>const bufferStartHandler = () =&gt; {<br> console.log(&quot;Bufering.......&quot;);<br>   setVideoState({...videoState , buffer: true})<br> };<br><br> const bufferEndHandler = () =&gt; {<br> console.log(&quot;buffering stoped ,,,,,,play&quot;);<br>   setVideoState({...videoState , buffer: false})<br> };</pre><p>These two functions will be passed to the <code>onBuffer</code><strong> </strong>and<strong> </strong><code>onBufferEnd</code>.
e>&lt;ReactPlayer<br>           ref={videoPlayerRef}<br>           className=&quot;player&quot;<br>           url=&quot;https://bucket-viewer.s3.amazonaws.com/viewer1664370329252.mp4&quot;<br>           width=&quot;100%&quot;<br>           height=&quot;100%&quot;<br>           playing={playing}<br>           volume={volume}<br>           muted={muted}<br>           onProgress={progressHandler}<br>           playbackRate={playBackRateHandler}<br>           onBuffer={bufferStartHandler}<br>           onBufferEnd={bufferEndHandler}<br>         /&gt;</pre><p>The last step alerts users when a video freezes. The buffer state must be <code>true</code> to render a load effectively.
Observe the <code>Loading</code><strong> </strong>text when the video freezes.
## Conclusion
This post taught us how to construct and modify a video player using the <code>react-player</code> package and <code>Material UI</code><strong> </strong>to style and import the required icons. Of course, you can always improve the build by including a few special features to make the player entirely custom.
