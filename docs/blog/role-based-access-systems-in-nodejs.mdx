![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dc2c88ea6b768a29e7bc40_rbas_0a501eaba791ca3c6b7e0211fa2d1bcd_2000.jpeg)
"access; node-js"
# Role-based access systems in Node.js
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="A stylized image of someone working at a computer." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dc2c88ea6b769677e7bc41_rbas_4ba4db01a2973fe29ad3762e1b3f99bb_800.jpeg"><div.new.line><figure.new.line><p>Many times, organizations of all sizes require web developers to limit access to certain resources and the rights to implement certain effects based on the hierarchy of users in the system. In this article, we'll be looking at how we can implement a role-based access system in our<a href="https://www.w3schools.com/nodejs/nodejs_intro.asp" target="_blank" rel="noopener noreferrer"> Node.js</a> server.<p.new.line><p>To be able to follow the rest of the article, you need the following:<p.new.line><ul><li>Working knowledge of JavaScript<li.new.line><li>A good understanding of Node.js and how to use it to create a server<li.new.line><li>Working understanding of database creation with Mongoose<li.new.line><li>Postman and knowledge of how to use Postman<li.new.line><ul.new.line><p>Before we continue, let's explain some concepts.<p.new.line><h2 id="2uib6">What is a Role-based access system?<h2.new.line><p>A Role-based access control (<a href="https://www.imperva.com/learn/data-security/role-based-access-control-rbac/" target="_blank" rel="noopener noreferrer">RBAC</a>) is a security approach that restricts network access and assigns permissions to users based on their role within an organization.<p.new.line><p>A simple example of a role-based access system is a blog with a set of permissions that allows users to create, edit, read, or delete articles in a writing application. For this blog, we could implement three roles:<p.new.line><ol type="1"><li>Reader<li.new.line><li>Writer<li.new.line><li>Admin<li.new.line></ol><p>The Reader can only read an article, the Writer has permission to create, edit, delete and read articles, and the Admin can add or remove a Writer. With a role-based system in place, a Reader will not be able to access the Writer's role and a Writer will not be able to carry out the Admin's role.<p.new.line><h2 id="9o2fe">How does a Role-based access system work?<h2.new.line><p>Role-based access systems rely on every user or entity within a system having a designated role. This role determines their permissions. Here's how it works:<p.new.line><ul><li>When a user creates an account, a role is assigned to the account based on its group. This role is then stored alongside other information in the database.<li.new.line><li>When the user attempts to access a protected route, our middleware retrieves the user's information from the database.<li.new.line><li>The user's role is cross-checked to confirm if the role of the user matches the required role to access the information requested.<li.new.line><li>If the user's role matches the required role, access is granted. If not, access will be denied.<li.new.line><ul.new.line><h3 id="8ka2m">Advantages of a role-based access system<h3.new.line><p>The following are the benefits of using a role-based access system:<p.new.line><ul><li><strong>Security</strong>: Coupled with proper authentication processes, RBAC enhances overall security as it pertains to privacy, confidentiality, and access management to resources and other sensitive data and systems.<li.new.line><li><strong>Reduces susceptibility to cyber attacks</strong>: As different groups have different roles and no one person has sole control of the system, cyber-attacks on a single account are less likely to cause substantial harm to systems.<li.new.line><li><strong>Decreases unnecessary customer support: </strong>In some systems, multiple passwords are assigned to a user for different routes and endpoints. The more passwords are assigned to a user, the more likely they are to forget them. Role-based access control takes away the need for multiple passwords and instead grants access based on the initial role assigned to a user.<li.new.line><li><strong>Establishing organizational structures:</strong> RBAC makes it easy to distinguish which user is responsible for each task. This makes it easier to know who did what and uncover the culprit of an information leak or a network issue.<li.new.line><ul.new.line><h3 id="7b34r">Disadvantages of a Role-based access system<h3.new.line><p>Despite the numerous advantages of a role-based access system, there are certain downsides to this system. Some of these are:<p.new.line><ul><li><strong>Role explosion: </strong>When a new worker or team is onboarded and their duties haven't been properly outlined, more roles may be created. Similarly, when a user from a different group requires access to information from another group, a new role is assigned to this user. The addition of many roles makes it difficult to keep track of who has access to what, making the role structure increasingly complex and compromising the effectiveness of the system.<li.new.line><li><strong>Conflicting combinations: </strong>Different roles assigned to different users can contain conflicting access. For example, it’s possible that a user can be given given a role that enables them to create an order and the role required to approve the same order. This can create business threats.<li.new.line><ul.new.line><h2 id="fgop6">Best practices for implementing a role-based access system<h2.new.line><p>When building a role-based access system, there are certain things to consider and actions to be taken to maintain the system and reduce confusion. Some of these are:<p.new.line><ul><li><strong>Define</strong> data and resources to which access should be restricted.<li.new.line><li><strong>Classify </strong>users into different groups based on their roles and required access to certain information. Any unnecessary exceptions should be cleaned up.<li.new.line><li><strong>Avoid creating too many roles</strong>. Creating too many roles defeats the purpose of the system and might lead to role explosion.<li.new.line><li><strong>Make roles reusable.</strong>  If only one user in a system has a particular role, that role should not be managed by a role-based system. All defined roles should apply to groups of people, otherwise, you'll have too many roles.<li.new.line><li><strong>Analyze</strong> how roles can be changed when necessary, how new users can be registered, and how old accounts can be deleted from a group.<li.new.line><li><strong>Continually adapt</strong>. The first iteration of a role-based system will require some changes, so the system should be continually checked and adapted to encompass a growing organization.<li.new.line><ul.new.line><h2 id="do815">Building our Node.js web server<h2.new.line><p>For better understanding we'll be building a server for a company that has three departments:<p.new.line><ol type="1"><li>Software Engineering Department<li.new.line><li>Marketing Department<li.new.line><li>Human Resources Department<li.new.line></ol><p>To build our server, we'll do the following:<p.new.line><ul><li>First, we'll create a directory for our server. Navigate to a suitable directory and run the following code in your terminal:<li.new.line><ul.new.line><pre>mkdir Company-Server</pre><ul><li>After creating our directory we'll navigate to this directory and initialize npm:<li.new.line><ul.new.line><pre>npm init</pre><h3 id="25fse">Installing required packages<h3.new.line><p>For this project, we'll use the following dependencies and packages:<p.new.line><ul><li><strong><a href="https://www.npmjs.com/package/dotenv" target="_blank" rel="noopener noreferrer">dotenv:</a> </strong>This package loads environmental variables from an env file into Node’s process.env object.<li.new.line><li><strong><a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="noopener noreferrer">bcrypt</a></strong>: This is used to hash our passwords and other sensitive information before sending them to the database to protect us against a breach of our database.<li.new.line><li><strong><a href="https://www.npmjs.com/package/body-parser" target="_blank" rel="noopener noreferrer">body-parser</a></strong>: This is used to parse incoming data from the request body and attaches the parsed value to an object which can then be accessed by an express middleware.<li.new.line><li><strong><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener noreferrer">jsonwebtoken</a></strong>: This provides a means of representing claims transferred between two parties, ensuring that the information transferred has not been tampered with by an unauthorized third party.<li.new.line><li><strong><a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer">Express.js</a></strong>: This makes building APIs and server-side applications with Node effortless by providing us with useful features such as routing, implementing middleware, and so on.<li.new.line><li><strong><a href="https://mongoosejs.com/" target="_blank" rel="noopener noreferrer">Mongoose</a></strong>: Helps us connect with our database and provides features such as schema validation, managing relationships between data, etc.<li.new.line><ul.new.line><pre>npm i jsonwebtoken mongoose bcrpyt body-parser express dotenv</pre><h3 id="1f08h">Setting up our Database<h3.new.line><p>For our database, we'll be using a mongo atlas database. You can create an account and easily link it to your Express server by following these steps:<p.new.line><p>To create our employee schema, copy the code below:<p.new.line><pre>const { Schema, model } = require(&quot;mongoose&quot;);<br><br>const EmployeeSchema = new Schema(<br>  {<br>    name: {<br>      type: String,<br>      required: true,<br>    },<br>    email: {<br>      type: String,<br>      required: true,<br>    },<br>    role: {<br>      type: String,<br>      enum: [&quot;se&quot;, &quot;marketer&quot;, &quot;HR&quot;, &quot;admin&quot;],<br>    },<br>    password: {<br>      type: String,<br>      required: true,<br>    },<br>  },<br>  { timestamps: true }<br>);<br><br>module.exports = model(&quot;Employee&quot;, EmployeeSchema);</pre><h3 id="fj75m">Setting up User Authentication<h3.new.line><p>Before the role-based access system checks for the role of the user, we'll need to set up a route to get our employees into the system. After this, we'll grant them access to certain resources based on their roles.<p.new.line><p>We’ll set up our logic for user signup, login, and authentication. Let’s start with signup.<p.new.line><h4 id="8kba5">User Signup<h4.new.line><p>For our Signup endpoint, we will do the following:<p.new.line><ul><li>Receive the user's information from the frontend request<li.new.line><li>Hash the password<li.new.line><li>Send the information to our database<li.new.line><li>Redirect the employee to the sign-in route<li.new.line><ul.new.line><pre>const bycrypt = require('brypt');<br>const Employee = require(&quot;../Database/employee&quot;);<br><br>const employeeSignup = async (req, role, res) =&gt; {<br>  try {<br>    //Get employee from database with same name if any<br>    const validateEmployeename = async (name) =&gt; {<br>      let employee = await Employee.findOne({ name });<br>      return employee ? false : true;<br>    };<br><br>    //Get employee from database with same email if any<br>    const validateEmail = async (email) =&gt; {<br>      let employee = await Employee.findOne({ email });<br>      return employee ? false : true;<br>    };<br>    // Validate the name<br>    let nameNotTaken = await validateEmployeename(req.name);<br>    if (!nameNotTaken) {<br>      return res.status(400).json({<br>        message: &#x60;Employee name is already taken.&#x60;,<br>      });<br>    }<br><br>    // validate the email<br>    let emailNotRegistered = await validateEmail(req.email);<br>    if (!emailNotRegistered) {<br>      return res.status(400).json({<br>        message: &#x60;Email is already registered.&#x60;,<br>      });<br>    }<br><br>// Hash password using bcrypt<br>    const password = await bcrypt.hash(req.password, 12);<br>    // create a new user<br>    const newEmployee = new Employee ({<br>      ...req,<br>      password,<br>      role<br>    });<br><br>    await newEmployee .save();<br>    return res.status(201).json({<br>      message: &quot;Hurry! now you are successfully registred. Please nor login.&quot;<br>    });<br>  } catch (err) {<br>    // Implement logger function if any<br>    return res.status(500).json({<br>      message: &#x60;${err.message}&#x60;<br>    });<br>  }<br>};</pre><p>With that done, we have set up our signup logic. Let's set up our login logic.<p.new.line><h4 id="3dvkf">User login<h4.new.line><p>Every employee that wants to log in has to log in from the route designed for his department. For example, if a software engineer tries to sign into the system via the login route for the marketing department, access will be denied.<p.new.line><p>For our login route we'll do the following:<p.new.line><ul><li>Receive the employee's information from the front-end request<li.new.line><li>Verify that the employee exists in our database<li.new.line><li>Check if the employee is signing in via the correct route for their department<li.new.line><li>If the user is signing in through the route for their department, we'll then check if the password is correct<li.new.line><li>If the password is correct, the user information coupled with a JWT token will be sent to the client side<li.new.line><ul.new.line><pre>const jwt = require(&quot;jsonwebtoken&quot;);<br>require('dotenv').config();<br>const Employee = require(&quot;../Database/employee&quot;);<br><br>const employeeLogin = async (req, role, res) =&gt; {<br>  let { name, password } = req;<br><br>  // First Check if the user exist in the database<br>  const employee = await Employee.findOne({ name });<br>  if (!employee) {<br>    return res.status(404).json({<br>      message: &quot;Employee name is not found. Invalid login credentials.&quot;,<br>      success: false,<br>    });<br>  }<br>  // We will check the if the employee is logging in via the route for his departemnt<br>  if (employee.role !== role) {<br>    return res.status(403).json({<br>      message: &quot;Please make sure you are logging in from the right portal.&quot;,<br>      success: false,<br>    });<br>  }<br><br>  // That means the employee is existing and trying to signin fro the right portal<br>  // Now check if the password match<br>  let isMatch = await bcrypt.compare(password, employee.password);<br>  if (isMatch) {<br>    // if the password match Sign a the token and issue it to the employee<br>    let token = jwt.sign(<br>      {<br>        role: employee.role,<br>        name: employee.name,<br>        email: employee.email,<br>      },<br>      process.env.APP_SECRET,<br>      { expiresIn: &quot;3 days&quot; }<br>    );<br><br>    let result = {<br>      name: employee.name,<br>      role: employee.role,<br>      email: employee.email,<br>      token: &#x60;Bearer ${token}&#x60;,<br>      expiresIn: 168,<br>    };<br><br>    return res.status(200).json({<br>      ...result,<br>      message: &quot;You are now logged in.&quot;,<br>    });<br>  } else {<br>    return res.status(403).json({<br>      message: &quot;Incorrect password.&quot;,<br>    });<br>  }<br>};</pre><h3 id="a73c4">Adding our role-based access system to our server<h3.new.line><p>Every logged-in user has a<a href="https://jwt.io/" target="_blank" rel="noopener noreferrer"> JWT</a> token; we'll create a<a href="https://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener noreferrer"> middleware</a> that checks for a token. The presence of a token indicates that the user is logged in. This middleware will also<a href="https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens" target="_blank" rel="noopener noreferrer"> verify</a> the token.<p.new.line><p>We'll also create another middleware for restricting access to certain routes to only users with specific roles.<p.new.line><pre>/**<br> * @DESC Verify JWT from authorization header Middleware<br> */<br>const employeeAuth = (req, res, next) =&gt; {<br>  const authHeader = req.headers[&quot;authorization&quot;];<br>  console.log(process.env.APP_SECRET);<br>  if (!authHeader) return res.sendStatus(403);<br>  console.log(authHeader); // Bearer token<br>  const token = authHeader.split(&quot; &quot;)[1];<br>  jwt.verify(token, process.env.APP_SECRET, (err, decoded) =&gt; {<br>    console.log(&quot;verifying&quot;);<br>    if (err) return res.sendStatus(403); //invalid token<br><br>    console.log(decoded); //for correct token<br>    next();<br>  });<br>};<br><br>/**<br> * @DESC Check Role Middleware<br> */<br>const checkRole = (roles) =&gt; async (req, res, next) =&gt; {<br>  let { name } = req.body;<br><br>  //retrieve employee info from DB<br>  const employee = await Employee.findOne({ name });<br>  !roles.includes(employee.role)<br>    ? res.status(401).json(&quot;Sorry you do not have access to this route&quot;)<br>    : next();<br>};</pre><p>The employee auth function checks for the presence of a JWT. If it finds any, it then checks if it is correct.<p.new.line><p>The checkrole function checks if the user requesting access has the required role to access that route.<p.new.line><h3 id="7etl8">Setting up our routes<h3.new.line><p>In this section, we'll be creating the following sets of routes and applying the required middleware.<p.new.line><ul><li>Sign-up routes for each department<li.new.line><li>Login routes for each department<li.new.line><li>Protected routes for each department<li.new.line><ul.new.line><pre>// Software engineering Registeration Route<br>app.post(&quot;/register-se&quot;, (req, res) =&gt; {<br>  employeeSignup(req.body, &quot;se&quot;, res);<br>});<br><br>//Marketer Registration Route<br>app.post(&quot;/register-marketer&quot;, async (req, res) =&gt; {<br>  await employeeSignup(req.body, &quot;marketer&quot;, res);<br>});<br><br>//Human resource Registration route<br>app.post(&quot;/register-hr&quot;, async (req, res) =&gt; {<br>  await employeeSignup(req.body, &quot;hr&quot;, res);<br>});<br><br>// Software engineers Login Route<br>app.post(&quot;/Login-se&quot;, async (req, res) =&gt; {<br>  await employeeLogin(req.body, &quot;se&quot;, res);<br>});<br><br>// Human Resource Login Route<br>app.post(&quot;/Login-hr&quot;, async (req, res) =&gt; {<br>  await employeeLogin(req.body, &quot;hr&quot;, res);<br>});<br><br>// Marketer Login Route<br>app.post(&quot;/Login-marketer&quot;, async (req, res) =&gt; {<br>  await employeeLogin(req.body, &quot;marketer&quot;, res);<br>});<br><br>app.get(&quot;/se-protected&quot;, employeeAuth, checkRole([&quot;se&quot;]), async (req, res) =&gt; {<br> return res.json(&#x60;welcome ${req.body.name}&#x60;);<br>});<br><br>app.get(<br>  &quot;/marketers-protected&quot;,<br>  employeeAuth,<br>  checkRole([&quot;marketer&quot;]),<br>  async (req, res) =&gt; {<br>    return res.json(&#x60;welcome ${req.body.name}&#x60;);<br>  }<br>);<br><br>app.get(&quot;/hr-protected&quot;, employeeAuth, checkRole([&quot;hr&quot;]), async (req, res) =&gt; {<br>  return res.json(&#x60;welcome ${req.body.name}&#x60;);<br>});</pre><h3 id="1a4r5">Testing our Application<h3.new.line><p>To test out our application, we'll be creating a demo user named Victor with a Software Engineering role.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Creating our demo user." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8e0eec99ee53_image4_5d66cab0db2ebe24c252cf40f94d590c_800.jpeg"><div.new.line><figure.new.line><p>With our user created, let's try logging in.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Logging in as a demo user." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8ee33699ee51_image2_f68cdafbafb824b5e274862947062d02_800.jpeg"><div.new.line><figure.new.line><p>Our user logged in correctly! Now, let's try logging in from the Human Resources department’s route.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Logging in to an incorrect route to test the application." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8ed09199ee50_image3_c1822bb330c637a0119591218a4f9954_800.jpeg"><div.new.line><figure.new.line><p>We can see that our user cannot log in via another department’s route. Success!<p.new.line><p>Now, let's try accessing the protected routes.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Accessing a protected route with our demo user." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8e6cac99ee54_image1_370ef3a443ca9d363654804e00914c6c_800.jpeg"><div.new.line><figure.new.line><p>Our user can access the software engineering protected route because that role is assigned to him. Let's try accessing the human resource route with our software engineering user.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Accessing a prevented route with our demo user." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8e8ea199ee52_image5_2802ea8f828cbd6bdd6e4c9597f984d3_800.jpeg"><div.new.line><figure.new.line><p>From the above images, we can see that all of our routes work as expected. They can all be tweaked, and more routes can be added with same logic, but I'll leave that to you.<p.new.line><h2 id="8u36f">Conclusion<h2.new.line><p>In this article, we talked about the Role-based access system, its benefits, and its downsides. We also looked at how we can implement a role-based access system in Node.js. Happy coding!<p.new.line><h3 id="9kl6i">Resources<h3.new.line><p><a href="https://github.com/King-AJr/rbacNodeServer" target="_blank" rel="noopener noreferrer">Repo</a><br><a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank" rel="noopener noreferrer">RBAC</a><br><a href="https://jwt.io/" target="_blank" rel="no
Many times, organizations of all sizes require web developers to limit access to certain resources and the rights to implement certain effects based on the hierarchy of users in the system. In this article, we'll be looking at how we can implement a role-based access system in our<a href="https://www.w3schools.com/nodejs/nodejs_intro.asp" target="_blank" rel="noopener noreferrer"> Node.js</a> server.
To be able to follow the rest of the article, you need the following:
- Working knowledge of JavaScript
- A good understanding of Node.js and how to use it to create a server
- Working understanding of database creation with Mongoose
- Postman and knowledge of how to use Postman
Before we continue, let's explain some concepts.
## What is a Role-based access system?
A Role-based access control (<a href="https://www.imperva.com/learn/data-security/role-based-access-control-rbac/" target="_blank" rel="noopener noreferrer">RBAC</a>) is a security approach that restricts network access and assigns permissions to users based on their role within an organization.
A simple example of a role-based access system is a blog with a set of permissions that allows users to create, edit, read, or delete articles in a writing application. For this blog, we could implement three roles:
- Writer
- Admin
## How does a Role-based access system work?
Role-based access systems rely on every user or entity within a system having a designated role. This role determines their permissions. Here's how it works:
- When a user creates an account, a role is assigned to the account based on its group. This role is then stored alongside other information in the database.
- When the user attempts to access a protected route, our middleware retrieves the user's information from the database.
- The user's role is cross-checked to confirm if the role of the user matches the required role to access the information requested.
- If the user's role matches the required role, access is granted. If not, access will be denied.
### Advantages of a role-based access system
The following are the benefits of using a role-based access system:
- <strong>Security</strong>: Coupled with proper authentication processes, RBAC enhances overall security as it pertains to privacy, confidentiality, and access management to resources and other sensitive data and systems.
- <strong>Reduces susceptibility to cyber attacks</strong>: As different groups have different roles and no one person has sole control of the system, cyber-attacks on a single account are less likely to cause substantial harm to systems.
- <strong>Decreases unnecessary customer support: </strong>In some systems, multiple passwords are assigned to a user for different routes and endpoints. The more passwords are assigned to a user, the more likely they are to forget them. Role-based access control takes away the need for multiple passwords and instead grants access based on the initial role assigned to a user.
- <strong>Establishing organizational structures:</strong> RBAC makes it easy to distinguish which user is responsible for each task. This makes it easier to know who did what and uncover the culprit of an information leak or a network issue.
### Disadvantages of a Role-based access system
Despite the numerous advantages of a role-based access system, there are certain downsides to this system. Some of these are:
- <strong>Role explosion: </strong>When a new worker or team is onboarded and their duties haven't been properly outlined, more roles may be created. Similarly, when a user from a different group requires access to information from another group, a new role is assigned to this user. The addition of many roles makes it difficult to keep track of who has access to what, making the role structure increasingly complex and compromising the effectiveness of the system.
- <strong>Conflicting combinations: </strong>Different roles assigned to different users can contain conflicting access. For example, it’s possible that a user can be given given a role that enables them to create an order and the role required to approve the same order. This can create business threats.
## Best practices for implementing a role-based access system
When building a role-based access system, there are certain things to consider and actions to be taken to maintain the system and reduce confusion. Some of these are:
- <strong>Define</strong> data and resources to which access should be restricted.
- <strong>Classify </strong>users into different groups based on their roles and required access to certain information. Any unnecessary exceptions should be cleaned up.
- <strong>Avoid creating too many roles</strong>. Creating too many roles defeats the purpose of the system and might lead to role explosion.
- <strong>Make roles reusable.</strong>  If only one user in a system has a particular role, that role should not be managed by a role-based system. All defined roles should apply to groups of people, otherwise, you'll have too many roles.
- <strong>Analyze</strong> how roles can be changed when necessary, how new users can be registered, and how old accounts can be deleted from a group.
- <strong>Continually adapt</strong>. The first iteration of a role-based system will require some changes, so the system should be continually checked and adapted to encompass a growing organization.
## Building our Node.js web server
For better understanding we'll be building a server for a company that has three departments:
- Marketing Department
- Human Resources Department
- First, we'll create a directory for our server. Navigate to a suitable directory and run the following code in your terminal:
For this project, we'll use the following dependencies and packages:
- <strong><a href="https://www.npmjs.com/package/dotenv" target="_blank" rel="noopener noreferrer">dotenv:</a> </strong>This package loads environmental variables from an env file into Node’s process.env object.
- <strong><a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="noopener noreferrer">bcrypt</a></strong>: This is used to hash our passwords and other sensitive information before sending them to the database to protect us against a breach of our database.
- <strong><a href="https://www.npmjs.com/package/body-parser" target="_blank" rel="noopener noreferrer">body-parser</a></strong>: This is used to parse incoming data from the request body and attaches the parsed value to an object which can then be accessed by an express middleware.
- <strong><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener noreferrer">jsonwebtoken</a></strong>: This provides a means of representing claims transferred between two parties, ensuring that the information transferred has not been tampered with by an unauthorized third party.
- <strong><a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer">Express.js</a></strong>: This makes building APIs and server-side applications with Node effortless by providing us with useful features such as routing, implementing middleware, and so on.
- <strong><a href="https://mongoosejs.com/" target="_blank" rel="noopener noreferrer">Mongoose</a></strong>: Helps us connect with our database and provides features such as schema validation, managing relationships between data, etc.
For our database, we'll be using a mongo atlas database. You can create an account and easily link it to your Express server by following these steps:
To create our employee schema, copy the code below:
Before the role-based access system checks for the role of the user, we'll need to set up a route to get our employees into the system. After this, we'll grant them access to certain resources based on their roles.
We’ll set up our logic for user signup, login, and authentication. Let’s start with signup.
For our Signup endpoint, we will do the following:
- Receive the user's information from the frontend request
- Hash the password
- Send the information to our database
- Redirect the employee to the sign-in route
e>const bycrypt = require('brypt');<br>const Employee = require(&quot;../Database/employee&quot;);<br><br>const employeeSignup = async (req, role, res) =&gt; {<br>  try {<br>    //Get employee from database with same name if any<br>    const validateEmployeename = async (name) =&gt; {<br>      let employee = await Employee.findOne({ name });<br>      return employee ? false : true;<br>    };<br><br>    //Get employee from database with same email if any<br>    const validateEmail = async (email) =&gt; {<br>      let employee = await Employee.findOne({ email });<br>      return employee ? false : true;<br>    };<br>    // Validate the name<br>    let nameNotTaken = await validateEmployeename(req.name);<br>    if (!nameNotTaken) {<br>      return res.status(400).json({<br>        message: &#x60;Employee name is already taken.&#x60;,<br>      });<br>    }<br><br>    // validate the email<br>    let emailNotRegistered = await validateEmail(req.email);<br>    if (!emailNotRegistered) {<br>      return res.status(400).json({<br>        message: &#x60;Email is already registered.&#x60;,<br>      });<br>    }<br><br>// Hash password using bcrypt<br>    const password = await bcrypt.hash(req.password, 12);<br>    // create a new user<br>    const newEmployee = new Employee ({<br>      ...req,<br>      password,<br>      role<br>    });<br><br>    await newEmployee .save();<br>    return res.status(201).json({<br>      message: &quot;Hurry! now you are successfully registred. Please nor login.&quot;<br>    });<br>  } catch (err) {<br>    // Implement logger function if any<br>    return res.status(500).json({<br>      message: &#x60;${err.message}&#x60;<br>    });<br>  }<br>};</pre><p>With that done, we have set up our signup logic. Let's set up our login logic.
Every employee that wants to log in has to log in from the route designed for his department. For example, if a software engineer tries to sign into the system via the login route for the marketing department, access will be denied.
For our login route we'll do the following:
- Receive the employee's information from the front-end request
- Verify that the employee exists in our database
- Check if the employee is signing in via the correct route for their department
- If the user is signing in through the route for their department, we'll then check if the password is correct
- If the password is correct, the user information coupled with a JWT token will be sent to the client side
Every logged-in user has a<a href="https://jwt.io/" target="_blank" rel="noopener noreferrer"> JWT</a> token; we'll create a<a href="https://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener noreferrer"> middleware</a> that checks for a token. The presence of a token indicates that the user is logged in. This middleware will also<a href="https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens" target="_blank" rel="noopener noreferrer"> verify</a> the token.
We'll also create another middleware for restricting access to certain routes to only users with specific roles.
e>/**<br> * @DESC Verify JWT from authorization header Middleware<br> */<br>const employeeAuth = (req, res, next) =&gt; {<br>  const authHeader = req.headers[&quot;authorization&quot;];<br>  console.log(process.env.APP_SECRET);<br>  if (!authHeader) return res.sendStatus(403);<br>  console.log(authHeader); // Bearer token<br>  const token = authHeader.split(&quot; &quot;)[1];<br>  jwt.verify(token, process.env.APP_SECRET, (err, decoded) =&gt; {<br>    console.log(&quot;verifying&quot;);<br>    if (err) return res.sendStatus(403); //invalid token<br><br>    console.log(decoded); //for correct token<br>    next();<br>  });<br>};<br><br>/**<br> * @DESC Check Role Middleware<br> */<br>const checkRole = (roles) =&gt; async (req, res, next) =&gt; {<br>  let { name } = req.body;<br><br>  //retrieve employee info from DB<br>  const employee = await Employee.findOne({ name });<br>  !roles.includes(employee.role)<br>    ? res.status(401).json(&quot;Sorry you do not have access to this route&quot;)<br>    : next();<br>};</pre><p>The employee auth function checks for the presence of a JWT. If it finds any, it then checks if it is correct.
The checkrole function checks if the user requesting access has the required role to access that route.
### Setting up our routes
In this section, we'll be creating the following sets of routes and applying the required middleware.
- Sign-up routes for each department
- Login routes for each department
- Protected routes for each department
To test out our application, we'll be creating a demo user named Victor with a Software Engineering role.
![](flow.com/6143afec68f555387049efb3/63c0198f139e8e0eec99ee53_image4_5d66cab0db2ebe24c252cf40f94d590c_800.jp)
With our user created, let's try logging in.
![](webflow.com/6143afec68f555387049efb3/63c0198f139e8ee33699ee51_image2_f68cdafbafb824b5e274862947062d02_800.jp)
Our user logged in correctly! Now, let's try logging in from the Human Resources department’s route.
![](ion." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8ed09199ee50_image3_c1822bb330c637a0119591218a4f9954_800.jp)
We can see that our user cannot log in via another department’s route. Success!
Now, let's try accessing the protected routes.
![]("https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8e6cac99ee54_image1_370ef3a443ca9d363654804e00914c6c_800.jp)
Our user can access the software engineering protected route because that role is assigned to him. Let's try accessing the human resource route with our software engineering user.
![]("https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63c0198f139e8e8ea199ee52_image5_2802ea8f828cbd6bdd6e4c9597f984d3_800.jp)
From the above images, we can see that all of our routes work as expected. They can all be tweaked, and more routes can be added with same logic, but I'll leave that to you.
## Conclusion
In this article, we talked about the Role-based access system, its benefits, and its downsides. We also looked at how we can implement a role-based access system in Node.js. Happy coding!
### Resources
