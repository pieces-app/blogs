![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ed5e6e4a15f41c999acf0f_MVVM.png)
"flutter; dart"
# Using MVVM Architecture in Flutter
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<h2 id=""><strong id="">What is Model-View-ViewModel?</strong><h2.new.line><p id=""><strong id="">Model-View-ViewModel (MVVM)</strong> Architecture is a unique combination of software architecture patterns that supports the separation of the UI (which is <strong id="">View</strong>) from the development of the business logic or the backend logic (<strong id="">Model</strong>). The view model inside MVVM is the bridge responsible for the conversion of data in a way that behaves in accordance with the changes happening in the UI.<p.new.line><p id="">In addition, to know about the responsibilities of the three components, it’s also important to understand how the components interact with each other. At the highest level, <em id="">the view “knows about” the view model</em>, and <em id="">the view model “knows about” the model</em>, but <em id="">the model is unaware of the view model</em>, and the <em id="">view model is unaware of the view</em>.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ead8e36a005d153f96fea4_0*Plj_xKz_2EwTrXQz.png" alt="A diagram showing the Flutter MVVM architecture." id="" width="auto" height="auto" loading="auto"><div.new.line><figcaption id="">Flutter MVVM Architecture</figcaption><figure.new.line><h2>Advantages and Disadvantages of MVVM<h2.new.line><p id="">There are several advantages of MVVM Architecture:<p.new.line><ul id=""><li id=""><strong id="">Separation of Concerns</strong>: This is a design principle for separating a computer program into distinct sections such that each section addresses a separate concern. A concern is anything that matters to provide a solution to a problem.<li.new.line><li id="">Improved testability<li.new.line><li id="">Defined project structure<li.new.line><li id="">Parallel development of UI<li.new.line><li id="">Abstracting the view, thus reducing the quantity of business logic required in the code behind it<li.new.line><ul.new.line><p id="">Some disadvantages of MVVM:<p.new.line><ul id=""><li id="">It has a somewhat steep learning curve. How all the layers work together may take some time to understand.<li.new.line><li id="">It adds a lot of extra classes, so it’s not ideal for low-complexity projects.<li.new.line><ul.new.line><p id="">Since architectural or MVVM design patterns are platform-agnostic, they can be used with any framework MVVM framework; in our case, <strong id="">Flutter</strong>. If you prefer visual learning, follow along with a <a href="https://www.youtube.com/watch?v=7Q9dxzIo314" target="_blank" id="">video version of this tutorial.</a><p.new.line><h2 id="">MVVM Components<h2.new.line><p id=""><strong id="">Model:</strong> This is basically the domain model, or the model which represents the data from your backend (i.e., the data access layer). Models hold information but typically don’t handle behavior. They don’t format information or influence how data appears. The Model in the MVVM pattern in Flutter represents the actual data that will be used in application development.<p.new.line><p id=""><strong id="">View:</strong> This is basically the only part of the application users actually interact with. For instance, the user presses the button, scrolls the list, edits the settings, etc. These events are then forwarded to the view model, which does the processing and returns the expected user response (which is some form of UI). It’s important to remember the <strong id="">View</strong> isn’t responsible here for handling the state.<p.new.line><p id="">A View should be as dumb as possible. Never put your business logic in a View.<p.new.line><p id=""><strong id="">ViewModel:</strong> The ViewModel acts as an intermediary between the <strong id="">View</strong> and the <strong id="">Model</strong>, in such a way that it provides data to the UI. The ViewModel may also expose methods for helping to maintain the View’s state, update the model based on the actions on a View, and trigger events on the View. In <strong id="">Flutter,</strong> we have a listener called <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" target="_blank" id="">ChangeNotifier</a> that allows the ViewModel to inform or update the View whenever the data is updated.<p.new.line><p id="">The ViewModel has basically two responsibilities:<p.new.line><ul id=""><li id="">It reacts to user inputs (e.g., by changing the model, initiating network requests, or routing to different screens)<li.new.line><li id="">It offers output data that the View can subscribe to<li.new.line><ul.new.line><p id="">In summary, the ViewModel sits behind the UI layer which is a <a href="https://code.pieces.app/blog/user-interface-neumorphism-glassmorphism">key user interface principle</a>. It exposes data needed by a View and can be viewed as the source our Views go to for both data and actions.<p.new.line><h3 id="">What is Flutter ChangeNotifier?<h3.new.line><p id=""><a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" target="_blank" id="">ChangeNotifier</a> is a class that provides change notifications to its listeners.<p.new.line><p id="">As per the official <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" target="_blank" id="">documentation</a>, a ChangeNotifier is:<p.new.line><p id="">A class that can be extended or mixed in that provides a change notification API using VoidCallback for notifications.<p.new.line><p id=""><em id="">It is O(1) for adding listeners and O(N) for removing listeners and dispatching notifications (where N is the number of listeners).</em><p.new.line><p id="">There are two ways to consume the ChangeNotifier in Flutter:<p.new.line><ol id=""><li id="">Using the <em id="">.addListener</em> method, as the ChangeNotifier is a type of <a href="https://api.flutter.dev/flutter/foundation/Listenable-class.html" target="_blank" id="">Listenable</a>.<li.new.line><li id="">Using a combination of <em id="">ChangeNotifierProvider,</em> <em id="">Consumer</em>, and <em id="">Provider.</em> These capabilities are provided to us by the <a href="https://pub.dev/packages/provider" target="_blank" id="">Provider</a> package.<li.new.line></ol><p id=""><strong id="">We will use approach 2 in the following flutter ChangeNotifier example.</strong><p.new.line><p id="">In the real world, other classes can <em id="">listen</em> to a <em id="">ChangeNotifier</em> object. When the change notifier gets updated values, it can call a method called <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" target="_blank" id="">notifyListeners</a>, and then any of its listeners will receive the updated values.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1054px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1054px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebad29e9ab9b75212857f3_raycast-untitled%20(67).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=2ce4479437" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Inside the app, any class that listens to this Person will be notified in case the age changes. Internally, notifyListeners calls the registered listeners.<p.new.line><h2 id="">Flutter MVVM Example<h2.new.line><p id="">Flutter is declarative in nature. This means that Flutter builds UI by overriding your build methods to reflect the current state of your app:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebad5c93dc2043f191b375_raycast-untitled%20(68).png" loading="lazy" id="" width="auto" height="auto" alt="Code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=5c8745be69" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">According to the <a href="https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app" target="_blank" id="">Flutter documentation</a>, the state is described as “the data you need to rebuild your UI at any point in time.”<p.new.line><p id="">A state can be contained in a single widget, known as a local state. Flutter provides inbuilt classes and methods to deal with self-contained states like <em id="">StatefulWidget </em>and <em id="">setState</em>.<p.new.line><p id="">However, a state that has to be shared across different widgets is known as an app state. It is at this point that we introduce state management tools.<p.new.line><p id=""><em id="">We will be using </em><a href="https://pub.dev/packages/provider" target="_blank" id=""><em id="">Provider</em></a><em id=""> for state management.</em><p.new.line><p id="">Let’s say you were architecting an application that includes only the screen below. How would you do it?<p.new.line><p id=""><em id="">Hint: Using Flutter MVVM</em><p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ead8e3e5898db7a261006c_1*KG0NtOrb3RIKXR4HJ2Amfw.png" alt="an example screen for a flutter architecture MVVM example." id="" width="auto" height="auto" loading="auto"><div.new.line><figure.new.line><p id="">Sample Screen<p.new.line><ul id=""><li id="">Each screen should comprise its own flutter MVVM folder structure. Create a folder called home which contains a view called <em id="">home_view</em>.<li.new.line><ul.new.line><h3 id=""><strong id="">Naming convention for View</strong>: <h3.new.line><p id="">Each screen is called “view” and the file is suffixed with <em id="">_view</em>. The view will be listening to the changes happening on the ViewModel Flutter, using the <a href="https://pub.dev/documentation/provider/latest/provider/Consumer-class.html" target="_blank" id=""><em id="">Consumer</em></a>.<p.new.line><ul id=""><li id="">Each view should have a ViewModel associated with it. Create a file called <em id="">home_view_model</em> which will be responsible for accepting the user interactions, processing them by running some business logic, and finally responding back.<li.new.line><ul.new.line><h3 id=""><strong id="">Naming convention for ViewModel</strong>:<h3.new.line><p id=""> Each screen has a ViewModel associated with it and the file is suffixed with <em id="">_view_model</em>. The ViewModel notifies the changes to the UI (if any) using <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" target="_blank" id="">notifyListeners</a>.<p.new.line><ul id=""><li id="">Let’s assume the button calls some API (more on that later) and responds back with some response. This response should be converted as a model suffixed with <em id="">_model </em>and returned from the ViewModel to the view.<li.new.line><ul.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ead8e3629c9081ff5d75c8_1*7kmY0bEok_LIUyU9Iv8akA.png" alt="MVVM Project structure example imagine." id="" width="auto" height="auto" loading="auto"><div.new.line><figcaption id="">MVVM&nbsp;Project Structure</figcaption><figure.new.line><p id="">These are the basics of MVVM architecture, as we can see in the screenshot above. This can be replicated for all of your app's screens. You can read more about <a href="https://code.pieces.app/blog/file-handling-web-development" target="_blank">The Best File Formats for Web Development</a> for a better understanding. Now, let’s see a slight addition on top of this structure.<p.new.line><h3 id="">Extending the MVVM toolkit with Repository and Services<h3.new.line><p id="">In the real world, our app needs to interact with APIs or third-party integrations. So, we introduce something called a Repository.<p.new.line><p id="">A repository pattern provides an abstraction of data so that your application can work with a simple abstraction that has an interface. Using this pattern can help to achieve loose coupling. If implemented correctly, the Repository pattern can be a great way to ensure you follow the <em id="">Single Responsibility Principle</em> for your data access code.<p.new.line><p id="">Some benefits of using the Repository pattern:<p.new.line><ol id=""><li id="">It separates the business logic for accessing external services<li.new.line><li id="">It makes mocking easier and allows to do unit tests<li.new.line><li id="">It easily switches data sources without doing time-consuming code changes<li.new.line></ol><p id="">Some disadvantages of using the Repository pattern:<p.new.line><ol id=""><li id="">It adds another layer of abstraction, which adds a certain level of complexity, making it overkill for small applications.<li.new.line></ol><p id="">Continuing with the previous example, let’s say our button needs to call an API. Let’s implement it using the <em id="">Repository</em> pattern.<p.new.line><p id="">Dart has no interfaces, like Java, but we can create one with an abstract class. We begin by creating an abstract class that defines the interface for our home_repo.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebae923c40995a14e4ae33_raycast-untitled%20(69).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=9e2b429fe1" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">This abstract class helps to create a boundary, and we are free to work on either side of that boundary. We could work on implementing the home repository (<em id="">recommended</em>), or we could just use the implementation directly in our app (<em id="">not recommended</em>).<p.new.line><p id="">Here, the <em id="">HomeRepository</em> has only one method, <em id="">fetchData</em>. This method returns the response as a model called <em id="">CarouselModel</em>.<p.new.line><p id="">Next, let’s implement the <em id="">HomeRepository</em>:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1254px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1254px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebaf4ab4e31a3ef38ece9a_raycast-untitled%20(70).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=6e8d4189d5" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Inside the method <em id="">fetchData</em>, we introduce a delay and then load the data from the assets, which is a JSON file. This delay is basically a substitute for calling the API, <em id="">but I hope I am able to convey my thoughts to the reader.</em><p.new.line><p id="">As your application grows, you may find yourself adding more and more methods to a given repository. In this scenario, consider creating multiple repositories and keeping related methods together.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ead8e311ea59bb35c97110_1*q1BNWS5-00kEkAVE3ob9qw.png" alt="An example of MVVM folder structure Flutter." id="" width="auto" height="auto" loading="auto"><div.new.line><figcaption id="">Repository Pattern</figcaption><figure.new.line><p id="">Now, we have<p.new.line><ul id=""><li id=""><em id="">carousel_model</em> representing the <strong id="">Model (M)</strong><li.new.line><li id=""><em id="">home_view</em> representing the <strong id="">View (V)</strong><li.new.line><li id=""><em id="">home_view_model </em>representing the <strong id="">View Model (VM)</strong><li.new.line><li id=""><em id="">home_repo</em> representing the <strong id="">Repository</strong><li.new.line><ul.new.line><h3 id="">Register the Repository<h3.new.line><p id="">Since our repository is ready, now we need to figure out how to register it and make it available inside our app. This is when we introduce another concept called Dependency Injection (DI). We make use of the package <a href="https://pub.dev/packages/get_it" target="_blank" id="">get_it</a>. As per the documentation:<p.new.line><p id="">This is a simple Service Locator for Dart and Flutter projects with some additional goodies highly inspired by <em id="">Splat</em>. It can be used instead of <em id="">InheritedWidget</em> or <em id="">Provider </em>to access objects, e.g., from your UI.<p.new.line><p id=""><strong id="">GetIt is super fast</strong> because it uses just a <em id="">Map&lt;Type&gt;</em>, which makes access to it <strong id="">O(1).</strong> GetIt itself is a singleton, so you can access it from everywhere using its instance property (see below).<p.new.line><p id="">We install <em id="">get_it</em> it by including it inside the <em id="">pubspec.yaml </em>as:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb0137f7f913219aa4b8f_raycast-untitled%20(71).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=79cf469234" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Typically at the start of your app, you register the types that you want to later access from anywhere. After that, you can access instances of the registered types by calling the locator again.<p.new.line><p id="">The nice thing is you can register an interface or abstract class together with a concrete implementation. When accessing the instance, you always ask for the interface/abstract class type. This makes it easy to switch the implementation by just switching the concrete type at registration time.<p.new.line><p id="">We create a file called <em id="">locator.dart</em> inside which we will instantiate the object of <em id="">get_it</em>:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb06cef7fa5045c9734e5_raycast-untitled%20(72).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code that helps to build MVVM Architecture."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=b47845a2c2" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">As Dart supports global variables, we assign the GetIt instance to a global variable to make access to it as easy as possible.<p.new.line><p id="">Although GetIt is a singleton, we will assign its instance to a global variable<em id=""> locator </em>to minimize the code for accessing GetIt. Any call to <em id="">locator</em> in any package of a project will get the same instance of <em id="">GetIt</em>.<p.new.line><p id="">Next, we use the <em id="">locator</em> and use the <em id="">registerFactory</em> to register our <em id="">HomeRepository</em>.<p.new.line><p>Note: if you like these Dart snippets, check out our collection of <a href="https://code.pieces.app/collections/dart" id="">Dart code samples</a>.<p.new.line><h4 id="">Provider as an alternative to GetIt<h4.new.line><p id="">Provider is a powerful alternative to GetIt. But there are some reasons why people use GetIt for Dependency injection:<p.new.line><ul id=""><li id="">Provider needs a <em id="">BuildContext</em> to access the registered objects, so you can’t use it inside business objects outside of the widget tree or in a pure Dart MVVM package.<li.new.line><li id="">Provider adds its own widget classes to the widget tree that are no GUI elements, but are needed to access the in Provider registered objects.<li.new.line><ul.new.line><h4 id="">Testing Repository<h4.new.line><p id="">You can implement unit testing for different elements of your Flutter applications, such as widgets, controllers, models, services, and repositories. It’s possible to unit test repository-based Flutter codebases with the following strategies:<p.new.line><ul id=""><li id="">Implement a mock repository class and test the logic<li.new.line><li id="">You don’t need to implement mock classes by yourself — the <a href="https://pub.dev/packages/mockito" target="_blank">Mockito package</a> helps you to generate them quickly and <a href="https://pub.dev/packages/mockito" target="_blank" id="">automatically</a>.<li.new.line><ul.new.line><h2 id="">Integrate Repository in ViewModel<h2.new.line><p id="">Now comes the time to use the Dependency Injection (DI). But before that, let’s see what it is.<p.new.line><p id="">When class A uses some functionality of class B, then it’s said that class A has a dependency of class B.<p.new.line><p id="">Before we can use methods of other classes, we first need to create the object of that class (i.e., class A needs to create an instance of class B).<p.new.line><p id=""><strong id="">Dependency injection is transferring the task of creating the object to someone else and directly using the dependency.</strong><p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ead8e3e38b9823c21f225c_0*0r7__ZZKUzZLQbt_.png" alt="A comic strip that illustrates dependency injection." id="" width="auto" height="auto" loading="auto"><div.new.line><figcaption id="">Dependency Injection</figcaption><figure.new.line><h3 id="">Benefits of using DI<h3.new.line><ol id=""><li id="">Supports unit testing<li.new.line><li id="">Boilerplate code is reduced, as the initializing of dependencies is done by another component (locator in our case)<li.new.line><li id="">Enables loose coupling<li.new.line></ol><h3 id="">Drawbacks of using DI<h3.new.line><ol id=""><li id="">It’s complex to learn, and if overused, can lead to management issues and other problems<li.new.line><li id="">Many compile time errors are pushed to runtime<li.new.line></ol><p id="">Coming back to our application, let’s see how we integrate it:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb11691d6ba21a83895c0_raycast-untitled%20(73).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code that integrates DI."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=954243a2ae" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Here, we create a constructor inside our HomeViewModel and specify the homeRepo as our required parameter. This way, we direct whomever needs access to our ViewModel first through the homeRepo.<p.new.line><h3 id="">Initialize the service locator<h3.new.line><p id="">You need to register the services on app startup, so you can do that in <em id="">main.dart.</em><p.new.line><p id="">Replace the standard:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb1365376ebf6da90b627_raycast-untitled%20(74).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=71a54b9f05" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">With the following:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb15ecf737f8331384a76_raycast-untitled%20(75).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=17054bb0ae" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">This will register any services you have with GetIt before the widget tree is built.<p.new.line><p id="">If we recall, our homeRepo was registered inside the locator, so in order to declare our ViewModel, we follow this:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1346px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1346px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb18255a6094317ad0c99_raycast-untitled%20(76).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=31d14b9ab7" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Inside our <em id="">main</em>, we call the <em id="">setupLocator</em>, which is the method that comprises all the registered dependencies under <em id="">locator.dart</em>.<p.new.line><p id="">Next, inside our <a href="https://pub.dev/documentation/provider/latest/provider/MultiProvider-class.html" target="_blank" id="">MultiProvider</a>, we specify the HomeViewModel under the <a href="https://pub.dev/documentation/provider/latest/provider/ChangeNotifierProvider-class.html" target="_blank" id="">ChangeNotifierProvider</a>.<p.new.line><p id=""><em id="">ChangeNotifierProvider creates a ChangeNotifier using create and automatically disposes it when it is removed from the widget tree.</em><p.new.line><h3 id="">Using ViewModel inside the View<h3.new.line><p id="">We have our repository registered and passed as a required parameter to our ViewModel. Let’s see how to use the ViewModel inside our View.<p.new.line><p id="">There are two ways to access the ViewModel inside the View:<p.new.line><ol id=""><li id="">Using the <em id="">Consumer&lt;T&gt;</em> widget<li.new.line><li id="">Using <em id="">Provider.of&lt;T&gt;(context)</em><li.new.line></ol><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1090px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1090px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb1edee89631f92187df7_raycast-untitled%20(77).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=9bb34aaed0" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">We instantiate the <em id="">viewModel</em> using <strong id="">Provider.of</strong> inside the <em id="">home_view</em>.<p.new.line><p id=""><em id="">Provider.of&lt;T&gt;(context)</em> is used when you need to access the dependency, but you don’t want to make any changes to the UI. We simply set <em id="">listen: false</em>, signifying that we don’t need to listen to updates from the ChangeNotifier. The<em id=""> listen: false</em> parameter is used to specify when you're using Provider to fetch an instance and call a method on that instance.<p.new.line><p id=""><em id="">Note: We can also use the below:</em><p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb24bcf737f7907385418_raycast-untitled%20(78).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippet."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=103e41a5cd" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">For reacting to the changes that happen to the viewModel, we use Consumer&lt;T&gt; when we want to rebuild the widgets when a value changes. It is a must to provide the type &lt;T&gt; so that the Provider can understand which dependency you are referring to.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb271826f8ab11d92f8be_raycast-untitled%20(79).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippet."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=691240bae8" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">The <a href="https://pub.dev/documentation/provider/latest/provider/Consumer-class.html" target="_blank" id="">Consumer</a> widget doesn’t do any fancy work. It just calls <a href="https://pub.dev/documentation/provider/latest/provider/Provider/of.html" target="_blank" id="">Provider.of</a> in a new widget and delegates its build implementation to the <a href="https://pub.dev/documentation/provider/latest/provider/Consumer/builder.html" target="_blank" id="">builder</a>.<p.new.line><p id="">The Consumer widget takes two parameters, the <em id="">builder</em> parameter and the <em id="">child</em> parameter (optional). The child parameter widget is not affected by any change in the ChangeNotifier.<p.new.line><p id="">This builder can be called multiple times (such as when the provided value changes), and that is where we can rebuild our UI. The Consumer widget has two main purposes:<p.new.line><ul id=""><li id="">It allows us to obtain a value from a provider when we don’t have a <a href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html" target="_blank" id="">BuildContext</a> that is a descendant of said provider and therefore cannot use <a href="https://pub.dev/documentation/provider/latest/provider/Provider/of.html" target="_blank" id="">Provider.of</a>.<li.new.line><li id="">It helps with performance optimization by providing more granular rebuilds.<li.new.line><ul.new.line><h3 id="">Unit tests for the ViewModel (Optional)<h3.new.line><p id="">You can mock dependencies by creating an alternative implementation of a class by making use of the <a href="https://pub.dev/packages/mockito" target="_blank" id="">Mockito package</a> as a shortcut.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ead8e3bc5946e3e6ab1aa2_0*raBWlTIpC0H5EKFM.png" alt="A flowchart of the Flutter MVVM architecture." id="" width="auto" height="auto" loading="auto"><div.new.line><figure.new.line><h2 id="">What are Services?<h2.new.line><p id="">Services are normal Dart classes that are written to do some specialized task in your app. The purpose of a service is to isolate a task, especially volatile third-party packages, and hide its implementation details from the rest of the app.<p.new.line><p id="">Some common examples you might create a service to handle:<p.new.line><ul id=""><li id="">Using a third-party package, for instance, read and write to local storage (shared preferences)<li.new.line><li id="">Using Cloud Providers like Firebase or some other third-party package<li.new.line><ul.new.line><p id="">Let’s say you’re using <a href="https://pub.dev/packages/package_info_plus" target="_blank" id="">package_info</a> to get the package details of your app.<p.new.line><p id="">You use the package directly inside the app, but after some time, you found an even better package. You go through and replace all the references to <em id="">package_info</em> with the new package <em id="">some_great_package</em>. This was surely <strong id="">a waste of your time and effort</strong>.<p.new.line><p id="">Let’s say the product owners found that no user was using this feature. Instead, they requested a new feature. You go through and remove all the references to some_great_package. This was, again, <strong id="">a waste of your time and effort</strong>.<p.new.line><p id="">The point is, when you have tight coupling to some function scattered around your code, it makes it error-prone and difficult to change.<p.new.line><p id=""><strong id="">Clean coding takes time and effort up front, but will save you more time and effort in the long run</strong>.<p.new.line><p id="">This is where services come in. You make a new class and call it something like PackageInfoService. The rest of the classes in the app don’t know how it works internally, they just call methods on the service to get the result.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb2ff93dc204ff591f2d7_raycast-untitled%20(80).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippet."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=e5444f8103" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><ul id=""><li id="">This makes it easy to change. If you want to switch <em id="">package_info</em> to <em id="">some_great_package</em>, just alter the code inside the service class. Updating the service code automatically affects everywhere the service is used inside the app.<li.new.line><li id="">This supports swapping around implementations. You can create a “fake” implementation that just returns hard-coded data while another team is finalizing/developing the service implementation.<li.new.line><li id="">Sometimes, the implementation may rely on other services. For example, your <em id="">xyzService</em> might use a service for making a network call to get other types of data.<li.new.line><ul.new.line><h3 id="">Registering your Service<h3.new.line><p id="">Using a service locator like GetIt is a convenient way to provide services throughout your app.<p.new.line><ul id=""><li id="">We use the <em id="">locator</em> to register our <em id="">PackageInfoService</em><li.new.line><li id="">We will be registering <em id="">PackageInfoService</em> as a lazy singleton. It only gets initialized when it’s first used. If you want it to be initialized on app startup, then use<em id=""> registerSingleton()</em> instead. Since it’s a singleton, you’ll always have the same instance of your service.<li.new.line><ul.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1146px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1146px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb35d0e07f17ec0d1ea7d_raycast-untitled%20(81).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippet."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=950f499442" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><h3 id="">Using the Service<h3.new.line><p id="">Since we registered the service using the GetIt, we can get a reference to the service from anywhere in the code.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb394ef7fa5463d974640_raycast-untitled%20(82).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippet."><div.new.line><figcaption id=""><a href="https://raman.pieces.cloud/?p=852d42a141" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Then you can use it within that class like this:<p.new.line><ul id=""><li id=""><em id="">packageService.getSomeValue()</em><li.new.line><li id=""><em id="">packageService.doSomething(someValue)</em><li.new.line><ul.new.line><h4 id="">Unit tests for the service (Optional)<h4.new.line><p id="">You can mock dependencies by creating an alternative implementation of the service class by making use of the <a href="https://pub.dev/packages/mockito" target="_blank" id="">Mockito package</a>.<p.new.line><h2 id="">Use Pieces to Store Your Flutter Snippets<h2.new.line><p id="">When <a href="https://code.pieces.app/blog/building-a-flutter-web-app-from-scratch-a-complete-guide" target="_blank">developing Flutter web applications</a>, you may have tons of widgets you save that you want to reuse later, but you just don't have them in a safe place where you can access them. There also may be the scenario where you are combing through <a href="https://code.pieces.app/blog/using-pieces-flutter-to-build-pieces">Flutter and Dart</a> documentation, and you want to save examples that come in handy when implementing a new feature or figuring out which widget to use for different circumstances.<p.new.line><p id=""><strong id="">Pieces</strong> helps you save
id=""><strong id="">Model-View-ViewModel (MVVM)</strong> Architecture is a unique combination of software architecture patterns that supports the separation of the UI (which is <strong id="">View</strong>) from the development of the business logic or the backend logic (<strong id="">Model</strong>). The view model inside MVVM is the bridge responsible for the conversion of data in a way that behaves in accordance with the changes happening in the UI.
id="">In addition, to know about the responsibilities of the three components, it’s also important to understand how the components interact with each other. At the highest level, <em id="">the view “knows about” the view model</em>, and <em id="">the view model “knows about” the model</em>, but <em id="">the model is unaware of the view model</em>, and the <em id="">view model is unaware of the view</em>.
![](8f555387049efb3/62ead8e36a005d153f96fea4_0*Plj_xKz_2EwTrXQz.png" alt="A diagram showing the Flutter MVVM architecture." id="" width="auto" height="auto" loading="au)
## Advantages and Disadvantages of MVVM
id="">There are several advantages of MVVM Architecture:
- id="">Improved testability
- id="">Defined project structure
- id="">Parallel development of UI
- id="">Abstracting the view, thus reducing the quantity of business logic required in the code behind it
id="">Some disadvantages of MVVM:
- id="">It adds a lot of extra classes, so it’s not ideal for low-complexity projects.
id="">Since architectural or MVVM design patterns are platform-agnostic, they can be used with any framework MVVM framework; in our case, <strong id="">Flutter</strong>. If you prefer visual learning, follow along with a <a href="https://www.youtube.com/watch?v=7Q9dxzIo314" target="_blank" id="">video version of this tutorial.</a>
## MVVM Components
id=""><strong id="">Model:</strong> This is basically the domain model, or the model which represents the data from your backend (i.e., the data access layer). Models hold information but typically don’t handle behavior. They don’t format information or influence how data appears. The Model in the MVVM pattern in Flutter represents the actual data that will be used in application development.
id=""><strong id="">View:</strong> This is basically the only part of the application users actually interact with. For instance, the user presses the button, scrolls the list, edits the settings, etc. These events are then forwarded to the view model, which does the processing and returns the expected user response (which is some form of UI). It’s important to remember the <strong id="">View</strong> isn’t responsible here for handling the state.
id="">A View should be as dumb as possible. Never put your business logic in a View.
id=""><strong id="">ViewModel:</strong> The ViewModel acts as an intermediary between the <strong id="">View</strong> and the <strong id="">Model</strong>, in such a way that it provides data to the UI. The ViewModel may also expose methods for helping to maintain the View’s state, update the model based on the actions on a View, and trigger events on the View. In <strong id="">Flutter,</strong> we have a listener called <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" target="_blank" id="">ChangeNotifier</a> that allows the ViewModel to inform or update the View whenever the data is updated.
id="">The ViewModel has basically two responsibilities:
- id="">It offers output data that the View can subscribe to
id="">In summary, the ViewModel sits behind the UI layer which is a <a href="https://code.pieces.app/blog/user-interface-neumorphism-glassmorphism">key user interface principle</a>. It exposes data needed by a View and can be viewed as the source our Views go to for both data and actions.
### What is Flutter ChangeNotifier?
id=""><a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" target="_blank" id="">ChangeNotifier</a> is a class that provides change notifications to its listeners.
id="">As per the official <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" target="_blank" id="">documentation</a>, a ChangeNotifier is:
id="">A class that can be extended or mixed in that provides a change notification API using VoidCallback for notifications.
id=""><em id="">It is O(1) for adding listeners and O(N) for removing listeners and dispatching notifications (where N is the number of listeners).</em>
id="">There are two ways to consume the ChangeNotifier in Flutter:
- id="">Using a combination of <em id="">ChangeNotifierProvider,</em> <em id="">Consumer</em>, and <em id="">Provider.</em> These capabilities are provided to us by the <a href="https://pub.dev/packages/provider" target="_blank" id="">Provider</a> package.
id="">In the real world, other classes can <em id="">listen</em> to a <em id="">ChangeNotifier</em> object. When the change notifier gets updated values, it can call a method called <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" target="_blank" id="">notifyListeners</a>, and then any of its listeners will receive the updated values.
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebad29e9ab9b75212857f3_raycast-untitled%20(67).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart cod)
id="">Inside the app, any class that listens to this Person will be notified in case the age changes. Internally, notifyListeners calls the registered listeners.
## Flutter MVVM Example
id="">Flutter is declarative in nature. This means that Flutter builds UI by overriding your build methods to reflect the current state of your app:
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebad5c93dc2043f191b375_raycast-untitled%20(68).png" loading="lazy" id="" width="auto" height="auto" alt="Code snippet with Dart cod)
id="">According to the <a href="https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app" target="_blank" id="">Flutter documentation</a>, the state is described as “the data you need to rebuild your UI at any point in time.”
id="">A state can be contained in a single widget, known as a local state. Flutter provides inbuilt classes and methods to deal with self-contained states like <em id="">StatefulWidget </em>and <em id="">setState</em>.
id="">However, a state that has to be shared across different widgets is known as an app state. It is at this point that we introduce state management tools.
id=""><em id="">We will be using </em><a href="https://pub.dev/packages/provider" target="_blank" id=""><em id="">Provider</em></a><em id=""> for state management.</em>
id="">Let’s say you were architecting an application that includes only the screen below. How would you do it?
id=""><em id="">Hint: Using Flutter MVVM</em>
![](8f555387049efb3/62ead8e3e5898db7a261006c_1*KG0NtOrb3RIKXR4HJ2Amfw.png" alt="an example screen for a flutter architecture MVVM example." id="" width="auto" height="auto" loading="au)
id="">Sample Screen
### <strong id="">Naming convention for View</strong>: 
id="">Each screen is called “view” and the file is suffixed with <em id="">_view</em>. The view will be listening to the changes happening on the ViewModel Flutter, using the <a href="https://pub.dev/documentation/provider/latest/provider/Consumer-class.html" target="_blank" id=""><em id="">Consumer</em></a>.
### <strong id="">Naming convention for ViewModel</strong>:
id=""> Each screen has a ViewModel associated with it and the file is suffixed with <em id="">_view_model</em>. The ViewModel notifies the changes to the UI (if any) using <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" target="_blank" id="">notifyListeners</a>.
![](8f555387049efb3/62ead8e3629c9081ff5d75c8_1*7kmY0bEok_LIUyU9Iv8akA.png" alt="MVVM Project structure example imagine." id="" width="auto" height="auto" loading="au)
id="">These are the basics of MVVM architecture, as we can see in the screenshot above. This can be replicated for all of your app's screens. You can read more about <a href="https://code.pieces.app/blog/file-handling-web-development" target="_blank">The Best File Formats for Web Development</a> for a better understanding. Now, let’s see a slight addition on top of this structure.
### Extending the MVVM toolkit with Repository and Services
id="">In the real world, our app needs to interact with APIs or third-party integrations. So, we introduce something called a Repository.
id="">A repository pattern provides an abstraction of data so that your application can work with a simple abstraction that has an interface. Using this pattern can help to achieve loose coupling. If implemented correctly, the Repository pattern can be a great way to ensure you follow the <em id="">Single Responsibility Principle</em> for your data access code.
id="">Some benefits of using the Repository pattern:
- id="">It makes mocking easier and allows to do unit tests
- id="">It easily switches data sources without doing time-consuming code changes
id="">Dart has no interfaces, like Java, but we can create one with an abstract class. We begin by creating an abstract class that defines the interface for our home_repo.
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebae923c40995a14e4ae33_raycast-untitled%20(69).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart cod)
id="">This abstract class helps to create a boundary, and we are free to work on either side of that boundary. We could work on implementing the home repository (<em id="">recommended</em>), or we could just use the implementation directly in our app (<em id="">not recommended</em>).
id="">Here, the <em id="">HomeRepository</em> has only one method, <em id="">fetchData</em>. This method returns the response as a model called <em id="">CarouselModel</em>.
id="">Next, let’s implement the <em id="">HomeRepository</em>:
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebaf4ab4e31a3ef38ece9a_raycast-untitled%20(70).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart cod)
id="">Inside the method <em id="">fetchData</em>, we introduce a delay and then load the data from the assets, which is a JSON file. This delay is basically a substitute for calling the API, <em id="">but I hope I am able to convey my thoughts to the reader.</em>
id="">As your application grows, you may find yourself adding more and more methods to a given repository. In this scenario, consider creating multiple repositories and keeping related methods together.
![](8f555387049efb3/62ead8e311ea59bb35c97110_1*q1BNWS5-00kEkAVE3ob9qw.png" alt="An example of MVVM folder structure Flutter." id="" width="auto" height="auto" loading="au)
id="">Now, we have
- id=""><em id="">home_view</em> representing the <strong id="">View (V)</strong>
- id=""><em id="">home_view_model </em>representing the <strong id="">View Model (VM)</strong>
- id=""><em id="">home_repo</em> representing the <strong id="">Repository</strong>
### Register the Repository
id="">Since our repository is ready, now we need to figure out how to register it and make it available inside our app. This is when we introduce another concept called Dependency Injection (DI). We make use of the package <a href="https://pub.dev/packages/get_it" target="_blank" id="">get_it</a>. As per the documentation:
id="">This is a simple Service Locator for Dart and Flutter projects with some additional goodies highly inspired by <em id="">Splat</em>. It can be used instead of <em id="">InheritedWidget</em> or <em id="">Provider </em>to access objects, e.g., from your UI.
id=""><strong id="">GetIt is super fast</strong> because it uses just a <em id="">Map&lt;Type&gt;</em>, which makes access to it <strong id="">O(1).</strong> GetIt itself is a singleton, so you can access it from everywhere using its instance property (see below).
id="">We install <em id="">get_it</em> it by including it inside the <em id="">pubspec.yaml </em>as:
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb0137f7f913219aa4b8f_raycast-untitled%20(71).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart cod)
id="">Typically at the start of your app, you register the types that you want to later access from anywhere. After that, you can access instances of the registered types by calling the locator again.
id="">The nice thing is you can register an interface or abstract class together with a concrete implementation. When accessing the instance, you always ask for the interface/abstract class type. This makes it easy to switch the implementation by just switching the concrete type at registration time.
id="">We create a file called <em id="">locator.dart</em> inside which we will instantiate the object of <em id="">get_it</em>:
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb06cef7fa5045c9734e5_raycast-untitled%20(72).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code that helps to build MVVM Architectur)
id="">As Dart supports global variables, we assign the GetIt instance to a global variable to make access to it as easy as possible.
id="">Although GetIt is a singleton, we will assign its instance to a global variable<em id=""> locator </em>to minimize the code for accessing GetIt. Any call to <em id="">locator</em> in any package of a project will get the same instance of <em id="">GetIt</em>.
id="">Next, we use the <em id="">locator</em> and use the <em id="">registerFactory</em> to register our <em id="">HomeRepository</em>.
Note: if you like these Dart snippets, check out our collection of <a href="https://code.pieces.app/collections/dart" id="">Dart code samples</a>.
id="">Provider is a powerful alternative to GetIt. But there are some reasons why people use GetIt for Dependency injection:
- id="">Provider adds its own widget classes to the widget tree that are no GUI elements, but are needed to access the in Provider registered objects.
id="">You can implement unit testing for different elements of your Flutter applications, such as widgets, controllers, models, services, and repositories. It’s possible to unit test repository-based Flutter codebases with the following strategies:
- id="">You don’t need to implement mock classes by yourself — the <a href="https://pub.dev/packages/mockito" target="_blank">Mockito package</a> helps you to generate them quickly and <a href="https://pub.dev/packages/mockito" target="_blank" id="">automatically</a>.
## Integrate Repository in ViewModel
id="">Now comes the time to use the Dependency Injection (DI). But before that, let’s see what it is.
id="">When class A uses some functionality of class B, then it’s said that class A has a dependency of class B.
id="">Before we can use methods of other classes, we first need to create the object of that class (i.e., class A needs to create an instance of class B).
id=""><strong id="">Dependency injection is transferring the task of creating the object to someone else and directly using the dependency.</strong>
![](8f555387049efb3/62ead8e3e38b9823c21f225c_0*0r7__ZZKUzZLQbt_.png" alt="A comic strip that illustrates dependency injection." id="" width="auto" height="auto" loading="au)
### Benefits of using DI
- id="">Boilerplate code is reduced, as the initializing of dependencies is done by another component (locator in our case)
- id="">Enables loose coupling
- id="">Many compile time errors are pushed to runtime
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb11691d6ba21a83895c0_raycast-untitled%20(73).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart code that integrates D)
id="">Here, we create a constructor inside our HomeViewModel and specify the homeRepo as our required parameter. This way, we direct whomever needs access to our ViewModel first through the homeRepo.
### Initialize the service locator
id="">You need to register the services on app startup, so you can do that in <em id="">main.dart.</em>
id="">Replace the standard:
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb1365376ebf6da90b627_raycast-untitled%20(74).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart cod)
id="">With the following:
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb15ecf737f8331384a76_raycast-untitled%20(75).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart cod)
id="">This will register any services you have with GetIt before the widget tree is built.
id="">If we recall, our homeRepo was registered inside the locator, so in order to declare our ViewModel, we follow this:
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb18255a6094317ad0c99_raycast-untitled%20(76).png" loading="lazy" id="" width="auto" height="auto" alt="A code snippet with Dart cod)
id="">Inside our <em id="">main</em>, we call the <em id="">setupLocator</em>, which is the method that comprises all the registered dependencies under <em id="">locator.dart</em>.
id="">Next, inside our <a href="https://pub.dev/documentation/provider/latest/provider/MultiProvider-class.html" target="_blank" id="">MultiProvider</a>, we specify the HomeViewModel under the <a href="https://pub.dev/documentation/provider/latest/provider/ChangeNotifierProvider-class.html" target="_blank" id="">ChangeNotifierProvider</a>.
id=""><em id="">ChangeNotifierProvider creates a ChangeNotifier using create and automatically disposes it when it is removed from the widget tree.</em>
### Using ViewModel inside the View
id="">We have our repository registered and passed as a required parameter to our ViewModel. Let’s see how to use the ViewModel inside our View.
id="">There are two ways to access the ViewModel inside the View:
- id="">Using <em id="">Provider.of&lt;T&gt;(context)</em>
id="">We instantiate the <em id="">viewModel</em> using <strong id="">Provider.of</strong> inside the <em id="">home_view</em>.
id=""><em id="">Provider.of&lt;T&gt;(context)</em> is used when you need to access the dependency, but you don’t want to make any changes to the UI. We simply set <em id="">listen: false</em>, signifying that we don’t need to listen to updates from the ChangeNotifier. The<em id=""> listen: false</em> parameter is used to specify when you're using Provider to fetch an instance and call a method on that instance.
id=""><em id="">Note: We can also use the below:</em>
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb24bcf737f7907385418_raycast-untitled%20(78).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippe)
id="">For reacting to the changes that happen to the viewModel, we use Consumer&lt;T&gt; when we want to rebuild the widgets when a value changes. It is a must to provide the type &lt;T&gt; so that the Provider can understand which dependency you are referring to.
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb271826f8ab11d92f8be_raycast-untitled%20(79).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippe)
id="">The <a href="https://pub.dev/documentation/provider/latest/provider/Consumer-class.html" target="_blank" id="">Consumer</a> widget doesn’t do any fancy work. It just calls <a href="https://pub.dev/documentation/provider/latest/provider/Provider/of.html" target="_blank" id="">Provider.of</a> in a new widget and delegates its build implementation to the <a href="https://pub.dev/documentation/provider/latest/provider/Consumer/builder.html" target="_blank" id="">builder</a>.
id="">The Consumer widget takes two parameters, the <em id="">builder</em> parameter and the <em id="">child</em> parameter (optional). The child parameter widget is not affected by any change in the ChangeNotifier.
id="">This builder can be called multiple times (such as when the provided value changes), and that is where we can rebuild our UI. The Consumer widget has two main purposes:
- id="">It helps with performance optimization by providing more granular rebuilds.
### Unit tests for the ViewModel (Optional)
id="">You can mock dependencies by creating an alternative implementation of a class by making use of the <a href="https://pub.dev/packages/mockito" target="_blank" id="">Mockito package</a> as a shortcut.
![](8f555387049efb3/62ead8e3bc5946e3e6ab1aa2_0*raBWlTIpC0H5EKFM.png" alt="A flowchart of the Flutter MVVM architecture." id="" width="auto" height="auto" loading="au)
## What are Services?
id="">Services are normal Dart classes that are written to do some specialized task in your app. The purpose of a service is to isolate a task, especially volatile third-party packages, and hide its implementation details from the rest of the app.
id="">Some common examples you might create a service to handle:
- id="">Using Cloud Providers like Firebase or some other third-party package
id="">Let’s say you’re using <a href="https://pub.dev/packages/package_info_plus" target="_blank" id="">package_info</a> to get the package details of your app.
id="">You use the package directly inside the app, but after some time, you found an even better package. You go through and replace all the references to <em id="">package_info</em> with the new package <em id="">some_great_package</em>. This was surely <strong id="">a waste of your time and effort</strong>.
id="">Let’s say the product owners found that no user was using this feature. Instead, they requested a new feature. You go through and remove all the references to some_great_package. This was, again, <strong id="">a waste of your time and effort</strong>.
id="">The point is, when you have tight coupling to some function scattered around your code, it makes it error-prone and difficult to change.
id=""><strong id="">Clean coding takes time and effort up front, but will save you more time and effort in the long run</strong>.
id="">This is where services come in. You make a new class and call it something like PackageInfoService. The rest of the classes in the app don’t know how it works internally, they just call methods on the service to get the result.
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb2ff93dc204ff591f2d7_raycast-untitled%20(80).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippe)
- id="">This supports swapping around implementations. You can create a “fake” implementation that just returns hard-coded data while another team is finalizing/developing the service implementation.
- id="">Sometimes, the implementation may rely on other services. For example, your <em id="">xyzService</em> might use a service for making a network call to get other types of data.
### Registering your Service
id="">Using a service locator like GetIt is a convenient way to provide services throughout your app.
- id="">We will be registering <em id="">PackageInfoService</em> as a lazy singleton. It only gets initialized when it’s first used. If you want it to be initialized on app startup, then use<em id=""> registerSingleton()</em> instead. Since it’s a singleton, you’ll always have the same instance of your service.
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb35d0e07f17ec0d1ea7d_raycast-untitled%20(81).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippe)
### Using the Service
id="">Since we registered the service using the GetIt, we can get a reference to the service from anywhere in the code.
![]( id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ebb394ef7fa5463d974640_raycast-untitled%20(82).png" loading="lazy" id="" width="auto" height="auto" alt="A Dart code snippe)
id="">Then you can use it within that class like this:
- id=""><em id="">packageService.doSomething(someValue)</em>
id="">You can mock dependencies by creating an alternative implementation of the service class by making use of the <a href="https://pub.dev/packages/mockito" target="_blank" id="">Mockito package</a>.
## Use Pieces to Store Your Flutter Snippets
id="">When <a href="https://code.pieces.app/blog/building-a-flutter-web-app-from-scratch-a-complete-guide" target="_blank">developing Flutter web applications</a>, you may have tons of widgets you save that you want to reuse later, but you just don't have them in a safe place where you can access them. There also may be the scenario where you are combing through <a href="https://code.pieces.app/blog/using-pieces-flutter-to-build-pieces">Flutter and Dart</a> documentation, and you want to save examples that come in handy when implementing a new feature or figuring out which widget to use for different circumstances.
