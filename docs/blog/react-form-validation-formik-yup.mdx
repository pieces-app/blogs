![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd6036a41bb07b4e1fd58a_yupandformik_27cf38bdb8b864349330198e161879c0_2000.jpeg)
"react-7; validation"
# Integrating Formik & Yup for React Form Validation
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)

In software development, forms offer a way of receiving data from users before sending information to the server. The data obtained through these forms must be validated and checked for mistakes that might break the server or cause problems. For example, you might need to verify that a username contains the required characters, or that the ```password``` field value and ```confirm-password``` field value match. In this article, we’ll examine how form validation in React Applications using two React form libraries: the Formik and Yup packages. To easily follow this article, fundamental knowledge of React is required. The code for the sample project we’ll be working with in this <a href="https://github.com/MelvinManni/react-formik" target="_blank" rel="noopener noreferrer">GitHub repository</a>.

## What Are Formik and Yup?
<a href="https://formik.org/docs/overview" target="_blank" rel="noopener noreferrer">Formik</a> is a React/React Native package used for handling forms; it keeps track of form values, errors, and events, and handles form submissions. Formik eliminates the work involved in setting up a state for form fields, allowing you to focus more on other aspects of development.
<a href="https://www.npmjs.com/package/yup" target="_blank" rel="noopener noreferrer">Yup</a> is a JavaScript schema builder for validating or parsing values. It allows you to model complex or inter-dependent validations using built-in validators or custom validations using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener noreferrer">regular expressions</a>.

### Yup Schema
The Yup schema allows you to create validation schema/rules that values should follow. You can create a Yup validation schema by calling ```Yup.object().shape()```. You’ll pass the schema object as a parameter with the schema rules as the value for the field keys. The schema has different datatypes: <a href="https://github.com/jquense/yup#string" target="_blank" rel="noopener noreferrer">string</a>, <a href="https://github.com/jquense/yup#number" target="_blank" rel="noopener noreferrer">numbers</a>, <a href="https://github.com/jquense/yup#date" target="_blank" rel="noopener noreferrer">date</a>, <a href="https://github.com/jquense/yup#tuple" target="_blank" rel="noopener noreferrer">tuple</a>, <a href="https://github.com/jquense/yup#array" target="_blank" rel="noopener noreferrer">arrays</a>, <a href="https://github.com/jquense/yup#object" target="_blank" rel="noopener noreferrer">objects</a>, <a href="https://github.com/jquense/yup#boolean" target="_blank" rel="noopener noreferrer">booleans</a>, and <a href="https://github.com/jquense/yup#mixed" target="_blank" rel="noopener noreferrer">mixed</a>. The mixed method allows you to create a schema that matches all data types or the ones you configured. Next, you’ll learn about the different Yup validation in React methods you can apply to schema types.
Formik allows easy integration with Yup for validating form values and ensures that the submitted data is error-free and matches a predetermined schema. The following sections will cover how to use Formik and Yup to validate forms in a simple React Application.

## Create a React App
To <a href="https://code.pieces.app/blog/alternatives-to-create-react-app" target="_blank" rel="noopener noreferrer">create a React app</a>, you’ll need to have <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener noreferrer">Node.js</a> installed. In your terminal, run the following command:
```
npx create-react-app react-formik```<a href="https://melvin.pieces.cloud/?p=4c0941b4eb" target="_blank" rel="noopener noreferrer">Save this code</a>

Once you create the application, update the ```App.css```** **file with the following styles:
```
*{
  outline: none;
  transition: 0.3s ease all;
}
main{
  max-width: 1024px;
  margin: auto;
}
.App {
  background-color: #202020;
  padding: 40px;
  min-height: 100vh;
}
.App-logo {
  pointer-events: none;
  margin: 20px;
}
@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}
.App-header {
  margin-bottom: 45px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
  text-align: center;
}
.App-header img {
  width: 150px;
}
.App-link {
  color: #61dafb;
}
.styledInput {
  margin-bottom: 25px;
}
.styledInput &gt; input {
  background: #fefefe;
  border: 1px solid #8db2e2;
  box-sizing: border-box;
  border-radius: 4px;
  height: 50px;
  min-width: 100%;
  max-width: max-content;
  padding: 5px 15px;
  padding-top: 0.7rem;
  font-family: &quot;Gill Sans&quot;, &quot;Gill Sans MT&quot;, Calibri, &quot;Trebuchet MS&quot;, sans-serif;
  color: #242235;
  font-style: normal;
  font-size: 0.87rem;
  line-height: 15px;
}
.styledInput &gt; input:focus {
  box-shadow: 1px 2px 4px #8db2e2;
}
.styledInput &gt; input::placeholder {
  color: #929292;
  font-size: 14.4px;
  font-family: &quot;Courier New&quot;, Courier, monospace;
  font-style: normal;
  font-weight: 700;
  text-transform: capitalize;
}
.helperText {
  color: #dc3545;
  font-size: 12px;
  min-height: 15px;
  text-align: left;
}
button {
  color: #fff;
  background: #2f4858;
  border-radius: 4px;
  font-family: &quot;PT Sans&quot;, sans-serif;
  font-weight: 700;
  border: none;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  padding: 10px 15px;
  font-size: 18px;
  height: 50px;
  min-width: 100%;
  max-width: max-content;
}
button:hover {
  box-shadow: 0px 3.5px 5px #e1e5f1a0;
  transform: translateY(-0.7px);
}
button:focus:before {
  transition: all 0.4s ease-out;
  opacity: 0;
  width: 40px;
  height: 40px;
  margin-top: -20px;
  margin-left: -20px;
}
button:before {
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.6);
  content: &quot;&quot;;
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
}
@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}```<a href="https://melvin.pieces.cloud/?p=c07c49b6c3" target="_blank" rel="noopener noreferrer">Save this code</a>

## Using Formik and Yup Form Validation
The ```App.js```** **file has a simple sign-up form controlled by Formik. In order to validate Forms in React, inject the Yup form validation schema into the Formik object:
```
import logo from &quot;./logo.svg&quot;;
import { useFormik } from &quot;formik&quot;;
import * as Yup from &quot;yup&quot;;
import &quot;./App.css&quot;;
import StyledInput from &quot;./components/StyledInput&quot;;
import { useState } from &quot;react&quot;;
function App() {
  const [loading, setLoading] = useState(false);
  const validateSchema = Yup.object().shape({
    firstName: Yup.string().required(&quot;This field is required&quot;),
    lastName: Yup.string().notRequired(),
    email: Yup.string().email(&quot;Please enter a valid email&quot;).required(&quot;This field is required&quot;),
    password: Yup.string()
      .required(&quot;This field is required&quot;)
      .min(8, &quot;Pasword must be 8 or more characters&quot;)
      .matches(/(?=.*[a-z])(?=.*[A-Z])\\w+/, &quot;Password ahould contain at least one uppercase and lowercase character&quot;)
      .matches(/\\d/, &quot;Password should contain at least one number&quot;)
      .matches(/[&#x60;!@#$%^&amp;*()_+\\-=[\\]{};':&quot;\\\\|,.&lt;&gt;/?~]/, &quot;Password should contain at least one special character&quot;),
    confirmPassword: Yup.string().when(&quot;password&quot;, (password, field) =&gt; {
      if (password) {
        return field.required(&quot;The passwords do not match&quot;).oneOf([Yup.ref(&quot;password&quot;)], &quot;The passwords do not match&quot;);
      }
    }),
  });
  const formik = useFormik({
    initialValues: {
      firstName: &quot;&quot;,
      lastName: &quot;&quot;,
      email: &quot;&quot;,
      password: &quot;&quot;,
      confirmPassword: &quot;&quot;,
    },
    validationSchema: validateSchema,
    onSubmit: (values, { resetForm }) =&gt; {
      console.log(values);
      setLoading(true);
      setTimeout(() =&gt; {
        setLoading(false);
        resetForm();
      }, 1000 * 2);
    },
  });
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;header className=&quot;App-header&quot;&gt;
        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;
        &lt;h4&gt;Signup&lt;/h4&gt;
      &lt;/header&gt;
      &lt;main&gt;
        &lt;form className=&quot;spaceY-lg w100-small w50-lg&quot; onSubmit={formik.handleSubmit}&gt;
          &lt;StyledInput
            label=&quot;First Name&quot;
            name=&quot;firstName&quot;
            onChange={formik.handleChange}
            value={formik.values.firstName}
            type={&quot;text&quot;}
            helperText={formik.errors.firstName ? formik.errors.firstName : &quot;&quot;}
          /&gt;
          &lt;StyledInput
            label=&quot;Last Name&quot;
            type={&quot;text&quot;}
            name=&quot;lastName&quot;
            onChange={formik.handleChange}
            value={formik.values.lastName}
            helperText={formik.errors.lastName ? formik.errors.lastName : &quot;&quot;}
          /&gt;
          &lt;StyledInput
            label=&quot;Email Address&quot;
            type={&quot;email&quot;}
            name=&quot;email&quot;
            onChange={formik.handleChange}
            value={formik.values.email}
            helperText={formik.errors.email ? formik.errors.email : &quot;&quot;}
          /&gt;
          &lt;StyledInput
            label=&quot;Password&quot;
            type={&quot;password&quot;}
            name=&quot;password&quot;
            onChange={formik.handleChange}
            value={formik.values.password}
            helperText={formik.errors.password ? formik.errors.password : &quot;&quot;}
          /&gt;
          &lt;StyledInput
            label=&quot;Confirm Password&quot;
            type={&quot;password&quot;}
            name=&quot;confirmPassword&quot;
            onChange={formik.handleChange}
            value={formik.values.confirmPassword}
            helperText={formik.errors.confirmPassword ? formik.errors.confirmPassword : &quot;&quot;}
          /&gt;
          &lt;button disabled={loading} type={&quot;submit&quot;}&gt;
            {loading ? &quot;Loading...&quot; : &quot;Sign Up&quot;}
          &lt;/button&gt;
        &lt;/form&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}
export default App;```<a href="https://melvin.pieces.cloud/?p=a0c94fadf8" target="_blank" rel="noopener noreferrer">Save this code</a>

In the code block above, we can see the Yup and Formik validation schema for the sign-up form on line 10. This creates a set of rules that each form field will follow.
On line 27, we have the ```useFormik``` hook with the initial values for the form state, the validation schema created with Yup and the ```onSubmit``` event for the form. Next, we linked the Formik values to the input fields. Using the First Name form field as a reference, we connected the field value from Formik to the value attribute and for the input to create a <a href="https://reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener noreferrer">controlled component</a>. Finally, we passed the ```handleSubmit``` function from Formik to the ```onSubmit``` event for the form.

### Validation Messages
Validation messages are tips that help the user understand which characters are valid for a specific form field, making them incredibly useful in React form validation. In addition, they serve as a guide for the user in resolving form errors. Validation messages are accessible through Formik errors for each field. We can see this example on line 61. The First Name field validation message can be accessed from ```formik.errors.firstName```.

### Built-in Validators
Yup has some built-in validators that we can implement. As seen in the code block above, we used some built-in validators in the validation schema. As discussed in the previous section, there are different datatypes for a Yup Schema. For each data type, there are different validation methods that can be chained to it. An exception is a boolean datatype that can be either true or false.

### Custom Validations (RegEx)
We can create our custom validation rules by using the ```matches()```** ** method for string schema. This accepts a regular expression and the validation message as a value:
```
    password: Yup.string()
      .required(&quot;This field is required&quot;)
      .min(8, &quot;Pasword must be 8 or more characters&quot;)
      .matches(/(?=.*[a-z])(?=.*[A-Z])\\w+/, &quot;Password ahould contain at least one uppercase and lowercase character&quot;)
      .matches(/\\d/, &quot;Password should contain at least one number&quot;)
      .matches(/[&#x60;!@#$%^&amp;*()_+\\-=[\\]{};':&quot;\\\\|,.&lt;&gt;/?~]/, &quot;Password should contain at least one specia```<a href="https://melvin.pieces.cloud/?p=387d4d94a1" target="_blank" rel="noopener noreferrer">Save this code</a>

The schema rule above will check if a value is a string and verify that the string value is not empty. Next, it will check to make sure that the minimum length for the string characters is eight. Finally, the following three validation rules for the value are customized using a regular expression:
- The first expression checks if there is at least one uppercase letter and one lowercase letter in the string.
- The second expression checks if the value contains at least one number.
- The last expression checks if the value contains at least one special character.

This validation can be applied in real-life scenarios for creating a strong password, as seen in the code sample in the ```App.js```** **file:

![]("https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63b3030c83c6d5f6a08d4784_image3_2801fcfdf10873b9c7745fb26676c17a.g)

### Validating a Dynamic Form with Formik and Yup
The Formik validation package also comes with built-in components that let us control the form state and events. In this section we’ll examine how to create a dynamic form using Formik form components and Yup. First, we’ll set up a form that allows us to create a list of items:
```
import &quot;./styles.css&quot;;
import * as yup from &quot;yup&quot;;
import { Field, FieldArray, Form, Formik } from &quot;formik&quot;;
import React from &quot;react&quot;;
export default function App() {
  const [list, setList] = React.useState([]);
  const validationSchema = yup.object().shape({
    items: yup.array().of(yup.string().required(&quot;This value is required&quot;))
  });
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;Formik
        initialValues={{
          items: [&quot;&quot;]
        }}
        validationSchema={validationSchema}
        onSubmit={(values, { resetForm }) =&gt; {
          setList(values.items);
          setTimeout(() =&gt; {
            console.log(&quot;clean&quot;);
            resetForm();
          }, 3000);
        }}
      &gt;
        {({ values }) =&gt; (
          &lt;Form&gt;
            {values.items.map((_, index) =&gt; (
              &lt;React.Fragment key={index}&gt;
                &lt;FieldArray
                  name=&quot;items&quot;
                  render={(helpers) =&gt; (
                    &lt;div&gt;
                      &lt;Field name={&#x60;items.${index}&#x60;}&gt;
                        {({
                          field, // { name, value, onChange, onBlur }
                          form: { touched, errors }, // also values, setXXXX, handleXXXX, dirty, isValid, status, etc.
                          meta
                        }) =&gt; (
                          &lt;div&gt;
                            &lt;input
                              type=&quot;text&quot;
                              placeholder=&quot;Enter item...&quot;
                              {...field}
                            /&gt;
                            {meta.touched &amp;&amp; meta.error &amp;&amp; (
                              &lt;small className=&quot;error&quot;&gt;{meta.error}&lt;/small&gt;
                            )}
                          &lt;/div&gt;
                        )}
                      &lt;/Field&gt;
                      &lt;div className=&quot;row&quot;&gt;
                        &lt;button
                          disabled={values.items.length === 1}
                          onClick={() =&gt; {
                            values.items.length &gt; 1 &amp;&amp; helpers.remove(index);
                          }}
                          type=&quot;button&quot;
                          className=&quot;remove&quot;
                        &gt;
                          Remove
                        &lt;/button&gt;
                        {values.items.length === index + 1 &amp;&amp; (
                          &lt;button
                            type=&quot;button&quot;
                            onClick={() =&gt; {
                              helpers.push(&quot;&quot;);
                            }}
                            className=&quot;add&quot;
                          &gt;
                            Add New Item
                          &lt;/button&gt;
                        )}
                      &lt;/div&gt;
                    &lt;/div&gt;
                  )}
                /&gt;
              &lt;/React.Fragment&gt;
            ))}
            &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
      &lt;div className=&quot;list-wrapper&quot;&gt;
        &lt;ul&gt;
          {list.map((val) =&gt; (
            &lt;li&gt;{val}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}```<a href="https://melvin.pieces.cloud/?p=49dd4e86ae" target="_blank" rel="noopener noreferrer">Save this code</a>

In the code block above, we have the Yup schema, which is an array type of strings. As we can see from the Yup validation schema, the array values are required; we cannot have an empty string as an array value.
Next, we imported the ```Formik``` component from the Formik package; this wraps the form. Since we’re working with arrays/dynamic form values, we used the ```FieldArray``` component, which helps with array manipulations. On line 32, we have the ```FieldArray```, which is used to render each form field and button. The render props from the ```FieldArray``` had helper props passed to them. This prop allowed us to mutate the array values, as seen in the &quot;Add New Item&quot; button, where we used the ```push()``` method from the helpers to add new values at the end of the array. Also, the &quot;remove&quot; button calls the ```remove()```** **method on click, with the item's index to remove passed as a parameter:
![](ploads-ssl.webflow.com/6143afec68f555387049efb3/63b3030c83c6d599a08d4783_image1_4048e61d06aada1b9cb258fdbbe71f4d.g)

Finally, to test your dynamic form, you can use the code sample in this <a href="https://codesandbox.io/s/3h5o32" target="_blank" rel="noopener noreferrer">codesandbox</a>.

## Conclusion
Formik and Yup provide a great way to manage form state and validate values in a form before sending data to the server. They provide a lot of flexibility and ease when creating forms. You can also utilize the Formik form components or hooks to handle your forms in a React application.
