![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd789070a1f2c81544b4de_remultapp_d483cb7e53ae69ba7c9f25605c8ecb9e_2000.jpeg)
"react-7; remult"
# Remult, TypeScript, and React: The Perfect Combo for a Full-stack App
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Stylized image of two people discussing a project." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd789170a1f2660c44b559_remultapp_13222562b269d71ad6d88300891f3c16_800.jpeg"><div.new.line><figure.new.line><p>A full-stack application is made up of frameworks, libraries, and tools for developing two separate domain applications: the backend and the frontend. Building these two applications can be very hectic, especially if the frameworks are developed from different programming languages or if one developer is working on both sides of the application. However, we’re grateful to the JavaScript developers for creating backend frameworks that allow us to use JavaScript to build both the client and server sides of our application. The Remult developers expanded on this concept by developing a framework that allows us to build both the client and server sides of an application in a single project rather than having two separate projects. We’ll explore how this can be implemented in this tutorial. Then, we’ll learn how to build a full-stack application with TypeScript and React using Remult.<p.new.line><h2 id="8uu8d">What is Remult?<h2.new.line><p>Remult is a full-stack TypeScript CRUD framework with a frontend type-safe API client and a backend ORM that uses entities as a single source of truth for your API. It saves developers time by abstracting all repetitive or poorly designed code, resulting in a more flexible web application. It makes full-stack app development easier by using only TypeScript code that’s easy to follow and refactor, and it fits well into any existing or new project.<p.new.line><h3 id="bonlc">Why Use Remult?<h3.new.line><p>Below are some of the reasons developers use Remult:<p.new.line><ul><li>It has a secure auto-generated TypeScript API model and classes that are consumed by frontend type-safe queries that can also be used as third-party applications.<li.new.line><li>It’s a simple CRUD application that interacts with the database directly from the frontend and does not require any boilerplate, so data transformations, validations, and CRUD events are easily controlled.<li.new.line><li>It uses a type-safe coding style to find and manipulate data on both the backend and frontend code.<li.new.line><li>It eliminates redundant and error-prone duplication with model metadata and declarative code that impacts both the frontend and the backend.<li.new.line><ul.new.line><h2 id="dr3od">Prerequisites<h2.new.line><p>This is a hands-on tutorial, so to follow along, be sure that you’ve done these things:<p.new.line><ul><li>Installed <u><a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a></u> V14 or later<li.new.line><li><u><a href="https://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwi3vPfd1bP6AhVKA4sKHQbnBWsYABAAGgJlZg&amp;ohost=www.google.com&amp;cid=CAESbOD2X-a6kboxXHXG3izU05eObOfzWxIrNJfa2IeMsImyvcs6l3QguTUf9pPYUNi6jbMn8Rz6TU0SWme6fbL3uUvtL6HyEzJhKOuYte37s4tYRlvpOV4oP-eB8VpRxFGnQhm1rArwTetsZzURSg&amp;sig=AOD64_3r0aVg59iknPszkLuo3XbggSzTLA&amp;q&amp;adurl&amp;ved=2ahUKEwjg2O_d1bP6AhUfgf0HHTn-AqMQ0Qx6BAgIEAE" target="_blank" rel="noopener noreferrer">MongoDB</a></u> Installed your database<li.new.line><li>Prior knowledge of <u><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">TypeScript</a></u> and <u><a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">React</a></u><li.new.line><ul.new.line><h2 id="29feu">Project Setup<h2.new.line><p>Without further ado, let’s scaffold a Remult React full stack application using Vite by running the command below:<p.new.line><pre>npm create -y vite@latest remult-react-blog -- --template react-ts<br>cd remult-react-blog</pre><p>The above commands will scaffold a new React project with the following folder structure:<p.new.line><pre>📦remult-react-blog<br>┣ 📂public<br>┃ ┗ 📜vite.svg<br>┣ 📂src<br>┃ ┣ 📂assets<br>┃ ┃ ┗ 📜react.svg<br>┃ ┣ 📜App.css<br>┃ ┣ 📜App.tsx<br>┃ ┣ 📜index.css<br>┃ ┣ 📜main.tsx<br>┃ ┗ 📜vite-env.d.ts<br>┣ 📜.gitignore<br>┣ 📜index.html<br>┣ 📜package.json<br>┣ 📜tsconfig.json<br>┣ 📜tsconfig.node.json<br>┗ 📜vite.config.ts</pre><p>In order to get your React application running, change the directory into the project folder, install the required packages, and start the application by running the commands below:<p.new.line><pre>cd remult-react-blog<br><br>npm install</pre><p>Now, let’s set up the backend of the application.<p.new.line><h3 id="cosu0">Install Dependencies<h3.new.line><p>The first step in setting up the backend is to install the required dependencies. We’ll use <strong>Express </strong>for the backend, and since Remult creates both the backend and frontend in one project, we’ll need to have them running concurrently.  So run the commands to install <strong>Express </strong>and the <strong>Remult</strong> SDK, and use <code>ts-node</code> to run the application in development.<p.new.line><pre>npm i express remult<br>npm i --save-dev @types/express ts-node-dev concurrently</pre><p>Next, wait for the installation to be completed and proceed to creating the backend.<p.new.line><h3 id="erhk2">Create the Backend<h3.new.line><p>With the required packages for the backend setup installed, create a TypeScript config file and add the configurations below:<p.new.line><pre>{<br>  &quot;extends&quot;: &quot;./tsconfig.json&quot;,<br>  &quot;compilerOptions&quot;: {<br>    &quot;module&quot;: &quot;commonjs&quot;,<br>    &quot;emitDecoratorMetadata&quot;: true,<br>    &quot;esModuleInterop&quot;: true<br>  }<br>}</pre><p>Then, create a <strong>server </strong>folder in the <strong>src </strong>folder. Next, in the server folder, create an <strong>index.ts </strong>file and make an Express server with the code snippets below:<p.new.line><pre>import express from &#x27;express&#x27;;<br>const app = express();<br><br>app.listen(3002, () =&gt; console.log(&quot;Server started&quot;));</pre><p>Since the application is using the Common.js module, you need to remove the <code>&quot;type&quot;: &quot;module&quot;</code> entry from the <strong>package.json</strong> file created by Vite.<p.new.line><p>Next, create an <strong>api.ts</strong> file on the <strong>server </strong>and load Remult in the backend as an Express middleware with the code snippet below:<p.new.line><pre>import { remultExpress } from &#x27;remult/remult-express&#x27;;<br>export const api = remultExpress();</pre><p>Then, register the Remult <strong>API</strong> middleware in the <strong>server/index.ts</strong> file with this code snippet:<p.new.line><pre>Import {api} from “./api”;<br>app.use(api);</pre><p>Next, update the<strong> </strong><code>tsconfig.json</code> file to enable TypeScript decorators in the React.js full stack App with the entry below:<p.new.line><pre>&quot;experimentalDecorators&quot;: true</pre><p>A Remult application is configured to run the frontend and backend from the same domain in production. However, in development, the API server listens to <u><a href="http://localhost:3002/" target="_blank" rel="noopener noreferrer">http://localhost:3002</a></u>, while the frontend listens to port <u><a href="http://localhost:5173/" target="_blank" rel="noopener noreferrer">http://localhost:5173</a></u>. Therefore, you need to use the Vite proxy feature to divert all requests to the <strong>API</strong> to <u><a href="http://localhost:5173/api" target="_blank" rel="noopener noreferrer">http://localhost:5173/api</a></u>. To do this, update the <strong>vite.confg.ts</strong> file with the code snippet below:<p.new.line><pre>export default defineConfig({<br>  plugins: [react()],<br>  server: { proxy: { &#x27;/api&#x27;: &#x27;http://localhost:3002&#x27; } }<br>})</pre><p>Next, update the <strong>package.json</strong> file to add a start script to run the application in development with the entry below:<p.new.line><pre>&quot;dev&quot;: &quot;concurrently -k -n \\&quot;API,WEB\\&quot; -c \\&quot;bgBlue.bold,bgGreen.bold\\&quot; \\&quot;ts-node-dev -P tsconfig.server.json src/server/\\&quot; \\&quot;vite\\&quot;&quot;</pre><p>Now, run the application with this command:<p.new.line><pre>npm run dev</pre><h3 id="bplja">Connect to a Database<h3.new.line><p>With the backend created, let’s proceed to connecting the application to a MongoDB database to store our blog data. To get started, install the MongoDB package by running the command below:<p.new.line><pre>npm i mongdb</pre><p>Then, update the<strong> server/index.ts </strong>file and connect it to MongoDB with the following code snippet:<p.new.line><pre>import { remultExpress } from &#x27;remult/remult-express&#x27;;<br>import { MongoClient } from &#x27;mongodb&#x27;;<br>import { MongoDataProvider } from &#x27;remult/remult-mongo&#x27;;<br><br>app.use(remultExpress({<br>  dataProvider: async () =&gt; {<br>    const client = new MongoClient(&quot;mongodb://localhost:27017/local&quot;);<br>    await client.connect();<br>    return new MongoDataProvider(client.db(&#x27;blogs&#x27;), client);<br>  }<br>}));<br></pre><p>With the above code snippet, we imported the <code>remultExpress</code><strong> </strong>middleware, the <code>MongoClient</code> class and the <code>MongoDataProvider</code> class. The <code>remultExpress</code><strong> </strong>middleware<strong> </strong>takes a <code>dataProvider</code><strong> </strong>object as an argument, which allows us to connect to the database. We also created a client instance from the <code>MongoClient</code> client class passing in the database URI and established a connection using the calling-the-client-connect method.<p.new.line><h2 id="c3orp">Create a Blog Entity with Remult<h2.new.line><p>Now, with the connection to our database established, let&#x27;s create a Blog entity to define and create our blog model. To do this, we’ll create a <strong>shared </strong>folder in the server folder. We’re saving it in this file because Remult classes are shared between the frontend and backend. This means we can access in the frontend any class created in the backend.<p.new.line><p>In the <strong>shared</strong> folder, create a blog.ts file and add the code below:<p.new.line><pre>import { Entity, Fields } from &#x27;remult&#x27;;<br><br>@Entity(&#x27;blogs&#x27;, {<br>  allowApiCrud: true<br>})<br><br>export class Blogs {<br>  @Fields.uuid()<br>  id!: string;<br><br>  @Fields.string()<br>  title = &#x27;&#x27;;<br><br>  @Fields.string()<br>  coverImage = &#x27;&#x27;;<br><br>  @Fields.string()<br>  content = &#x27;&#x27;;<br>}</pre><p>In the above code snippets, we imported the Remult <code>Entity</code> and <code>Fields</code><strong> </strong>decorators. We used the <code>Entity</code><strong> </strong>decorator to create a blogs entity, which will be translated to a model in our MongoDB base with the fields we defined in the <code>Blogs</code> class using the <code>Fields</code> decorator. We also set<strong> </strong><code>allowApiCrud</code><strong> </strong>to <code>true</code> in the <code>@Entity</code> decorator to allow us to perform CRUD operations on this entity.<p.new.line><p>Next, update the <strong>server/index.ts</strong> file to register the entity in the <code>remultExpress</code> middleware with this code snippet:<p.new.line><pre>import { Blogs } from &#x27;./shared /blog&#x27;;<br><br>app.use(remultExpress({<br>  dataProvider: async () =&gt; {<br>    const client = new MongoClient(&quot;mongodb://localhost:27017/local&quot;);<br>    await client.connect();<br>    return new MongoDataProvider(client.db(&#x27;test&#x27;), client);<br>  },<br>  entities: [Blogs],<br>}));</pre><p>In the above code snippet, we imported the Blogs entity and registered it to the application in the array of <strong>entities</strong> object.<p.new.line><h2 id="51pfj">Create CRUD Operations<h2.new.line><p>Now let’s create our CRUD functions so that we Create, Read, Update and Delete a blog from our database.<p.new.line><p>First, you need to create a <code>blogController.ts</code> file in the <strong>server/shared </strong>folder. In the <code>blogController.ts</code><strong> </strong>file, add the following code:<p.new.line><pre>import { BackendMethod, remult } from &quot;remult&quot;;<br>import { Blogs } from &quot;./blog&quot;;<br><br>export class BlogsController {<br><br>  @BackendMethod({ allowed: true })<br>  static async create(title: string, coverImage: string, content: string) {<br>    const newBlog = await remult.repo(Blogs).save({ title, content, coverImage })<br>   return newBlog<br>  }<br>static async getAll() {<br>  return await this.blogRepo.find();<br>}<br>static async getOne(id: string) {<br>  return await this.blogRepo.findId(id)<br>}<br>static async updateOne(id: string, title: string, coverImage: string, content: string) {<br>  return await this.blogRepo.update(id, { title, coverImage, content })<br>}<br>static async deleteOne(id:string) {<br>  return await this.blogRepo.delete(id)<br>}</pre><p>In the above code snippets, we imported the Remult <code>BackendMethod</code> decorator and <code>Remult</code><strong> </strong>object. The <code>BackendMethod</code><strong> </strong>decorator tells Remult to expose the methods we defined in the <code>BlogsController</code> as API endpoints. Then, we used the <code>remult.repo</code><strong> </strong>method to create a repository for our Blogs entity. This provides us with the methods we need to perform database CRUD operations in each controller method.<p.new.line><p>Next, you also need to register the <code>BlogsController</code> like you did for the <code>Blogs</code><strong> </strong>entity in the <code>server/index.ts</code> file. This can done with the code snippet below:<p.new.line><pre>import { BlogsController } from &#x27;./shared/blogController&#x27;;<br><br>app.use(remultExpress({<br>  dataProvider: async () =&gt; {<br>    const client = new MongoClient(&quot;mongodb://localhost:27017/local&quot;);<br>    await client.connect();<br>    return new MongoDataProvider(client.db(&#x27;test&#x27;), client);<br>  },<br>entities: [Blogs],<br>controllers: [BlogsController]<br>}));<br></pre><h2 id="dsmol">Handle the React Frontend with Remult<h2.new.line><p>We’re done setting up the backend part of the application. Now, let’s move to our React frontend and consume the API’s we’ve created in our backend.<p.new.line><p>To get started, create a controllers folder in the <strong>src </strong>to create some React controllers for your application.<p.new.line><p>First, create a <strong>Form.ts</strong> file in the controllers folder, and add the code below:<p.new.line><pre>import { useState } from &quot;react&quot;;<br>import { BlogsController } from &quot;../server/shared /blogController&quot;;<br>export function Form() {<br>  const [title, setTitle] = useState(&quot;&quot;);<br>  const [coverImage, setCoverImage] = useState(&quot;&quot;);<br>  const [content, setContent] = useState(&quot;&quot;);<br>  <br>  const create = async () =&gt; {<br>    await BlogsController.create(title, coverImage, content);<br>};<br>return (<br>&lt;div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;label htmlFor=&quot;exampleFormControlInput1&quot; className=&quot;form-label&quot;&gt;<br>    Title<br>    &lt;/label&gt;<br>    &lt;input<br>      type=&quot;email&quot;<br>      className=&quot;form-control&quot;<br>      id=&quot;exampleFormControlInput1&quot;<br>      onChange={(e) =&gt; setTitle(e.target.value)}<br>    /&gt;<br>  &lt;/div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;label htmlFor=&quot;exampleFormControlInput1&quot; className=&quot;form-label&quot;&gt;<br>    Cover Image<br>    &lt;/label&gt;<br>    &lt;input<br>      type=&quot;email&quot;<br>      className=&quot;form-control&quot;<br>      id=&quot;exampleFormControlInput1&quot;<br>      onChange={(e) =&gt; setCoverImage(e.target.value)}<br>    /&gt;<br>  &lt;/div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;label htmlFor=&quot;exampleFormControlTextarea1&quot; className=&quot;form-label&quot;&gt;<br>    Content<br>    &lt;/label&gt;<br>    &lt;textarea<br>      className=&quot;form-control&quot;<br>      id=&quot;exampleFormControlTextarea1&quot;<br>      rows=&quot;3&quot;<br>      onChange={(e) =&gt; setContent(e.target.value)}<br>    &gt;&lt;/textarea&gt;<br>  &lt;/div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;button className=&quot;btn btn-primary&quot; onClick={()=&gt; create()}&gt;Add&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>);<br>}</pre><p>In the above code snippet, we imported the <code>BlogsController</code> class so we can access the API endpoints that we defined there. We also created a state variable to store the blog <code>title</code> and <code>coverImage</code> <code>content</code><strong> </strong>values from the form data. We made a<strong> </strong><code>create</code><strong> </strong>function and called the create endpoint from our <code>BlogsController</code> class, passing the variables we defined for the form values to create a new blog.<p.new.line><p>We need this form to display in a modal when clicked. Therefore, we need to create a Modal.tsx file in the controllers file to create a <code>Modal</code> component. This can be done by using the code snippet below:<p.new.line><pre>import { Form } from &quot;./Form&quot;;<br><br>export function Modal() {<br>return (<br>  &lt;div<br>    className=&quot;modal fade&quot;<br>    id=&quot;staticBackdrop&quot;<br>    data-bs-backdrop=&quot;static&quot;<br>    data-bs-keyboard=&quot;false&quot;<br>    tabIndex=&quot;-1&quot;<br>    aria-labelledby=&quot;staticBackdropLabel&quot;<br>    aria-hidden=&quot;true&quot;<br>  &gt;<br>  &lt;div className=&quot;modal-dialog&quot;&gt;<br>   &lt;div className=&quot;modal-content&quot;&gt;<br>    &lt;div className=&quot;modal-header&quot;&gt;<br>      &lt;h5 className=&quot;modal-title&quot; id=&quot;staticBackdropLabel&quot;&gt;<br>      Create New Blog<br>      &lt;/h5&gt;<br>    &lt;button<br>      type=&quot;button&quot;<br>      className=&quot;btn-close&quot;<br>      data-bs-dismiss=&quot;modal&quot;<br>      aria-label=&quot;Close&quot;<br>    &gt;&lt;/button&gt;<br>    &lt;/div&gt;<br>    &lt;div className=&quot;modal-body&quot;&gt;<br>    &lt;Form /&gt;<br>    &lt;/div&gt;<br>   &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>);<br>}</pre><p>In the above code, we used the <code>Bootstrap</code> classes to create a modal for the form component. Then, we imported the <code>Form</code> component and rendered it in the modal body.<p.new.line><p>Next, we’ll need to add a clickable button to show the modal component we just created. To add a button in the header part of the application, create a Header.ts file in the controllers folder and add the code below:<p.new.line><pre>import { Modal } from &quot;./Modal&quot;;<br><br>export function Header() {<br>return (<br>  &lt;nav className=&quot;navbar navbar-light bg-light&quot;&gt;<br>    &lt;div className=&quot;container-fluid&quot;&gt;<br>    &lt;a className=&quot;navbar-brand&quot;&gt;Blog App&lt;/a&gt;<br>    &lt;button<br>      className=&quot;btn btn-primary&quot;<br>      data-bs-toggle=&quot;modal&quot;<br>      data-bs-target=&quot;#staticBackdrop&quot;<br>    &gt;<br>    Add New<br>    &lt;/button&gt;<br>   &lt;/div&gt;<br>  &lt;Modal/&gt;<br>&lt;/nav&gt;<br>);<br>}</pre><p>Now, let’s update the code in the<strong> </strong><code>App.tsx</code> file to make the <code>Header</code> component available, read the blog data from our Remult backend, and render it to users with the following:<p.new.line><pre>import { useEffect, useState } from &quot;react&quot;;<br>import { Header } from &quot;./components/Header&quot;;<br>import { BlogsController } from &quot;./server/shared /blogController&quot;;<br>import { Blogs } from &quot;./server/shared /blog&quot;;<br><br>function App() {<br>  const [blogs, setBlogs] = useState&lt;Blogs[]&gt;([]);<br>  useEffect(() =&gt; {<br>    const fetchData = async () =&gt; {<br>    const blogData = await BlogsController.getAll();<br>    setBlogs(blogData);<br>  };<br>  fetchData();<br>});<br>const deleteBlog = async (id:string)=&gt;{<br>  await BlogsController.deleteOne(id)<br>}<br>return (<br>&lt;div className=&quot;App&quot;&gt;<br>  &lt;Header /&gt;<br>    &lt;div className=&quot;container&quot;&gt;<br>    &lt;div className=&quot;row&quot;&gt;<br>      {blogs &amp;&amp;<br>        blogs.map((blog: Blogs) =&gt; {<br>      return (<br>        &lt;div className=&quot;card&quot; style={{ width: &quot;18rem&quot;, margin:&quot;20px&quot; }} key={blog.id}&gt;<br>          &lt;img<br>            src={blog.coverImage}<br>            className=&quot;card-img-top&quot;<br>            alt=&quot;...&quot;<br>          /&gt;<br>        &lt;div className=&quot;card-body&quot;&gt;<br>          &lt;h5 className=&quot;card-title&quot;&gt;{blog.title}&lt;/h5&gt;<br>            &lt;p className=&quot;card-text&quot;&gt;<br>            {blog.content}<br>            &lt;/p&gt;<br>            &lt;a href=&quot;#&quot; className=&quot;btn btn-sm btn-danger&quot; onClick={()=&gt;{<br>               deleteBlog(blog.id)<br>            }}&gt;<br>            Delete<br>            &lt;/a&gt;<br>        &lt;/div&gt;<br>       &lt;/div&gt;<br>     );<br>    })}<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>);<br>}<br>export default App;</pre><p>Also, with the above code snippet, we created a delete function to delete blogs from our database by calling the <code>deleteOne</code> endpoint using the <code>BlogsController</code><strong> </strong>controller class.<p.new.line><p>Next, open your browser and navigate to <u><a href="http://localhost:5173/" target="_blank" rel="noopener noreferrer">http://localhost:5173</a></u>, and you should see the output on the screenshot below:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The first glimpse of our Remult app." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63614dff1eb9182703a65da6_image2_79575295c40725aca88abdf2c4081a89_800.png"><div.new.line><figure.new.line><p>Click the Add New button to create a new blog.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Creating a new blog about fullstack development." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63614dff1eb91880fda65da7_image1_9562fa5bf35783a59804210a8a68da4a_800.png"><div.new.line><figure.new.line><h2 id="698su">Conclusion and Resources<h2.new.line><p>In this tutorial, we went through a React TypesScript tutorial to build a full-stack application using Remult. We began by learning what Remult is and why a developer would use it to build full-stack web applications. Then, we built a blog application with CRUD operations as a demonstration.<p.new.line><p>Now that you’ve learned about Remult, how would you use it in your next project? To learn more about Remult, check out the official <u><a href="https://remult.dev/" target="_blank" rel="noopener noreferrer">documentation</a></u>.<p.new.line>\n
A full-stack application is made up of frameworks, libraries, and tools for developing two separate domain applications: the backend and the frontend. Building these two applications can be very hectic, especially if the frameworks are developed from different programming languages or if one developer is working on both sides of the application. However, we’re grateful to the JavaScript developers for creating backend frameworks that allow us to use JavaScript to build both the client and server sides of our application. The Remult developers expanded on this concept by developing a framework that allows us to build both the client and server sides of an application in a single project rather than having two separate projects. We’ll explore how this can be implemented in this tutorial. Then, we’ll learn how to build a full-stack application with TypeScript and React using Remult.
## What is Remult?
Remult is a full-stack TypeScript CRUD framework with a frontend type-safe API client and a backend ORM that uses entities as a single source of truth for your API. It saves developers time by abstracting all repetitive or poorly designed code, resulting in a more flexible web application. It makes full-stack app development easier by using only TypeScript code that’s easy to follow and refactor, and it fits well into any existing or new project.
### Why Use Remult?
Below are some of the reasons developers use Remult:
- It has a secure auto-generated TypeScript API model and classes that are consumed by frontend type-safe queries that can also be used as third-party applications.
- It’s a simple CRUD application that interacts with the database directly from the frontend and does not require any boilerplate, so data transformations, validations, and CRUD events are easily controlled.
- It uses a type-safe coding style to find and manipulate data on both the backend and frontend code.
- It eliminates redundant and error-prone duplication with model metadata and declarative code that impacts both the frontend and the backend.
## Prerequisites
This is a hands-on tutorial, so to follow along, be sure that you’ve done these things:
- Installed <u><a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a></u> V14 or later
- <u><a href="https://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwi3vPfd1bP6AhVKA4sKHQbnBWsYABAAGgJlZg&amp;ohost=www.google.com&amp;cid=CAESbOD2X-a6kboxXHXG3izU05eObOfzWxIrNJfa2IeMsImyvcs6l3QguTUf9pPYUNi6jbMn8Rz6TU0SWme6fbL3uUvtL6HyEzJhKOuYte37s4tYRlvpOV4oP-eB8VpRxFGnQhm1rArwTetsZzURSg&amp;sig=AOD64_3r0aVg59iknPszkLuo3XbggSzTLA&amp;q&amp;adurl&amp;ved=2ahUKEwjg2O_d1bP6AhUfgf0HHTn-AqMQ0Qx6BAgIEAE" target="_blank" rel="noopener noreferrer">MongoDB</a></u> Installed your database
- Prior knowledge of <u><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">TypeScript</a></u> and <u><a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">React</a></u>
## Project Setup
Without further ado, let’s scaffold a Remult React full stack application using Vite by running the command below:
e>npm create -y vite@latest remult-react-blog -- --template react-ts<br>cd remult-react-blog</pre><p>The above commands will scaffold a new React project with the following folder structure:
e>📦remult-react-blog<br>┣ 📂public<br>┃ ┗ 📜vite.svg<br>┣ 📂src<br>┃ ┣ 📂assets<br>┃ ┃ ┗ 📜react.svg<br>┃ ┣ 📜App.css<br>┃ ┣ 📜App.tsx<br>┃ ┣ 📜index.css<br>┃ ┣ 📜main.tsx<br>┃ ┗ 📜vite-env.d.ts<br>┣ 📜.gitignore<br>┣ 📜index.html<br>┣ 📜package.json<br>┣ 📜tsconfig.json<br>┣ 📜tsconfig.node.json<br>┗ 📜vite.config.ts</pre><p>In order to get your React application running, change the directory into the project folder, install the required packages, and start the application by running the commands below:
e>cd remult-react-blog<br><br>npm install</pre><p>Now, let’s set up the backend of the application.
### Install Dependencies
The first step in setting up the backend is to install the required dependencies. We’ll use <strong>Express </strong>for the backend, and since Remult creates both the backend and frontend in one project, we’ll need to have them running concurrently.  So run the commands to install <strong>Express </strong>and the <strong>Remult</strong> SDK, and use <code>ts-node</code> to run the application in development.
e>npm i express remult<br>npm i --save-dev @types/express ts-node-dev concurrently</pre><p>Next, wait for the installation to be completed and proceed to creating the backend.
### Create the Backend
With the required packages for the backend setup installed, create a TypeScript config file and add the configurations below:
e>{<br>  &quot;extends&quot;: &quot;./tsconfig.json&quot;,<br>  &quot;compilerOptions&quot;: {<br>    &quot;module&quot;: &quot;commonjs&quot;,<br>    &quot;emitDecoratorMetadata&quot;: true,<br>    &quot;esModuleInterop&quot;: true<br>  }<br>}</pre><p>Then, create a <strong>server </strong>folder in the <strong>src </strong>folder. Next, in the server folder, create an <strong>index.ts </strong>file and make an Express server with the code snippets below:
e>import express from &#x27;express&#x27;;<br>const app = express();<br><br>app.listen(3002, () =&gt; console.log(&quot;Server started&quot;));</pre><p>Since the application is using the Common.js module, you need to remove the <code>&quot;type&quot;: &quot;module&quot;</code> entry from the <strong>package.json</strong> file created by Vite.
Next, create an <strong>api.ts</strong> file on the <strong>server </strong>and load Remult in the backend as an Express middleware with the code snippet below:
e>import { remultExpress } from &#x27;remult/remult-express&#x27;;<br>export const api = remultExpress();</pre><p>Then, register the Remult <strong>API</strong> middleware in the <strong>server/index.ts</strong> file with this code snippet:
e>Import {api} from “./api”;<br>app.use(api);</pre><p>Next, update the<strong> </strong><code>tsconfig.json</code> file to enable TypeScript decorators in the React.js full stack App with the entry below:
e>&quot;experimentalDecorators&quot;: true</pre><p>A Remult application is configured to run the frontend and backend from the same domain in production. However, in development, the API server listens to <u><a href="http://localhost:3002/" target="_blank" rel="noopener noreferrer">http://localhost:3002</a></u>, while the frontend listens to port <u><a href="http://localhost:5173/" target="_blank" rel="noopener noreferrer">http://localhost:5173</a></u>. Therefore, you need to use the Vite proxy feature to divert all requests to the <strong>API</strong> to <u><a href="http://localhost:5173/api" target="_blank" rel="noopener noreferrer">http://localhost:5173/api</a></u>. To do this, update the <strong>vite.confg.ts</strong> file with the code snippet below:
e>export default defineConfig({<br>  plugins: [react()],<br>  server: { proxy: { &#x27;/api&#x27;: &#x27;http://localhost:3002&#x27; } }<br>})</pre><p>Next, update the <strong>package.json</strong> file to add a start script to run the application in development with the entry below:
e>&quot;dev&quot;: &quot;concurrently -k -n \\&quot;API,WEB\\&quot; -c \\&quot;bgBlue.bold,bgGreen.bold\\&quot; \\&quot;ts-node-dev -P tsconfig.server.json src/server/\\&quot; \\&quot;vite\\&quot;&quot;</pre><p>Now, run the application with this command:
With the backend created, let’s proceed to connecting the application to a MongoDB database to store our blog data. To get started, install the MongoDB package by running the command below:
e>npm i mongdb</pre><p>Then, update the<strong> server/index.ts </strong>file and connect it to MongoDB with the following code snippet:
e>import { remultExpress } from &#x27;remult/remult-express&#x27;;<br>import { MongoClient } from &#x27;mongodb&#x27;;<br>import { MongoDataProvider } from &#x27;remult/remult-mongo&#x27;;<br><br>app.use(remultExpress({<br>  dataProvider: async () =&gt; {<br>    const client = new MongoClient(&quot;mongodb://localhost:27017/local&quot;);<br>    await client.connect();<br>    return new MongoDataProvider(client.db(&#x27;blogs&#x27;), client);<br>  }<br>}));<br></pre><p>With the above code snippet, we imported the <code>remultExpress</code><strong> </strong>middleware, the <code>MongoClient</code> class and the <code>MongoDataProvider</code> class. The <code>remultExpress</code><strong> </strong>middleware<strong> </strong>takes a <code>dataProvider</code><strong> </strong>object as an argument, which allows us to connect to the database. We also created a client instance from the <code>MongoClient</code> client class passing in the database URI and established a connection using the calling-the-client-connect method.
## Create a Blog Entity with Remult
Now, with the connection to our database established, let&#x27;s create a Blog entity to define and create our blog model. To do this, we’ll create a <strong>shared </strong>folder in the server folder. We’re saving it in this file because Remult classes are shared between the frontend and backend. This means we can access in the frontend any class created in the backend.
In the <strong>shared</strong> folder, create a blog.ts file and add the code below:
e>import { Entity, Fields } from &#x27;remult&#x27;;<br><br>@Entity(&#x27;blogs&#x27;, {<br>  allowApiCrud: true<br>})<br><br>export class Blogs {<br>  @Fields.uuid()<br>  id!: string;<br><br>  @Fields.string()<br>  title = &#x27;&#x27;;<br><br>  @Fields.string()<br>  coverImage = &#x27;&#x27;;<br><br>  @Fields.string()<br>  content = &#x27;&#x27;;<br>}</pre><p>In the above code snippets, we imported the Remult <code>Entity</code> and <code>Fields</code><strong> </strong>decorators. We used the <code>Entity</code><strong> </strong>decorator to create a blogs entity, which will be translated to a model in our MongoDB base with the fields we defined in the <code>Blogs</code> class using the <code>Fields</code> decorator. We also set<strong> </strong><code>allowApiCrud</code><strong> </strong>to <code>true</code> in the <code>@Entity</code> decorator to allow us to perform CRUD operations on this entity.
Next, update the <strong>server/index.ts</strong> file to register the entity in the <code>remultExpress</code> middleware with this code snippet:
e>import { Blogs } from &#x27;./shared /blog&#x27;;<br><br>app.use(remultExpress({<br>  dataProvider: async () =&gt; {<br>    const client = new MongoClient(&quot;mongodb://localhost:27017/local&quot;);<br>    await client.connect();<br>    return new MongoDataProvider(client.db(&#x27;test&#x27;), client);<br>  },<br>  entities: [Blogs],<br>}));</pre><p>In the above code snippet, we imported the Blogs entity and registered it to the application in the array of <strong>entities</strong> object.
## Create CRUD Operations
Now let’s create our CRUD functions so that we Create, Read, Update and Delete a blog from our database.
First, you need to create a <code>blogController.ts</code> file in the <strong>server/shared </strong>folder. In the <code>blogController.ts</code><strong> </strong>file, add the following code:
e>import { BackendMethod, remult } from &quot;remult&quot;;<br>import { Blogs } from &quot;./blog&quot;;<br><br>export class BlogsController {<br><br>  @BackendMethod({ allowed: true })<br>  static async create(title: string, coverImage: string, content: string) {<br>    const newBlog = await remult.repo(Blogs).save({ title, content, coverImage })<br>   return newBlog<br>  }<br>static async getAll() {<br>  return await this.blogRepo.find();<br>}<br>static async getOne(id: string) {<br>  return await this.blogRepo.findId(id)<br>}<br>static async updateOne(id: string, title: string, coverImage: string, content: string) {<br>  return await this.blogRepo.update(id, { title, coverImage, content })<br>}<br>static async deleteOne(id:string) {<br>  return await this.blogRepo.delete(id)<br>}</pre><p>In the above code snippets, we imported the Remult <code>BackendMethod</code> decorator and <code>Remult</code><strong> </strong>object. The <code>BackendMethod</code><strong> </strong>decorator tells Remult to expose the methods we defined in the <code>BlogsController</code> as API endpoints. Then, we used the <code>remult.repo</code><strong> </strong>method to create a repository for our Blogs entity. This provides us with the methods we need to perform database CRUD operations in each controller method.
Next, you also need to register the <code>BlogsController</code> like you did for the <code>Blogs</code><strong> </strong>entity in the <code>server/index.ts</code> file. This can done with the code snippet below:
We’re done setting up the backend part of the application. Now, let’s move to our React frontend and consume the API’s we’ve created in our backend.
To get started, create a controllers folder in the <strong>src </strong>to create some React controllers for your application.
First, create a <strong>Form.ts</strong> file in the controllers folder, and add the code below:
e>import { useState } from &quot;react&quot;;<br>import { BlogsController } from &quot;../server/shared /blogController&quot;;<br>export function Form() {<br>  const [title, setTitle] = useState(&quot;&quot;);<br>  const [coverImage, setCoverImage] = useState(&quot;&quot;);<br>  const [content, setContent] = useState(&quot;&quot;);<br>  <br>  const create = async () =&gt; {<br>    await BlogsController.create(title, coverImage, content);<br>};<br>return (<br>&lt;div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;label htmlFor=&quot;exampleFormControlInput1&quot; className=&quot;form-label&quot;&gt;<br>    Title<br>    &lt;/label&gt;<br>    &lt;input<br>      type=&quot;email&quot;<br>      className=&quot;form-control&quot;<br>      id=&quot;exampleFormControlInput1&quot;<br>      onChange={(e) =&gt; setTitle(e.target.value)}<br>    /&gt;<br>  &lt;/div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;label htmlFor=&quot;exampleFormControlInput1&quot; className=&quot;form-label&quot;&gt;<br>    Cover Image<br>    &lt;/label&gt;<br>    &lt;input<br>      type=&quot;email&quot;<br>      className=&quot;form-control&quot;<br>      id=&quot;exampleFormControlInput1&quot;<br>      onChange={(e) =&gt; setCoverImage(e.target.value)}<br>    /&gt;<br>  &lt;/div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;label htmlFor=&quot;exampleFormControlTextarea1&quot; className=&quot;form-label&quot;&gt;<br>    Content<br>    &lt;/label&gt;<br>    &lt;textarea<br>      className=&quot;form-control&quot;<br>      id=&quot;exampleFormControlTextarea1&quot;<br>      rows=&quot;3&quot;<br>      onChange={(e) =&gt; setContent(e.target.value)}<br>    &gt;&lt;/textarea&gt;<br>  &lt;/div&gt;<br>  &lt;div className=&quot;mb-3&quot;&gt;<br>    &lt;button className=&quot;btn btn-primary&quot; onClick={()=&gt; create()}&gt;Add&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>);<br>}</pre><p>In the above code snippet, we imported the <code>BlogsController</code> class so we can access the API endpoints that we defined there. We also created a state variable to store the blog <code>title</code> and <code>coverImage</code> <code>content</code><strong> </strong>values from the form data. We made a<strong> </strong><code>create</code><strong> </strong>function and called the create endpoint from our <code>BlogsController</code> class, passing the variables we defined for the form values to create a new blog.
We need this form to display in a modal when clicked. Therefore, we need to create a Modal.tsx file in the controllers file to create a <code>Modal</code> component. This can be done by using the code snippet below:
e>import { Form } from &quot;./Form&quot;;<br><br>export function Modal() {<br>return (<br>  &lt;div<br>    className=&quot;modal fade&quot;<br>    id=&quot;staticBackdrop&quot;<br>    data-bs-backdrop=&quot;static&quot;<br>    data-bs-keyboard=&quot;false&quot;<br>    tabIndex=&quot;-1&quot;<br>    aria-labelledby=&quot;staticBackdropLabel&quot;<br>    aria-hidden=&quot;true&quot;<br>  &gt;<br>  &lt;div className=&quot;modal-dialog&quot;&gt;<br>   &lt;div className=&quot;modal-content&quot;&gt;<br>    &lt;div className=&quot;modal-header&quot;&gt;<br>      &lt;h5 className=&quot;modal-title&quot; id=&quot;staticBackdropLabel&quot;&gt;<br>      Create New Blog<br>      &lt;/h5&gt;<br>    &lt;button<br>      type=&quot;button&quot;<br>      className=&quot;btn-close&quot;<br>      data-bs-dismiss=&quot;modal&quot;<br>      aria-label=&quot;Close&quot;<br>    &gt;&lt;/button&gt;<br>    &lt;/div&gt;<br>    &lt;div className=&quot;modal-body&quot;&gt;<br>    &lt;Form /&gt;<br>    &lt;/div&gt;<br>   &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>);<br>}</pre><p>In the above code, we used the <code>Bootstrap</code> classes to create a modal for the form component. Then, we imported the <code>Form</code> component and rendered it in the modal body.
Next, we’ll need to add a clickable button to show the modal component we just created. To add a button in the header part of the application, create a Header.ts file in the controllers folder and add the code below:
e>import { Modal } from &quot;./Modal&quot;;<br><br>export function Header() {<br>return (<br>  &lt;nav className=&quot;navbar navbar-light bg-light&quot;&gt;<br>    &lt;div className=&quot;container-fluid&quot;&gt;<br>    &lt;a className=&quot;navbar-brand&quot;&gt;Blog App&lt;/a&gt;<br>    &lt;button<br>      className=&quot;btn btn-primary&quot;<br>      data-bs-toggle=&quot;modal&quot;<br>      data-bs-target=&quot;#staticBackdrop&quot;<br>    &gt;<br>    Add New<br>    &lt;/button&gt;<br>   &lt;/div&gt;<br>  &lt;Modal/&gt;<br>&lt;/nav&gt;<br>);<br>}</pre><p>Now, let’s update the code in the<strong> </strong><code>App.tsx</code> file to make the <code>Header</code> component available, read the blog data from our Remult backend, and render it to users with the following:
e>import { useEffect, useState } from &quot;react&quot;;<br>import { Header } from &quot;./components/Header&quot;;<br>import { BlogsController } from &quot;./server/shared /blogController&quot;;<br>import { Blogs } from &quot;./server/shared /blog&quot;;<br><br>function App() {<br>  const [blogs, setBlogs] = useState&lt;Blogs[]&gt;([]);<br>  useEffect(() =&gt; {<br>    const fetchData = async () =&gt; {<br>    const blogData = await BlogsController.getAll();<br>    setBlogs(blogData);<br>  };<br>  fetchData();<br>});<br>const deleteBlog = async (id:string)=&gt;{<br>  await BlogsController.deleteOne(id)<br>}<br>return (<br>&lt;div className=&quot;App&quot;&gt;<br>  &lt;Header /&gt;<br>    &lt;div className=&quot;container&quot;&gt;<br>    &lt;div className=&quot;row&quot;&gt;<br>      {blogs &amp;&amp;<br>        blogs.map((blog: Blogs) =&gt; {<br>      return (<br>        &lt;div className=&quot;card&quot; style={{ width: &quot;18rem&quot;, margin:&quot;20px&quot; }} key={blog.id}&gt;<br>          &lt;img<br>            src={blog.coverImage}<br>            className=&quot;card-img-top&quot;<br>            alt=&quot;...&quot;<br>          /&gt;<br>        &lt;div className=&quot;card-body&quot;&gt;<br>          &lt;h5 className=&quot;card-title&quot;&gt;{blog.title}&lt;/h5&gt;<br>            &lt;p className=&quot;card-text&quot;&gt;<br>            {blog.content}<br>            &lt;/p&gt;<br>            &lt;a href=&quot;#&quot; className=&quot;btn btn-sm btn-danger&quot; onClick={()=&gt;{<br>               deleteBlog(blog.id)<br>            }}&gt;<br>            Delete<br>            &lt;/a&gt;<br>        &lt;/div&gt;<br>       &lt;/div&gt;<br>     );<br>    })}<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>);<br>}<br>export default App;</pre><p>Also, with the above code snippet, we created a delete function to delete blogs from our database by calling the <code>deleteOne</code> endpoint using the <code>BlogsController</code><strong> </strong>controller class.
Next, open your browser and navigate to <u><a href="http://localhost:5173/" target="_blank" rel="noopener noreferrer">http://localhost:5173</a></u>, and you should see the output on the screenshot below:
![](loads-ssl.webflow.com/6143afec68f555387049efb3/63614dff1eb9182703a65da6_image2_79575295c40725aca88abdf2c4081a89_800.p)
Click the Add New button to create a new blog.
![](="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63614dff1eb91880fda65da7_image1_9562fa5bf35783a59804210a8a68da4a_800.p)
## Conclusion and Resources
In this tutorial, we went through a React TypesScript tutorial to build a full-stack application using Remult. We began by learning what Remult is and why a developer would use it to build full-stack web applications. Then, we built a blog application with CRUD operations as a demonstration.
Now that you’ve learned about Remult, how would you use it in your next project? To learn more about Remult, check out the official <u><a href="https://remult.dev/" target="_blank" rel="noopener noreferrer">documentation</a></u>.
