![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd7a542cefb8b199fd7353_dartoncli_1a0fd612b711ec435a2cc5d6bc1b7e45_2000.jpeg)
"cli; dart-c"
# Dart CLI Foundations: CLI Tools to Streamline Your Workflow
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<p>Are you ready to take your software development skills to the next level? Then, it's time to dive into the world of Command Line Interface (CLI) tools with dart CLI. These tools run directly in the terminal, the familiar space for developers, and can streamline your workflow with their minimal interface and quick access. <p.new.line><p>In this series of articles, we will be exploring Dart CLI apps and how to build them. You'll learn about the structure of Dart CLI projects, handling arguments, working with input/output, reading and writing to files, and finally, compiling and installing your Dart CLI apps. Embrace the full power of the terminal and join us on this exciting journey to build CLI apps in Dart.<p.new.line><h2 id="btbb4">Getting Started <h2.new.line><p> <a href="https://dart.dev/get-dart">Install the Dart SDK</a> to get started. We will be using <a href="https://marketplace.visualstudio.com/items?itemName=MeshIntelligentTechnologiesInc.pieces-vscode">Visual Studio Code</a> as the development environment for our Command Line Interface (CLI) application. However, the choice of Integrated Development Environment (IDE) is not crucial and you can work with any IDE that you prefer, without affecting the learning outcome.<p.new.line><p>To create a new Dart CLI project, run the following dart command:<p.new.line><pre>dart create dart_cli -t console</pre><p>This will create a Dart CLI project in the respective directory.<p.new.line><p>You can run your Dart CLI application with the following dart command:<p.new.line><pre>dart run bin/dart_cli.dart</pre><p>Here, ```-t``` defines the template for the Dart project. <a href="https://dart.dev/tools/dart-create">Dart has several templates</a> you can use to work on CLI, web or server-side projects. <p.new.line><p><a href="https://takrutvik.pieces.cloud/?p=0b324f8f6b" target="_blank" rel="noopener noreferrer">Save the above commands</a><p.new.line><h2 id="86fi0">Understanding Project Structure with Dart CLI<h2.new.line><p>Three of the most important things in our project structure are the <a href="https://dart.dev/tools/pub/package-layout#public-directories" target="_blank" rel="noopener noreferrer"><strong>bin</strong> and <strong>lib</strong></a> directories along with the <strong>pubspec.yaml</strong> file.<p.new.line><ul><li><strong>bin:</strong> This is a public directory that is the entry point for your Dart CLI application. This includes the executable Dart file that the CLI app will run.<li.new.line><li><strong>lib: </strong>Lib includes the public libraries that your application uses. Like Dart methods, classes or any other code, this is imported into the bin directory.<li.new.line><li><a href="https://dart.dev/tools/pub/pubspec"><strong>pubspec.yaml</strong>:</a> The Dart CLI app is a package in itself. This file contains the package/CLI app information like name, app version, any dependencies your app is using, etc. It also includes the entry point for your CLI application defined by the executables. This usually directs to the executable in the bin folder. Whenever you’ll be using your CLI app, you’ll be running this executable. <li.new.line><ul.new.line><h3 id="32d7e">Arguments in Dart CLI<h3.new.line><p>Within the ```bin/dart_cli.dart``` file, you’ll see that the main function accepts a list of strings called <strong>arguments</strong>. These are inputs provided to CLI applications that you can use to know what to do.<p.new.line><p>Arguments are broken down into the following major types relevant to this tutorial:<p.new.line><ul><li><strong>Command:</strong> The command you wish to run to execute a particular task.<li.new.line><li><strong>Flags:</strong> Flags hold a boolean value. They can be used to turn on/off some flows within your program.<li.new.line><li><strong>Options</strong>: Options are <strong>key-value pairs</strong> that you can define. You can also define options that accept a value from an allowed list of values, thus restricting the input that a user can provide for the option.<li.new.line><ul.new.line><p>For example, take a look at the following command, which creates the Dart project with some additional arguments added:<p.new.line><pre>$ dart create dart_cli -t console --force --[no-]pub</pre><p><a href="https://takrutvik.pieces.cloud/?p=08f342bb7e" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><ol type="1"><li><strong>dart:</strong> This is the executable or the program that you want to run. You can treat it as a ```root-command```.<li.new.line><li><strong>create:</strong> The command you want to execute.<li.new.line><li><strong>dart_cli:</strong> This is an argument for the earlier command which defines the name for the project. This is not predefined, so if there are any such arguments that a command would be accepting, then it should know about it.<li.new.line><li><strong>-t:</strong> An option where the ```t``` is the abbreviation used for the ```template``` for the project. You can also provide options like ```follow```, ```-t console``` or ```--template=&quot;console&quot;```.<li.new.line><li><strong>console</strong>: This is the value for the option earlier.<li.new.line><li>—<strong>force:</strong> This is a flag and is used to force the creation of a project even if the target directory already exists. You can also turn on certain flags by using the flags abbreviations (if any) provided for them, e.g., ```-f```. Both of these methods will turn the respective flag on.<li.new.line><li>—<strong>no-pub</strong>: By default, Dart create will run ```pub get```, which will fetch the dependencies within your <strong>pubspec.yaml.</strong> The prefix <strong>no</strong> is used to set the flag’s value to false.<li.new.line></ol><p>Now that we are clear on the different types of arguments we can expect in our CLI application, let’s see how we can handle those arguments within the code.<p.new.line><h3 id="6dtcv">Parsing Arguments in Dart CLI<h3.new.line><p>You’ll see that within our main method, the arguments are provided as a list of strings. Working with them this way would be inefficient and unmanageable. Therefore, what we’ll do is parse the list of arguments into something that’s more approachable and friendlier to use.<p.new.line><p>We’ll be using the <strong>args</strong> package, which helps us define parsers for the raw command line arguments. You can add it to your project by running the following command:<p.new.line><pre>$ dart pub add args</pre><p><a href="https://takrutvik.pieces.cloud/?p=13a74a8cee" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>This will add the <strong>args</strong> dependency in your <strong>pubspec</strong> file. We used the Darts<a href="https://dart.dev/tools/pub/cmd" target="_blank" rel="noopener noreferrer"> package manager <strong>pub</strong></a> to add this dependency.<p.new.line><p>Now, take a look at the code below:<p.new.line><pre>void main(List&lt;String&gt; arguments) async {<br><br> final ArgParser parser = ArgParser()<br>    ..addCommand(&quot;create&quot;)   <br>  ..addOption(<br>    &quot;template&quot;,<br>    defaultsTo:   &quot;t&quot;,<br>   // If allowed is non-null, then input will be restricted to the values<br>   // provided in allowed list.<br>      allowed:   [<br>        &quot;console&quot;,<br>        &quot;package&quot;<br>        &quot;web&quot;,<br>        &quot;server-shelf&quot;,<br>       ],<br>     )<br>     ..addFlag(&quot;force&quot;,   abbr:   &quot;f&quot;);<br> <br> final ArgResults argResults = parser.parse(arguments);<br><br> final command = argResults.command!.name!;   <br> // gets the command entered<br><br> final isForced = argResults[&quot;force&quot;] as bool;<br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=d3b0499bd4" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>There are two important pieces of information here, the ```ArgParser``` and the ```ArgResults```:<p.new.line><ul><li><strong>ArgParser:</strong> ```ArgParser``` can be used to define parsers to parse the arguments. You can then add to the parser the commands, flags and options that you expect to use in your CLI application.<li.new.line><li><strong>ArgResults:</strong> Once you’ve created your parser, you can parse the raw ```arguments``` and it’ll return the ```ArgResults``` object, which will map the raw values from the ```arguments``` list to the defined commands, flags and options. This makes it easier to use the arguments from input through a concrete class. You can also treat it like a ```map``` to find different values as we did above to get values for the ```force``` flag.<li.new.line><ul.new.line><h3 id="epd1g">I/O<h3.new.line><p>The<a href="https://dart.dev/articles/libraries/dart-io" target="_blank" rel="noopener noreferrer"> dart:io</a> library provides us with different streams through which we can manage input/output events. Let’s take a look at them below.<p.new.line><h4 id="1h65">Output Stream<h4.new.line><p>The ```stdout``` from dart:io provides the standard output stream. This stream can be used to log outputs to the terminal, like below:<p.new.line><pre>stdout.writeln(&quot;Hello World!&quot;);</pre><p><a href="https://takrutvik.pieces.cloud/?p=391944bc1f" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>This will output ```&quot;Hello World&quot;``` and is a non-blocking operation. This means any other i/o operations will not be blocked from executing while this is running.<p.new.line><h4 id="g7c3">Input Stream<h4.new.line><p>The ```stdin``` provides the standard input stream, which we can read/listen to get the input from the terminal, like the following:<p.new.line><pre>final input = stdin.readLineSync();<br><br>stdout.writeln(input);</pre><p><a href="https://takrutvik.pieces.cloud/?p=85b64c8d78" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>Here, ```readLineSync()``` listens to the input from the standard stream. This is a blocking operation, and until input is received and the user presses return, other i/o events are blocked.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Hello World." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/635ab3e8bd64ae625f663586_input_demo_983b9a71f3f6da6446887a2a966e666e.gif"><div.new.line><figure.new.line><p>Alternatively, if you want a non-blocking input read, then you can use the ```.pipe()``` method:<p.new.line><pre>final input = await stdin.pipe(stdout);</pre><p><a href="https://takrutvik.pieces.cloud/?p=38234c9a80" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>This method is <strong>non-blocking</strong> and <strong>async</strong>. It takes in another stream consumer like ```stdout```, which consumes the events from the ```stdin``` stream without blocking the ```output``` stream.<p.new.line><h4 id="9f89h">Error Stream<h4.new.line><p>It’s not uncommon to come across errors in your applications and catch them, or to explicitly throw errors if things don’t add up.<p.new.line><p>The dart:io library also provides a standard error stream that logs the errors to the console:<p.new.line><pre>stderr.writeln(&quot;Ooops! Something's not right!&quot;)</pre><p><a href="https://takrutvik.pieces.cloud/?p=50d64f936a" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>This will log out the given error. Also, this operation is non-blocking.<p.new.line><h4 id="7r3c1">Exception Handling<h4.new.line><p>Your application may throw exceptions at runtime. You should handle these exceptions when they occur, and provide the proper message to the user to tell them what went wrong. Exceptions can be easily caught with a ```try/catch``` block.<p.new.line><pre>void main(List&lt;String&gt; arguments) {<br><br> try {<br>  // This will throw an exception as abbr can be either null or character of length 1.<br> final ArgParser parser = ArgParser()..addFlag(&quot;save&quot;, abbr: &quot;save&quot;);<br>      } on ArgParserException catch (e) {<br>  stdout.writeln(&quot;Failed while parsing arguments&quot;);<br>      studout.writeln(e.message);<br>      exit(1);<br>    } catch (e) {<br>  stdout.writeln(&quot;Something went wrong&quot;);<br>  studout.writeln(e.message);<br>          exit(1);<br>}<br><br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=c83548a027" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>Here, we used a ```try/catch``` block to catch any exceptions that might be thrown during the parsing of ```arguments```. Also, we are defining a ```catch``` block that will only catch the exceptions of type ```ArgParserException```. This makes it easier to work with different types of exceptions individually and provide outputs that are more helpful for those kinds of exceptions.<p.new.line><p>The last catch block will catch all other exceptions aside from the ```ArgParserException``` type, and provide a general message with the error thrown to the user.<p.new.line><h2 id="949hi"><strong>Dart CLI Exit Codes</strong><h2.new.line><p>Exit codes are a small number that shows the success, failure or any other state of the program to the system that called it. Within Dart, there are pre-defined exit codes appropriate for certain conditions.<p.new.line><p>Generally, exit codes like ```0``` mean ```success```, ```1``` mean ```warning``` and ```2``` mean an ```error``` has occurred. See more Dart exit codes here:<a href="https://dart.dev/tutorials/server/cmdline#setting-exit-codes" target="_blank" rel="noopener noreferrer"> src</a>.<p.new.line><p>The dart:io library defines a top-level property called ```exitCode```, which you can change to set the exit code for the running program:<p.new.line><pre>void readFile(String path) {<br> try {<br>  final file = File(path);<br>  file.readAsLines();<br> } on FileSystemException catch (e) {<br>   exitCode = 2;<br> }<br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=20364f8430" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>Setting up a new ```exitCode``` doesn’t terminate the program. The program will continue to execute until it’s complete or an error occurs.<p.new.line><p>Along with the ```exitCode```, there is also a top-level method ```exit(exit_code)```, which sets the ```exitCode``` to the given code and terminates the program immediately.<p.new.line><h2 id="4587u">Reading/Writing to Files <h2.new.line><p>As with any other type of application, when working with a CLI, you may need to access files on a user's system for either reading or writing purposes. The dart:io library provides ways to access files on the system. Here’s how you can do that:<p.new.line><h3 id="8k00q">Reading a File<h3.new.line><pre>final notesFile = File(&quot;./bin/notes.txt&quot;);<br><br>final notes = notesFile.readAsLinesSync();<br><br>for (String note in notes) {<br>       stdout.writeln(note);<br>   }</pre><p><a href="https://takrutvik.pieces.cloud/?p=14544997ee" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>The ```File``` object is part of dart:io and has utility methods that you can use for reading/writing to a file at the given path.<p.new.line><p>Here, you’re reading from a file named <strong>notes.txt</strong> within the <strong>bin</strong> folder, as shown below:<p.new.line><pre>Learn Dart on CLI.🙌<br>Practice what I learned.🧑🏽‍💻<br>Build something cool with it.🔥</pre><p><a href="https://takrutvik.pieces.cloud/?p=66cf41bb79" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>The file is read as lines, and then you log each line to the output.<p.new.line><p>Output:<p.new.line><pre>$ dart run bin/dart_cli.dart<br><br>Learn Dart on CLI.🙌<br>Practice what I learned.🧑🏽‍💻<br>Build something cool with it.🔥</pre><p><a href="https://takrutvik.pieces.cloud/?p=dc774d970f" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><h3 id="9gbfe">Writing to a File<h3.new.line><pre>final newNotes = [<br> &quot;Having fun learning Dart on CLI!🤩&quot;,<br> &quot;Dart makes it so easy to write cli apps.👍🏽&quot;,<br> &quot;Can't wait to build something cool with it!💙&quot;,<br>      ];<br><br> final notesFile = File(&quot;./bin/notes.txt&quot;);<br><br> final notesString = newNotes.join(&quot;\\n&quot;);<br><br>      notesFile.writeAsStringSync(<br>          notesString,<br>// FileMode.append will add the new content at the end of the file.<br>            mode: FileMode.append,<br>//   FileMode.write will override the existing file content with the new content.<br> // mode: FileMode.write,<br>    );</pre><p><a href="https://takrutvik.pieces.cloud/?p=1e624bad9a" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>You can see that here we have defined some new notes. We are writing them to a notes file by using ```.writeAsStringSync```. Before writing to the file, we joined the existing notes with ```\\\\n``` line delimiters because each note will be written on a new line.<p.new.line><p>Next, set the ```FileMode.append```, which will add the new content to the end of the file. You can set it to ```.write``` if you want to override the existing content of the file.<p.new.line><p>```File``` has many other utility methods that you may find useful. Some of the most common ones are shown below:<p.new.line><pre>// Creates the file at the path the File object was initialized with.<br>    file.create();<br><br> // Checks if the file exists.<br>    file.exists();<br><br> // Deletes the file.<br>    file.delete();<br><br> // Listens to changes on file.<br>    file.watch().listen((event) {<br> // File changed. Do something.<br>   });</pre><p><a href="https://takrutvik.pieces.cloud/?p=278b46bb5e" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><h2 id="f8lhk">Styling Your Application<h2.new.line><p>Oftentimes, CLI applications can have a less appealing visual experience as coloring the output text, adding a colorful background to text and changing how users can interact with the app is challenging. This is definitely not an easy task; there are a lot of factors that go into getting this right.<p.new.line><p>Next, we’ll take a look at a logger package that makes it easier for us to style our CLI.<p.new.line><h3 id="5kom9">Adding Mason Logger<h3.new.line><p>We can use<a href="https://pub.dev/packages/mason_logger" target="_blank" rel="noopener noreferrer"> Mason logger</a> to log stylized and more interactive outputs to the terminal.<p.new.line><p>To use it, add it as a dependency in your <strong>pubspec.yaml</strong>, or just run the following command that will add it for you:<a href="https://takrutvik.pieces.cloud/?p=7d2e498b49"> </a><p.new.line><pre>$ dart pub add mason_logger</pre><p><a href="https://takrutvik.pieces.cloud/?p=7d2e498b49" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><h4 id="7540k">Stylized Output<h4.new.line><p>Mason provides us with a range of different output levels like info, warning, error, success, etc. It also allows us to add a background color to text, as in the example below.<p.new.line><pre>import 'package:mason_logger/mason_logger.dart';<br><br>void main(List&lt;String&gt; arguments) async {<br> final logger = Logger();<br><br>    logger.info('\\nThis is an info.🔵\\n');<br>    logger.warn('\\nThis is a warning.🌕');<br>    logger.err('\\nThis is an error.🔴');<br>    logger.success('\\nThis is success!🟢');<br><br>    logger.success(<br>          backgroundBlue.wrap(&quot;\\nLook! A text with colored background!🥳&quot;),<br>    );<br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=d29d4cbad1" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>Output:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Project output." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/635ab3e8bd64ae4cb5663587_output_b1d7215a553f6793cc3bd89dd7444bf2_800.png"><div.new.line><figure.new.line><h4 id="b7t7n">Rich Interactions<h4.new.line><p>Mason can not only help with styling output, but also with implementing more common types of interactive outputs with rich experiences like below:<p.new.line><pre>import 'package:mason_logger/mason_logger.dart';<br><br>void main(List&lt;String&gt; arguments) async {<br> final logger = Logger();<br> <br> // Confirmation message<br> final isConfirmed =<br>                logger.confirm(&quot;This is a confirmation messsage with yes and no option.&quot;);<br><br> if (isConfirmed) {<br> // User permitted the action.<br>   }<br><br> // Single choice selection<br> final selectedChoice = logger.chooseOne(&quot;Options picker&quot;, choices: [<br> &quot;Choice1&quot;,<br> &quot;Choice2&quot;,<br> &quot;Choice3&quot;,<br>      ]);<br><br> logger.info(&quot;Selected Choice--&gt;$selectedChoice&quot;);<br><br> // Multiple choice selection<br> final selectedListOfChoices = logger.chooseAny(&quot;Options picker&quot;, choices: [<br> &quot;Choice1&quot;,<br> &quot;Choice2&quot;,<br> &quot;Choice3&quot;,<br> &quot;Choice4&quot;,<br> &quot;Choice5&quot;,<br>  ]);</pre><p><a href="https://takrutvik.pieces.cloud/?p=543c4f9f53" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>Output:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Output of the Dart CLI code above showing an options picker in the terminal. " src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/635ab3e8bd64ae74f9663588_output2_17116c26be794acf2becc3bf0e25e9ac.gif"><div.new.line><figure.new.line><h2 id="1oksj">Compiling<h2.new.line><p>Once you’re done with your app, it’s time to compile it so you can distribute it to stores, or anywhere else you like.<p.new.line><p>While in the dev process, the application runs on top of Dart VM, which is optimized for faster performance and execution times.<p.new.line><p>For production, you can use the Dart compiler. This offers AOT compilation to compile the program to native machine code:<p.new.line><pre>$   dart compile exe bin/dart_cli.dart</pre><p><a href="https://takrutvik.pieces.cloud/?p=ef7b47a777" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>This will generate the application executable in your <strong>bin</strong> folder.<p.new.line><p>You can run the executable like so:<p.new.line><pre>$ ./bin/dart_cli.exe</pre><p><a href="https://takrutvik.pieces.cloud/?p=593a4db4c7" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><blockquote><strong>Note:</strong> The executable generated is a stand-alone executable compatible with the platform it was generated on. Cross-compilation is not yet supported through the compiler. You’ll need to run the compiler across the needed platform to generate a compatible executable for that platform.</blockquote><p>Cross-compilation support for Dart CLI is being worked on. You can follow its progress<a href="https://github.com/dart-lang/sdk/issues/28617" target="_blank" rel="noopener noreferrer"> here.</a><p.new.line><p>Another interesting fact about the executables is that they can be run without installing Dart SDK on the system they’re running on. This is because the executables are self-contained with everything needed to run properly.<p.new.line><h2 id="dbr30">Installing Dart CLI<h2.new.line><p>Besides building the executable, you can also directly install the CLI app through <strong>pub.</strong> However, before this step, make sure you’ve mentioned the<a href="https://dart.dev/tools/pub/pubspec#executables" target="_blank" rel="noopener noreferrer"> executables</a> in your <strong>pubspec.yaml,</strong> which you’ll want to activate:<p.new.line><pre>..<br>...<br>executables:<br>    dart_cli: dart_cli # value can be left empty and is inferred from the key<br>    other_executable: todo_cli<br>..<br>...</pre><p><a href="https://takrutvik.pieces.cloud/?p=f2ee479a8d" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>To add the executable, you’ll need to provide a <strong>key-value</strong> pair. If the ```value``` is not provided, then it’s inferred from the ```key```.<p.new.line><p>Then, run the following command to activate values globally:<p.new.line><pre>$ dart pub global activate --source path &lt;project_path&gt;</pre><p><a href="https://takrutvik.pieces.cloud/?p=31ec45a850" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>Next, provide the path of the project. If you’re in the project’s directory, provide the ```project_path``` as ```.``` .<p.new.line><p>This will globally activate the CLI application by installing the executable on your system.<p.new.line><p>You can run the application from anywhere on your system like so:<p.new.line><pre>$ dart_cli &lt;command&gt;</pre><p><a href="https://takrutvik.pieces.cloud/?p=315f4da0b2" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><h2 id="ctjim">Summary on Dart CLI<h2.new.line><p>So, you took a leap of faith in learning to build CLI apps with Dart. You learned the basics of i/o, working with files, HTTP requests and more in Dart. Along with this, you also looked into how to compile and install CLI apps to use them on your system.<p.new.line><p>Working with Dart on CLI applications is really amazing. The pace at which it’s evolving is astonishing to me. I’ve never grown so fond of a language that makes building CLI tools so easy. There are a lot of interesting things that you can do with Dart right now. You can learn more about them<a href="https://dart.dev/tutorials/server/get-started#6-compile-for-production" target="_blank" rel="noopener noreferrer"> here</a>.<p.new.line><p>Going forward in this series, we’ll explore building casual/utility CLI apps with Dart and maybe some CLI games! 👀 Who knows? 🤫<p.new.line><p>Make sure you subscribe to the blog to get updated when the next article drops for this series. 💙 Have an amazing day
Are you ready to take your software development skills to the next level? Then, it's time to dive into the world of Command Line Interface (CLI) tools with dart CLI. These tools run directly in the terminal, the familiar space for developers, and can streamline your workflow with their minimal interface and quick access.
In this series of articles, we will be exploring Dart CLI apps and how to build them. You'll learn about the structure of Dart CLI projects, handling arguments, working with input/output, reading and writing to files, and finally, compiling and installing your Dart CLI apps. Embrace the full power of the terminal and join us on this exciting journey to build CLI apps in Dart.
## Getting Started 
 <a href="https://dart.dev/get-dart">Install the Dart SDK</a> to get started. We will be using <a href="https://marketplace.visualstudio.com/items?itemName=MeshIntelligentTechnologiesInc.pieces-vscode">Visual Studio Code</a> as the development environment for our Command Line Interface (CLI) application. However, the choice of Integrated Development Environment (IDE) is not crucial and you can work with any IDE that you prefer, without affecting the learning outcome.
To create a new Dart CLI project, run the following dart command:
e>dart create dart_cli -t console</pre><p>This will create a Dart CLI project in the respective directory.
You can run your Dart CLI application with the following dart command:
e>dart run bin/dart_cli.dart</pre><p>Here, ```-t``` defines the template for the Dart project. <a href="https://dart.dev/tools/dart-create">Dart has several templates</a> you can use to work on CLI, web or server-side projects.
<a href="https://takrutvik.pieces.cloud/?p=0b324f8f6b" target="_blank" rel="noopener noreferrer">Save the above commands</a>
## Understanding Project Structure with Dart CLI
Three of the most important things in our project structure are the <a href="https://dart.dev/tools/pub/package-layout#public-directories" target="_blank" rel="noopener noreferrer"><strong>bin</strong> and <strong>lib</strong></a> directories along with the <strong>pubspec.yaml</strong> file.
- <strong>bin:</strong> This is a public directory that is the entry point for your Dart CLI application. This includes the executable Dart file that the CLI app will run.
- <strong>lib: </strong>Lib includes the public libraries that your application uses. Like Dart methods, classes or any other code, this is imported into the bin directory.
- <a href="https://dart.dev/tools/pub/pubspec"><strong>pubspec.yaml</strong>:</a> The Dart CLI app is a package in itself. This file contains the package/CLI app information like name, app version, any dependencies your app is using, etc. It also includes the entry point for your CLI application defined by the executables. This usually directs to the executable in the bin folder. Whenever you’ll be using your CLI app, you’ll be running this executable. 
### Arguments in Dart CLI
Within the ```bin/dart_cli.dart``` file, you’ll see that the main function accepts a list of strings called <strong>arguments</strong>. These are inputs provided to CLI applications that you can use to know what to do.
Arguments are broken down into the following major types relevant to this tutorial:
- <strong>Command:</strong> The command you wish to run to execute a particular task.
- <strong>Flags:</strong> Flags hold a boolean value. They can be used to turn on/off some flows within your program.
- <strong>Options</strong>: Options are <strong>key-value pairs</strong> that you can define. You can also define options that accept a value from an allowed list of values, thus restricting the input that a user can provide for the option.
For example, take a look at the following command, which creates the Dart project with some additional arguments added:
e>$ dart create dart_cli -t console --force --[no-]pub</pre><p><a href="https://takrutvik.pieces.cloud/?p=08f342bb7e" target="_blank" rel="noopener noreferrer">Save this code</a>
- <strong>create:</strong> The command you want to execute.
- <strong>dart_cli:</strong> This is an argument for the earlier command which defines the name for the project. This is not predefined, so if there are any such arguments that a command would be accepting, then it should know about it.
- <strong>-t:</strong> An option where the ```t``` is the abbreviation used for the ```template``` for the project. You can also provide options like ```follow```, ```-t console``` or ```--template=&quot;console&quot;```.
- <strong>console</strong>: This is the value for the option earlier.
- —<strong>force:</strong> This is a flag and is used to force the creation of a project even if the target directory already exists. You can also turn on certain flags by using the flags abbreviations (if any) provided for them, e.g., ```-f```. Both of these methods will turn the respective flag on.
- —<strong>no-pub</strong>: By default, Dart create will run ```pub get```, which will fetch the dependencies within your <strong>pubspec.yaml.</strong> The prefix <strong>no</strong> is used to set the flag’s value to false.
### Parsing Arguments in Dart CLI
You’ll see that within our main method, the arguments are provided as a list of strings. Working with them this way would be inefficient and unmanageable. Therefore, what we’ll do is parse the list of arguments into something that’s more approachable and friendlier to use.
We’ll be using the <strong>args</strong> package, which helps us define parsers for the raw command line arguments. You can add it to your project by running the following command:
e>$ dart pub add args</pre><p><a href="https://takrutvik.pieces.cloud/?p=13a74a8cee" target="_blank" rel="noopener noreferrer">Save this code</a>
This will add the <strong>args</strong> dependency in your <strong>pubspec</strong> file. We used the Darts<a href="https://dart.dev/tools/pub/cmd" target="_blank" rel="noopener noreferrer"> package manager <strong>pub</strong></a> to add this dependency.
Now, take a look at the code below:
e>void main(List&lt;String&gt; arguments) async {<br><br> final ArgParser parser = ArgParser()<br>    ..addCommand(&quot;create&quot;)   <br>  ..addOption(<br>    &quot;template&quot;,<br>    defaultsTo:   &quot;t&quot;,<br>   // If allowed is non-null, then input will be restricted to the values<br>   // provided in allowed list.<br>      allowed:   [<br>        &quot;console&quot;,<br>        &quot;package&quot;<br>        &quot;web&quot;,<br>        &quot;server-shelf&quot;,<br>       ],<br>     )<br>     ..addFlag(&quot;force&quot;,   abbr:   &quot;f&quot;);<br> <br> final ArgResults argResults = parser.parse(arguments);<br><br> final command = argResults.command!.name!;   <br> // gets the command entered<br><br> final isForced = argResults[&quot;force&quot;] as bool;<br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=d3b0499bd4" target="_blank" rel="noopener noreferrer">Save this code</a>
There are two important pieces of information here, the ```ArgParser``` and the ```ArgResults```:
- <strong>ArgParser:</strong> ```ArgParser``` can be used to define parsers to parse the arguments. You can then add to the parser the commands, flags and options that you expect to use in your CLI application.
- <strong>ArgResults:</strong> Once you’ve created your parser, you can parse the raw ```arguments``` and it’ll return the ```ArgResults``` object, which will map the raw values from the ```arguments``` list to the defined commands, flags and options. This makes it easier to use the arguments from input through a concrete class. You can also treat it like a ```map``` to find different values as we did above to get values for the ```force``` flag.
### I/O
The<a href="https://dart.dev/articles/libraries/dart-io" target="_blank" rel="noopener noreferrer"> dart:io</a> library provides us with different streams through which we can manage input/output events. Let’s take a look at them below.
The ```stdout``` from dart:io provides the standard output stream. This stream can be used to log outputs to the terminal, like below:
e>stdout.writeln(&quot;Hello World!&quot;);</pre><p><a href="https://takrutvik.pieces.cloud/?p=391944bc1f" target="_blank" rel="noopener noreferrer">Save this code</a>
This will output ```&quot;Hello World&quot;``` and is a non-blocking operation. This means any other i/o operations will not be blocked from executing while this is running.
The ```stdin``` provides the standard input stream, which we can read/listen to get the input from the terminal, like the following:
e>final input = stdin.readLineSync();<br><br>stdout.writeln(input);</pre><p><a href="https://takrutvik.pieces.cloud/?p=85b64c8d78" target="_blank" rel="noopener noreferrer">Save this code</a>
Here, ```readLineSync()``` listens to the input from the standard stream. This is a blocking operation, and until input is received and the user presses return, other i/o events are blocked.
![](43afec68f555387049efb3/635ab3e8bd64ae625f663586_input_demo_983b9a71f3f6da6446887a2a966e666e.g)
Alternatively, if you want a non-blocking input read, then you can use the ```.pipe()``` method:
e>final input = await stdin.pipe(stdout);</pre><p><a href="https://takrutvik.pieces.cloud/?p=38234c9a80" target="_blank" rel="noopener noreferrer">Save this code</a>
This method is <strong>non-blocking</strong> and <strong>async</strong>. It takes in another stream consumer like ```stdout```, which consumes the events from the ```stdin``` stream without blocking the ```output``` stream.
It’s not uncommon to come across errors in your applications and catch them, or to explicitly throw errors if things don’t add up.
The dart:io library also provides a standard error stream that logs the errors to the console:
e>stderr.writeln(&quot;Ooops! Something's not right!&quot;)</pre><p><a href="https://takrutvik.pieces.cloud/?p=50d64f936a" target="_blank" rel="noopener noreferrer">Save this code</a>
This will log out the given error. Also, this operation is non-blocking.
Your application may throw exceptions at runtime. You should handle these exceptions when they occur, and provide the proper message to the user to tell them what went wrong. Exceptions can be easily caught with a ```try/catch``` block.
e>void main(List&lt;String&gt; arguments) {<br><br> try {<br>  // This will throw an exception as abbr can be either null or character of length 1.<br> final ArgParser parser = ArgParser()..addFlag(&quot;save&quot;, abbr: &quot;save&quot;);<br>      } on ArgParserException catch (e) {<br>  stdout.writeln(&quot;Failed while parsing arguments&quot;);<br>      studout.writeln(e.message);<br>      exit(1);<br>    } catch (e) {<br>  stdout.writeln(&quot;Something went wrong&quot;);<br>  studout.writeln(e.message);<br>          exit(1);<br>}<br><br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=c83548a027" target="_blank" rel="noopener noreferrer">Save this code</a>
Here, we used a ```try/catch``` block to catch any exceptions that might be thrown during the parsing of ```arguments```. Also, we are defining a ```catch``` block that will only catch the exceptions of type ```ArgParserException```. This makes it easier to work with different types of exceptions individually and provide outputs that are more helpful for those kinds of exceptions.
The last catch block will catch all other exceptions aside from the ```ArgParserException``` type, and provide a general message with the error thrown to the user.
## <strong>Dart CLI Exit Codes</strong>
Exit codes are a small number that shows the success, failure or any other state of the program to the system that called it. Within Dart, there are pre-defined exit codes appropriate for certain conditions.
Generally, exit codes like ```0``` mean ```success```, ```1``` mean ```warning``` and ```2``` mean an ```error``` has occurred. See more Dart exit codes here:<a href="https://dart.dev/tutorials/server/cmdline#setting-exit-codes" target="_blank" rel="noopener noreferrer"> src</a>.
The dart:io library defines a top-level property called ```exitCode```, which you can change to set the exit code for the running program:
e>void readFile(String path) {<br> try {<br>  final file = File(path);<br>  file.readAsLines();<br> } on FileSystemException catch (e) {<br>   exitCode = 2;<br> }<br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=20364f8430" target="_blank" rel="noopener noreferrer">Save this code</a>
Setting up a new ```exitCode``` doesn’t terminate the program. The program will continue to execute until it’s complete or an error occurs.
Along with the ```exitCode```, there is also a top-level method ```exit(exit_code)```, which sets the ```exitCode``` to the given code and terminates the program immediately.
## Reading/Writing to Files 
As with any other type of application, when working with a CLI, you may need to access files on a user's system for either reading or writing purposes. The dart:io library provides ways to access files on the system. Here’s how you can do that:
### Reading a File
e>final notesFile = File(&quot;./bin/notes.txt&quot;);<br><br>final notes = notesFile.readAsLinesSync();<br><br>for (String note in notes) {<br>       stdout.writeln(note);<br>   }</pre><p><a href="https://takrutvik.pieces.cloud/?p=14544997ee" target="_blank" rel="noopener noreferrer">Save this code</a>
The ```File``` object is part of dart:io and has utility methods that you can use for reading/writing to a file at the given path.
Here, you’re reading from a file named <strong>notes.txt</strong> within the <strong>bin</strong> folder, as shown below:
e>Learn Dart on CLI.🙌<br>Practice what I learned.🧑🏽‍💻<br>Build something cool with it.🔥</pre><p><a href="https://takrutvik.pieces.cloud/?p=66cf41bb79" target="_blank" rel="noopener noreferrer">Save this code</a>
The file is read as lines, and then you log each line to the output.
Output:
e>$ dart run bin/dart_cli.dart<br><br>Learn Dart on CLI.🙌<br>Practice what I learned.🧑🏽‍💻<br>Build something cool with it.🔥</pre><p><a href="https://takrutvik.pieces.cloud/?p=dc774d970f" target="_blank" rel="noopener noreferrer">Save this code</a>
### Writing to a File
e>final newNotes = [<br> &quot;Having fun learning Dart on CLI!🤩&quot;,<br> &quot;Dart makes it so easy to write cli apps.👍🏽&quot;,<br> &quot;Can't wait to build something cool with it!💙&quot;,<br>      ];<br><br> final notesFile = File(&quot;./bin/notes.txt&quot;);<br><br> final notesString = newNotes.join(&quot;\\n&quot;);<br><br>      notesFile.writeAsStringSync(<br>          notesString,<br>// FileMode.append will add the new content at the end of the file.<br>            mode: FileMode.append,<br>//   FileMode.write will override the existing file content with the new content.<br> // mode: FileMode.write,<br>    );</pre><p><a href="https://takrutvik.pieces.cloud/?p=1e624bad9a" target="_blank" rel="noopener noreferrer">Save this code</a>
You can see that here we have defined some new notes. We are writing them to a notes file by using ```.writeAsStringSync```. Before writing to the file, we joined the existing notes with ```\\\\n``` line delimiters because each note will be written on a new line.
Next, set the ```FileMode.append```, which will add the new content to the end of the file. You can set it to ```.write``` if you want to override the existing content of the file.
```File``` has many other utility methods that you may find useful. Some of the most common ones are shown below:
e>// Creates the file at the path the File object was initialized with.<br>    file.create();<br><br> // Checks if the file exists.<br>    file.exists();<br><br> // Deletes the file.<br>    file.delete();<br><br> // Listens to changes on file.<br>    file.watch().listen((event) {<br> // File changed. Do something.<br>   });</pre><p><a href="https://takrutvik.pieces.cloud/?p=278b46bb5e" target="_blank" rel="noopener noreferrer">Save this code</a>
## Styling Your Application
Oftentimes, CLI applications can have a less appealing visual experience as coloring the output text, adding a colorful background to text and changing how users can interact with the app is challenging. This is definitely not an easy task; there are a lot of factors that go into getting this right.
Next, we’ll take a look at a logger package that makes it easier for us to style our CLI.
### Adding Mason Logger
We can use<a href="https://pub.dev/packages/mason_logger" target="_blank" rel="noopener noreferrer"> Mason logger</a> to log stylized and more interactive outputs to the terminal.
To use it, add it as a dependency in your <strong>pubspec.yaml</strong>, or just run the following command that will add it for you:<a href="https://takrutvik.pieces.cloud/?p=7d2e498b49"> </a>
e>$ dart pub add mason_logger</pre><p><a href="https://takrutvik.pieces.cloud/?p=7d2e498b49" target="_blank" rel="noopener noreferrer">Save this code</a>
Mason provides us with a range of different output levels like info, warning, error, success, etc. It also allows us to add a background color to text, as in the example below.
e>import 'package:mason_logger/mason_logger.dart';<br><br>void main(List&lt;String&gt; arguments) async {<br> final logger = Logger();<br><br>    logger.info('\\nThis is an info.🔵\\n');<br>    logger.warn('\\nThis is a warning.🌕');<br>    logger.err('\\nThis is an error.🔴');<br>    logger.success('\\nThis is success!🟢');<br><br>    logger.success(<br>          backgroundBlue.wrap(&quot;\\nLook! A text with colored background!🥳&quot;),<br>    );<br>}</pre><p><a href="https://takrutvik.pieces.cloud/?p=d29d4cbad1" target="_blank" rel="noopener noreferrer">Save this code</a>
Output:
![](/6143afec68f555387049efb3/635ab3e8bd64ae4cb5663587_output_b1d7215a553f6793cc3bd89dd7444bf2_800.p)
Mason can not only help with styling output, but also with implementing more common types of interactive outputs with rich experiences like below:
e>import 'package:mason_logger/mason_logger.dart';<br><br>void main(List&lt;String&gt; arguments) async {<br> final logger = Logger();<br> <br> // Confirmation message<br> final isConfirmed =<br>                logger.confirm(&quot;This is a confirmation messsage with yes and no option.&quot;);<br><br> if (isConfirmed) {<br> // User permitted the action.<br>   }<br><br> // Single choice selection<br> final selectedChoice = logger.chooseOne(&quot;Options picker&quot;, choices: [<br> &quot;Choice1&quot;,<br> &quot;Choice2&quot;,<br> &quot;Choice3&quot;,<br>      ]);<br><br> logger.info(&quot;Selected Choice--&gt;$selectedChoice&quot;);<br><br> // Multiple choice selection<br> final selectedListOfChoices = logger.chooseAny(&quot;Options picker&quot;, choices: [<br> &quot;Choice1&quot;,<br> &quot;Choice2&quot;,<br> &quot;Choice3&quot;,<br> &quot;Choice4&quot;,<br> &quot;Choice5&quot;,<br>  ]);</pre><p><a href="https://takrutvik.pieces.cloud/?p=543c4f9f53" target="_blank" rel="noopener noreferrer">Save this code</a>
Output:
![](picker in the terminal. " src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/635ab3e8bd64ae74f9663588_output2_17116c26be794acf2becc3bf0e25e9ac.g)
## Compiling
Once you’re done with your app, it’s time to compile it so you can distribute it to stores, or anywhere else you like.
While in the dev process, the application runs on top of Dart VM, which is optimized for faster performance and execution times.
For production, you can use the Dart compiler. This offers AOT compilation to compile the program to native machine code:
e>$   dart compile exe bin/dart_cli.dart</pre><p><a href="https://takrutvik.pieces.cloud/?p=ef7b47a777" target="_blank" rel="noopener noreferrer">Save this code</a>
This will generate the application executable in your <strong>bin</strong> folder.
You can run the executable like so:
e>$ ./bin/dart_cli.exe</pre><p><a href="https://takrutvik.pieces.cloud/?p=593a4db4c7" target="_blank" rel="noopener noreferrer">Save this code</a>
Another interesting fact about the executables is that they can be run without installing Dart SDK on the system they’re running on. This is because the executables are self-contained with everything needed to run properly.
## Installing Dart CLI
Besides building the executable, you can also directly install the CLI app through <strong>pub.</strong> However, before this step, make sure you’ve mentioned the<a href="https://dart.dev/tools/pub/pubspec#executables" target="_blank" rel="noopener noreferrer"> executables</a> in your <strong>pubspec.yaml,</strong> which you’ll want to activate:
e>..<br>...<br>executables:<br>    dart_cli: dart_cli # value can be left empty and is inferred from the key<br>    other_executable: todo_cli<br>..<br>...</pre><p><a href="https://takrutvik.pieces.cloud/?p=f2ee479a8d" target="_blank" rel="noopener noreferrer">Save this code</a>
To add the executable, you’ll need to provide a <strong>key-value</strong> pair. If the ```value``` is not provided, then it’s inferred from the ```key```.
Then, run the following command to activate values globally:
e>$ dart pub global activate --source path &lt;project_path&gt;</pre><p><a href="https://takrutvik.pieces.cloud/?p=31ec45a850" target="_blank" rel="noopener noreferrer">Save this code</a>
Next, provide the path of the project. If you’re in the project’s directory, provide the ```project_path``` as ```.``` .
This will globally activate the CLI application by installing the executable on your system.
You can run the application from anywhere on your system like so:
e>$ dart_cli &lt;command&gt;</pre><p><a href="https://takrutvik.pieces.cloud/?p=315f4da0b2" target="_blank" rel="noopener noreferrer">Save this code</a>
## Summary on Dart CLI
So, you took a leap of faith in learning to build CLI apps with Dart. You learned the basics of i/o, working with files, HTTP requests and more in Dart. Along with this, you also looked into how to compile and install CLI apps to use them on your system.
Working with Dart on CLI applications is really amazing. The pace at which it’s evolving is astonishing to me. I’ve never grown so fond of a language that makes building CLI tools so easy. There are a lot of interesting things that you can do with Dart right now. You can learn more about them<a href="https://dart.dev/tutorials/server/get-started#6-compile-for-production" target="_blank" rel="noopener noreferrer"> here</a>.
Going forward in this series, we’ll explore building casual/utility CLI apps with Dart and maybe some CLI games! 👀 Who knows? 🤫
