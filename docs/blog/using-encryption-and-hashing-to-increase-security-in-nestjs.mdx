![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd5f5347af2e3268a85d53_encryptionandhashing_b2ea24b26d10645800dcbd6521965990_2000.jpeg)
"cybersecurity"
# Using Encryption and Hashing to Increase Security in NestJS
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<p>Data stored on the web is prone to attacks. To guarantee the integrity of users' data in an online application, you'll need to adopt a secure method for handling and storing your users' data. There are many approaches to this, such as encoding the user's information to allow only authorized users access. This is where encryption and hashing come into play.<p.new.line><h2 id="bavgl">What Is NestJS?<h2.new.line><p><a href="https://nestjs.com/">NestJS</a> is a Node.js framework for developing TypeScript-based server-side applications that are fast, testable, scalable, and loosely coupled. It makes use of powerful HTTP server frameworks like Express and Fastify. Nest abstracts Node.js frameworks and makes their APIs available to developers.<p.new.line><p>The NestJS framework is compatible with database management systems such as PostgreSQL and MySQL. It provides dependency injections, Websockets, and APIGetaways as well.<p.new.line><h2 id="9b43f">What Are Data Encryption and Hashing?<h2.new.line><p>Data encryption encodes information by converting its original representation, plaintext, into an alternate form known as cipher text. With cipher text, only authorized users can access and decrypt the original data. Data encryption prevents interception while denying potential interceptors intelligible content. Encryption is a two-way function, meaning encrypted information can only be decrypted with the correct key.<p.new.line><p>Hashing, however, converts a given key into another value that generates a new value using a mathematical algorithm. It should be impossible to go from the output to the input once hashing is complete.<p.new.line><h3 id="ffdi4">Prerequisites<h3.new.line><p>This tutorial is a hands-on demonstration. To follow along, ensure you have the following installed:<p.new.line><ul><li>Node.js version 14 or later<li.new.line><li>MongoDB database<li.new.line><ul.new.line><h2 id="c48or">Project Setup<h2.new.line><p>With the above requirements met, let’s install the NestJS CLI tool by running the command below:<p.new.line><pre>npm install -g nest/cli</pre><p>Once the installation is completed, create a new NestJS project by running this command:<p.new.line><pre>nest new encryption</pre><p>The above command will prompt you to choose your preferred npm package manager. For this tutorial, we'll use ```npm``` and wait for the necessary packages to be installed.<p.new.line><h3 id="q1m2">Install Dependencies<h3.new.line><p>We’ll use the default <a href="https://nodejs.org/api/crypto.html" target="_blank" rel="noopener noreferrer">crypto module</a> provided by Node.js to handle our data encryption. For data hashing, we’ll use the <a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="noopener noreferrer">bcrypt </a>NodeJS third-party module. To install the ```bcrypt``` module, run the command below:<p.new.line><pre>npm i -D @types/bcrypt<br>npm i bcrypt</pre><p>Wait for the installation to complete and then connect the application to a MongoDB database.<p.new.line><h3 id="abm4c">Connect a Database<h3.new.line><p>To demonstrate how to store secret data in a database securely, we’ll connect the application to a MongoDB database. To do that, we need to install the Mongoose module with the command below:<p.new.line><pre>npm i @nestjs/mongoose mongoose</pre><p>Next, let’s update the code in the ```app.module.ts``` file with the code snippet below:<p.new.line><pre>import { Module } from '@nestjs/common';<br>import { AppController } from './app.controller';<br>import { AppService } from './app.service';<br>import { MongooseModule } from '@nestjs/mongoose';<br><br>@Module({<br>  imports: [<br>    MongooseModule.forRoot('mongodb://localhost/nest'),<br>  ],<br>  controllers: [AppController],<br>  providers: [AppService],<br>})<br>export class AppModule {}</pre><p>In the above code snippet, we imported the ```MongooseModule```, which allows us to connect to the database using the ```forRoot``` method. The ```forRoot()```<strong> </strong>method takes in the connection URI similar to the ```mongoose.connect()```<strong> </strong>method.<p.new.line><h3 id="dtvol">Create a Model<h3.new.line><p>Now, let’s define the schema to create a model for our database. To get started, create a ```model```<strong> </strong>folder in the ```src``` directory. Then create a ```users.ts``` file and define a User Schema class with the code snippet below:<p.new.line><pre>import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';<br>import { Document } from 'mongoose';<br><br>export type UserDocument = User &amp; Document;<br><br>@Schema()<br>export class User {<br>  @Prop()<br>  name: string;<br><br>  @Prop()<br>  email: string;<br><br>  @Prop()<br>  password: string;<br>}<br><br>export const UserSchema = SchemaFactory.createForClass(User);</pre><p>In the code snippet above, we imported the following: the ```Prop``` decorator to define the properties of the schema, the ```Schema``` decorator, which will map our ```User``` class to a MongoDB collection, and the ```SchemaFactory```<strong> </strong>decorator to compile the schema and prepare the schema for validation.<p.new.line><p>Next, we need to register the schema in our root ```app.module.ts``` file to allow our application to use it.<p.new.line><pre>...<br><br>@Module({<br>  imports: [<br>    ...<br>    MongooseModule.forFeature([{ name: 'user', schema: UserSchema }]),<br>  ],<br>   ...<br>})<br>export class AppModule {}</pre><p>In the above code, we used the ```MongoseModule.forFeature()``` method to configure the module, specifying the models we want to register for the current scope.<p.new.line><h3 id="ufnh">Implement Data Hashing<h3.new.line><p>With our database model created, let's look at the actual hash implementation. First, we'll create a signup API to allow users to sign up with their name, email, and password. Then we'll hash the user's password before saving it to our database. This way, even if a hacker gains access to the records in our database, they won't be able to access our user accounts because they will only see the hashed version of the password.<p.new.line><p>Let’s go ahead and see the implementation. In the ```app.service.ts```<strong> </strong>file, update the code with the snippets below:<p.new.line><pre>import { Injectable } from '@nestjs/common';<br>import { Model } from 'mongoose';<br>import { InjectModel } from '@nestjs/mongoose';<br>import { User, UserDocument } from './models/users';<br>import * as bcrypt from 'bcrypt';<br><br>@Injectable()<br>export class AppService {<br>  constructor(@InjectModel('user') private userModel: Model&lt;UserDocument&gt;) {}<br>  async createUser(user: User): Promise&lt;User&gt; {<br>    const salt = await bcrypt.genSalt();<br>    const hashPassword = await bcrypt.hash(user.password, salt);<br>    user.password = hashPassword;<br>    const newUser = new this.userModel(user);<br>    return newUser.save();<br>  }<br>  }</pre><p>In the above code snippet, we imported the ```bcrypt``` module, the ```User``` class, and the ```UserDocumet``` type. Then, we created a createUser method in which we created a ```salt``` to generate random text for our password hash. Then, we hashed the user’s password using the ```bcrypt.hash()``` function, which takes in the user's password and salt value. Finally, we modified the user object to change the password value to the hashed password and save it to the database.<p.new.line><p>Now, we’ll create another method to check if the password a user enters is the same as the plain-text equivalent of the hashed password. To do this, let’s add the method below to the AppService class:<p.new.line><pre>...<br>async loginUser(email: string, password: string): Promise&lt;string&gt; {<br>    const user = await this.userModel.findOne({ email });<br>    if (user) {<br>      const match = await bcrypt.compare(password, user.password);<br>      if (match) return 'Credentials are correct!';<br>      return 'Invalid Credentials!';<br>    }<br>    return 'Invalid Invalid!';<br>  }<br>…</pre><p>In the above code snippet, we used the ```userModel.findOne()``` method to check if the email provided by the user exists in our database. Then, we used ```bcrypt.compare()``` to compare the plain password supplied with the database's hashed version of the password. Here, you can decide to grant a user access to services in your application if the credentials provided are correct.<p.new.line><h3 id="1bsk5">Implement Data Encryption<h3.new.line><p>We’ve seen how to increase the security of our application by hashing the sensitive data in a user’s record. Now, let’s look at how we can secure user data with encryption. Let's say we’re building a chatting or social networking application where many users' secrets (confidential to them and the person they’re communicating with) are shared online. If such data is not encrypted, hackers can gain unauthorized access to the user's private information.<p.new.line><p>Let’s get started implementing data encryption in our application. First, create a ```utils```<strong> </strong>folder in the<strong> </strong>```src```<strong> </strong>directory. In the ```utils```<strong> </strong>folder, create an ```encrypt.ts``` file and add the code snippets below:<p.new.line><pre>import {<br>  createCipheriv,<br>  randomBytes,<br>  createDecipheriv,<br>  createHash,<br>} from 'crypto';<br><br>const alg = 'aes-256-ctr';<br>let key = 'The Encryption Key';<br>key = createHash('sha256').update(String(key)).digest('base64').substr(0, 32);<br><br>export const encryptData = (data) =&gt; {<br>  const iv = randomBytes(16);<br>  const cipher = createCipheriv(alg, key, iv);<br>  const result = Buffer.concat([iv, cipher.update(data), cipher.final()]);<br>  return result;<br>};</pre><p>We imported all the functions we needed from the crypto module in the above code snippet. We’re using the AES (Advanced Encryption System) algorithm because it’s easy to implement. You can use any algorithm of your choosing. In our code, we created an initializer vector and built a new cipher using the algorithm, key, and iv with the ```createCipher()``` method. Finally, we made an encrypted buffer from the data supplied.<p.new.line><p>Now, let’s create another function to decrypt the data when an authorized user wants to access it. To do this, we’ll use the code snippet below:<p.new.line><pre>export const decryptData = (data) =&gt; {<br>  const iv = data.slice(0, 16);<br>  data = data.slice(16);<br>  const decipher = createDecipheriv(algorithm, key, iv);<br>  const result = Buffer.concat([decipher.update(data), decipher.final()]);<br>  return result;<br>};</pre><p>In the above code snippet, we used the ```slice()``` method to get the first 16 bytes of the encrypted buffer and then the rest of the data. We also modified the value. Then, we created a decipher and decrypted the encrypted buffer.<p.new.line><p>Now, open the ```app.service.ts``` file, and create another method to encrypt and decrypt users' messages with the code snippet below:<p.new.line><pre>...<br>import { encryptData, decryptData } from './utils/encrypt-file';<br><br>...<br>async sendMessage(message: string): Promise&lt;object&gt; {<br>  const encryptedMessage = encrypt(message);<br>  const decrytedMessage = decrypt(encryptedMessage);<br>  return {<br>    'Encryted Message': encryptedMessage.toString(),<br>    'Decryted Message': decrytedMessage.toString(),<br>  };<br>}<br>...</pre><p>In the above code snippet, we imported the ```encryptData``` and ```decryptData```<strong> </strong>functions we created. Then we encrypted and decrypted the user-provided message and returned both versions of the message. This was done to show what the encrypted message looks like. However, you can proceed and save the encrypted data in your database.<p.new.line><p>Finally, create the route controllers for the AppService class methods in the ```app.controller.ts``` file with the code snippet below:<p.new.line><pre>import { Controller, Get, Post, Body, Param } from '@nestjs/common';<br>import { AppService } from './app.service';<br>import { User } from './models/users';<br>@Controller()<br>export class AppController {<br> constructor(private readonly appService: AppService) {}<br> @Post('create')<br> async createUser(@Body() user: User): Promise&lt;User&gt; {<br>  return await this.appService.createUser(user);<br>}<br>@Post('/login')<br>async getMessage(@Body() user: User): Promise&lt;any&gt; {<br>  const { email, password } = user;<br>  return this.appService.loginUser(email, password);<br>}<br>@Post('message')<br>async sendMessage(@Body() user) {<br>  const { message } = user;<br>  return await this.appService.sendMessage(message);<br> }<br>}</pre><h3 id="b85gg">Test Application<h3.new.line><p>Now, start the application by running the command below:<p.new.line><pre>Npm run start:dev</pre><p>Then, use any API testing tool like Postman or Insomnia to test the application at <a href="http://localhost:3000/" target="_blank" rel="noopener noreferrer">http://localhost:3000</a>.<p.new.line><h2 id="cek5g">Conclusion<h2.new.line><p>This tutorial demonstrated how to increase the security of a NestJS application with encryption and hashing. Now, you should have an understanding of what encryption, hashing, and NestJS are. You also learned how to create a NestJS allocation, connect to a database, create a model, service, and controller, and implement data encryption and hashing. Now that you have this knowledge, how would you increase the security of your next project? Perhaps you can check out the NestJS official <a href="https://docs.nestjs.com/" target="_blank" rel="noopener noreferrer">documentation</a> to learn more.<p.new.line>\n\n    <figu
Data stored on the web is prone to attacks. To guarantee the integrity of users' data in an online application, you'll need to adopt a secure method for handling and storing your users' data. There are many approaches to this, such as encoding the user's information to allow only authorized users access. This is where encryption and hashing come into play.
## What Is NestJS?
<a href="https://nestjs.com/">NestJS</a> is a Node.js framework for developing TypeScript-based server-side applications that are fast, testable, scalable, and loosely coupled. It makes use of powerful HTTP server frameworks like Express and Fastify. Nest abstracts Node.js frameworks and makes their APIs available to developers.
The NestJS framework is compatible with database management systems such as PostgreSQL and MySQL. It provides dependency injections, Websockets, and APIGetaways as well.
## What Are Data Encryption and Hashing?
Data encryption encodes information by converting its original representation, plaintext, into an alternate form known as cipher text. With cipher text, only authorized users can access and decrypt the original data. Data encryption prevents interception while denying potential interceptors intelligible content. Encryption is a two-way function, meaning encrypted information can only be decrypted with the correct key.
Hashing, however, converts a given key into another value that generates a new value using a mathematical algorithm. It should be impossible to go from the output to the input once hashing is complete.
### Prerequisites
This tutorial is a hands-on demonstration. To follow along, ensure you have the following installed:
- Node.js version 14 or later
- MongoDB database
## Project Setup
With the above requirements met, let’s install the NestJS CLI tool by running the command below:
e>npm install -g nest/cli</pre><p>Once the installation is completed, create a new NestJS project by running this command:
e>nest new encryption</pre><p>The above command will prompt you to choose your preferred npm package manager. For this tutorial, we'll use ```npm``` and wait for the necessary packages to be installed.
### Install Dependencies
We’ll use the default <a href="https://nodejs.org/api/crypto.html" target="_blank" rel="noopener noreferrer">crypto module</a> provided by Node.js to handle our data encryption. For data hashing, we’ll use the <a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="noopener noreferrer">bcrypt </a>NodeJS third-party module. To install the ```bcrypt``` module, run the command below:
e>npm i -D @types/bcrypt<br>npm i bcrypt</pre><p>Wait for the installation to complete and then connect the application to a MongoDB database.
### Connect a Database
To demonstrate how to store secret data in a database securely, we’ll connect the application to a MongoDB database. To do that, we need to install the Mongoose module with the command below:
e>npm i @nestjs/mongoose mongoose</pre><p>Next, let’s update the code in the ```app.module.ts``` file with the code snippet below:
e>import { Module } from '@nestjs/common';<br>import { AppController } from './app.controller';<br>import { AppService } from './app.service';<br>import { MongooseModule } from '@nestjs/mongoose';<br><br>@Module({<br>  imports: [<br>    MongooseModule.forRoot('mongodb://localhost/nest'),<br>  ],<br>  controllers: [AppController],<br>  providers: [AppService],<br>})<br>export class AppModule {}</pre><p>In the above code snippet, we imported the ```MongooseModule```, which allows us to connect to the database using the ```forRoot``` method. The ```forRoot()```<strong> </strong>method takes in the connection URI similar to the ```mongoose.connect()```<strong> </strong>method.
### Create a Model
Now, let’s define the schema to create a model for our database. To get started, create a ```model```<strong> </strong>folder in the ```src``` directory. Then create a ```users.ts``` file and define a User Schema class with the code snippet below:
e>import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';<br>import { Document } from 'mongoose';<br><br>export type UserDocument = User &amp; Document;<br><br>@Schema()<br>export class User {<br>  @Prop()<br>  name: string;<br><br>  @Prop()<br>  email: string;<br><br>  @Prop()<br>  password: string;<br>}<br><br>export const UserSchema = SchemaFactory.createForClass(User);</pre><p>In the code snippet above, we imported the following: the ```Prop``` decorator to define the properties of the schema, the ```Schema``` decorator, which will map our ```User``` class to a MongoDB collection, and the ```SchemaFactory```<strong> </strong>decorator to compile the schema and prepare the schema for validation.
Next, we need to register the schema in our root ```app.module.ts``` file to allow our application to use it.
e>...<br><br>@Module({<br>  imports: [<br>    ...<br>    MongooseModule.forFeature([{ name: 'user', schema: UserSchema }]),<br>  ],<br>   ...<br>})<br>export class AppModule {}</pre><p>In the above code, we used the ```MongoseModule.forFeature()``` method to configure the module, specifying the models we want to register for the current scope.
### Implement Data Hashing
With our database model created, let's look at the actual hash implementation. First, we'll create a signup API to allow users to sign up with their name, email, and password. Then we'll hash the user's password before saving it to our database. This way, even if a hacker gains access to the records in our database, they won't be able to access our user accounts because they will only see the hashed version of the password.
Let’s go ahead and see the implementation. In the ```app.service.ts```<strong> </strong>file, update the code with the snippets below:
e>import { Injectable } from '@nestjs/common';<br>import { Model } from 'mongoose';<br>import { InjectModel } from '@nestjs/mongoose';<br>import { User, UserDocument } from './models/users';<br>import * as bcrypt from 'bcrypt';<br><br>@Injectable()<br>export class AppService {<br>  constructor(@InjectModel('user') private userModel: Model&lt;UserDocument&gt;) {}<br>  async createUser(user: User): Promise&lt;User&gt; {<br>    const salt = await bcrypt.genSalt();<br>    const hashPassword = await bcrypt.hash(user.password, salt);<br>    user.password = hashPassword;<br>    const newUser = new this.userModel(user);<br>    return newUser.save();<br>  }<br>  }</pre><p>In the above code snippet, we imported the ```bcrypt``` module, the ```User``` class, and the ```UserDocumet``` type. Then, we created a createUser method in which we created a ```salt``` to generate random text for our password hash. Then, we hashed the user’s password using the ```bcrypt.hash()``` function, which takes in the user's password and salt value. Finally, we modified the user object to change the password value to the hashed password and save it to the database.
Now, we’ll create another method to check if the password a user enters is the same as the plain-text equivalent of the hashed password. To do this, let’s add the method below to the AppService class:
e>...<br>async loginUser(email: string, password: string): Promise&lt;string&gt; {<br>    const user = await this.userModel.findOne({ email });<br>    if (user) {<br>      const match = await bcrypt.compare(password, user.password);<br>      if (match) return 'Credentials are correct!';<br>      return 'Invalid Credentials!';<br>    }<br>    return 'Invalid Invalid!';<br>  }<br>…</pre><p>In the above code snippet, we used the ```userModel.findOne()``` method to check if the email provided by the user exists in our database. Then, we used ```bcrypt.compare()``` to compare the plain password supplied with the database's hashed version of the password. Here, you can decide to grant a user access to services in your application if the credentials provided are correct.
### Implement Data Encryption
We’ve seen how to increase the security of our application by hashing the sensitive data in a user’s record. Now, let’s look at how we can secure user data with encryption. Let's say we’re building a chatting or social networking application where many users' secrets (confidential to them and the person they’re communicating with) are shared online. If such data is not encrypted, hackers can gain unauthorized access to the user's private information.
Let’s get started implementing data encryption in our application. First, create a ```utils```<strong> </strong>folder in the<strong> </strong>```src```<strong> </strong>directory. In the ```utils```<strong> </strong>folder, create an ```encrypt.ts``` file and add the code snippets below:
e>import {<br>  createCipheriv,<br>  randomBytes,<br>  createDecipheriv,<br>  createHash,<br>} from 'crypto';<br><br>const alg = 'aes-256-ctr';<br>let key = 'The Encryption Key';<br>key = createHash('sha256').update(String(key)).digest('base64').substr(0, 32);<br><br>export const encryptData = (data) =&gt; {<br>  const iv = randomBytes(16);<br>  const cipher = createCipheriv(alg, key, iv);<br>  const result = Buffer.concat([iv, cipher.update(data), cipher.final()]);<br>  return result;<br>};</pre><p>We imported all the functions we needed from the crypto module in the above code snippet. We’re using the AES (Advanced Encryption System) algorithm because it’s easy to implement. You can use any algorithm of your choosing. In our code, we created an initializer vector and built a new cipher using the algorithm, key, and iv with the ```createCipher()``` method. Finally, we made an encrypted buffer from the data supplied.
Now, let’s create another function to decrypt the data when an authorized user wants to access it. To do this, we’ll use the code snippet below:
e>export const decryptData = (data) =&gt; {<br>  const iv = data.slice(0, 16);<br>  data = data.slice(16);<br>  const decipher = createDecipheriv(algorithm, key, iv);<br>  const result = Buffer.concat([decipher.update(data), decipher.final()]);<br>  return result;<br>};</pre><p>In the above code snippet, we used the ```slice()``` method to get the first 16 bytes of the encrypted buffer and then the rest of the data. We also modified the value. Then, we created a decipher and decrypted the encrypted buffer.
Now, open the ```app.service.ts``` file, and create another method to encrypt and decrypt users' messages with the code snippet below:
e>...<br>import { encryptData, decryptData } from './utils/encrypt-file';<br><br>...<br>async sendMessage(message: string): Promise&lt;object&gt; {<br>  const encryptedMessage = encrypt(message);<br>  const decrytedMessage = decrypt(encryptedMessage);<br>  return {<br>    'Encryted Message': encryptedMessage.toString(),<br>    'Decryted Message': decrytedMessage.toString(),<br>  };<br>}<br>...</pre><p>In the above code snippet, we imported the ```encryptData``` and ```decryptData```<strong> </strong>functions we created. Then we encrypted and decrypted the user-provided message and returned both versions of the message. This was done to show what the encrypted message looks like. However, you can proceed and save the encrypted data in your database.
Finally, create the route controllers for the AppService class methods in the ```app.controller.ts``` file with the code snippet below:
Now, start the application by running the command below:
e>Npm run start:dev</pre><p>Then, use any API testing tool like Postman or Insomnia to test the application at <a href="http://localhost:3000/" target="_blank" rel="noopener noreferrer">http://localhost:3000</a>.
## Conclusion
This tutorial demonstrated how to increase the security of a NestJS application with encryption and hashing. Now, you should have an understanding of what encryption, hashing, and NestJS are. You also learned how to create a NestJS allocation, connect to a database, create a model, service, and controller, and implement data encryption and hashing. Now that you have this knowledge, how would you increase the security of your next project? Perhaps you can check out the NestJS official <a href="https://docs.nestjs.com/" target="_blank" rel="noopener noreferrer">documentation</a> to learn more.
