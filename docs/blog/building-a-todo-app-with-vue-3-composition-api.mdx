![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd69256f36a9075c5f25be_todoapp_c6e3bbf6174151c7859ea71c9383836f_2000.jpeg)
"vue"
# Building a ToDo App With Vue 3 Composition API
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<p>The Composition API was a significant advancement in Vue 3. It consists of a group of APIs that let users use Vue's parts by importing functions rather than expressing options as they would when using the Options API.<p.new.line><p>In this article, we‚Äôll be building a task tracker with Vue 3 Composition API. Here is the link to the<a href="https://vue--todo-app.vercel.app/" target="_blank" rel="noopener noreferrer"> application demo</a>.<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The finished ToDo Application." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/639739a651b100af490d477f_image1_8d4003f2c1646ff83e303abb8fa244d2.gif"><div.new.line><figure.new.line><h2 id="bulmk">What is the Composition API?<h2.new.line><p>As an alternative to the Options API, a new way to create Vue apps was introduced in Vue 3. It is a functional-based API that enables developers to create Vue components without using declarative functions by employing imported functions.<p.new.line><h3 id="bdrk0">Why Use Composition API?<h3.new.line><p>Due to the logical data distribution among numerous options, scaling a large Vue application that uses the Optional API can be highly frenetic and demanding. However, the Composition API corrects this by putting all the data that has been divided into options together, making them more flexible and easier to comprehend.<p.new.line><h4 id="2vlhk">Composition Hooks<h4.new.line><p>The Composition API comes with many custom hooks, some of which we‚Äôll be using in this article. Before hopping in, let's familiarize ourselves with the hooks and their uses:<p.new.line><ul><li><strong><a href="https://vuejs.org/api/reactivity-core.html#ref" target="_blank" rel="noopener noreferrer">Ref</a>: </strong>The ref hook is used to create a local state.<li.new.line><li><strong><a href="https://vuejs.org/guide/essentials/watchers.html#basic-example" target="_blank" rel="noopener noreferrer">Watch</a>: </strong>The watch hook initiates an event as soon as a change in a reactive state is noticed.<li.new.line><li><strong><a href="https://vuejs.org/api/composition-api-lifecycle.html#onmounted" target="_blank" rel="noopener noreferrer">OnMounted</a></strong>:  The onMounted hook is a lifecycle hook that registers a callback immediately after the component is mounted.<li.new.line><ul.new.line><h4 id="35hov">Prerequisites<h4.new.line><p>To follow along with this tutorial, you‚Äôll need to first clone the<a href="https://github.com/iamVictorSam/vue-todo-app/tree/starter" target="_blank" rel="noopener noreferrer"> stater file from Github.</a><p.new.line><h2 id="7jk7q">Setting Up Work Environments<h2.new.line><p>After cloning the repo from Github, let‚Äôs navigate to the cloned project directory and run the command below in our terminal to initialize yarn for the project and also run the development server:<p.new.line><pre>yarn &amp;&amp; yarn dev</pre><h2 id="dnjb2">Creating Todo Functionalities<h2.new.line><p>With our project initialized with yarn and running in the browser, we can start creating some basic functionalities.<p.new.line><h3 id="8akgf">Initializing Global Variables<h3.new.line><p>In this section, we‚Äôll be initializing some global variables that we‚Äôll use later in our application. First, let‚Äôs replace the entire ```App.vue``` with the code block below:<p.new.line><pre>&lt;script setup&gt;<br>import {ref, onMounted, watch} from &quot;vue&quot;;<br><br>const todos = ref([]);<br>const text = ref(&quot;&quot;);<br><br>&lt;/script&gt;</pre><p>In the code block above, we're initializing our global variables. The setup attribute added to the ```&lt;script&gt;``` tag gives us access to use the Composition API and its hooks.<p.new.line><h3 id="4jpfo">Creating Todos<h3.new.line><p>Next, let‚Äôs create a function that adds todos to our application. To do this, we‚Äôll copy and add the code block below into the ```script``` tag:<p.new.line><pre>&lt;script setup&gt;<br>import {ref, onMounted, watch} from &quot;vue&quot;;<br><br>const todos = ref([]);<br>const text = ref(&quot;&quot;);<br><br>&lt;/script&gt;</pre><p>In the code block above, we‚Äôre pushing an object into the ```todos``` array containing a ```todo``` and ```done``` property whenever the user creates a todo. We‚Äôre also checking for empty inputs.<p.new.line><p><em>The ```unshift``` method adds the current item to the beginning of the array.</em><p.new.line><h3 id="2c60l">Deleting Todos<h3.new.line><p>Let‚Äôs give our users the ability to remove unwanted todos from their list. Next, we‚Äôll add the code below the ```addTodo``` function in the ```&lt;script&gt;``` tag:<p.new.line><pre>function deleteTodo(todo) {<br>  todos.value = todos.value.filter((x) =&gt; x !== todo);<br>}</pre><p>In the code block above, we‚Äôre filtering through the todos array and returning a new array without the todo passed to it.<p.new.line><h3 id="5ti2e">Adding Todos to Browsers‚Äô Local Storage<h3.new.line><p>We want to persist our user‚Äôs data to the browser‚Äôs local storage to avoid losing it on page refresh and reload. To achieve this, we‚Äôll add the code below the ```deleteTodo``` into the ```&lt;script&gt;``` tag:<p.new.line><pre>watch(<br> todos,<br>  (newTodoValue) =&gt; {<br>    localStorage.setItem(&quot;todos&quot;, JSON.stringify(newTodoValue));<br>  },<br>  { deep: true }<br>);</pre><p>In the code block above, we‚Äôre adding a ```newTodoValue``` to the ```todos``` object in the browser‚Äôs local storage by listening to changes in the todos array.  We‚Äôre also setting the deep property to true to make our watch function listen further in the array for the slightest change.<p.new.line><h3 id="a84g7">Retrieving Todos from Browsers‚Äô Local Storage<h3.new.line><p>Finally, let‚Äôs retrieve our todos from the browser's local storage whenever our page is mounted. To achieve this, we‚Äôll copy and paste the function below into the ```&lt;script&gt;``` tag:<p.new.line><pre>onMounted(() =&gt; {<br>  todos.value = JSON.parse(localStorage.getItem(&quot;todos&quot;)) || [];<br>});</pre><p>In the code block above, we‚Äôre getting the todos from the browser's local storage whenever the page is mounted, and returning an empty array if the local storage is empty.<p.new.line><h2 id="btrt9">Building User Interface<h2.new.line><p>In the previous section, we did a setup of logic and functionalities for our task tracker. Let‚Äôs put all those into our user interface.<p.new.line><h3 id="6hjio">Handling Todo Input Event<h3.new.line><p>In this section, we‚Äôll be using the logic created earlier to retrieve and store our user‚Äôs input data:<p.new.line><pre>&lt;template&gt;<br>  &lt;main class=&quot;app&quot;&gt;<br>    &lt;section class=&quot;greeting&quot;&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;‚úçÔ∏èToDo Application&lt;/h3&gt;<br>    &lt;/section&gt;<br>    &lt;div class=&quot;input-section&quot;&gt;<br>      &lt;section class=&quot;create-todo&quot;&gt;<br>        &lt;form @submit.prevent=&quot;addTodo&quot;&gt;<br>          &lt;h3&gt;What do you plan on doingüôÇ?&lt;/h3&gt;<br>          &lt;input<br>            type=&quot;text&quot;<br>            placeholder=&quot;e.g. email your boss&quot;<br>            v-model=&quot;text&quot;<br>          /&gt;<br>          &lt;input type=&quot;submit&quot; value=&quot;Add todo&quot; /&gt;<br>        &lt;/form&gt;<br>      &lt;/section&gt;<br>    &lt;/div&gt;<br><br>  &lt;/main&gt;<br>&lt;/template&gt;</pre><p>In the code block above, we‚Äôre passing the user‚Äôs data from the input text into the ```addTodo``` function. The ```addTodo``` function adds this data to our todo array in our ```script``` tag.<p.new.line><h3 id="1ljti">Displaying the Todo List<h3.new.line><p>After adding the todo to our ```todos``` array, we should visualize it in our UI. To achieve this, we‚Äôll copy and paste the code below the ```create-task``` section:<p.new.line><pre>&lt;template&gt;<br>  &lt;main class=&quot;app&quot;&gt;<br><br>  ...    &lt;!-- previous code block here --&gt;<br><br>    &lt;div class=&quot;todo-section&quot;&gt;<br>      &lt;section class=&quot;todo-list&quot;&gt;<br>        &lt;h2 v-show=&quot;todos.length === 0&quot;&gt;No Todos Hereüòû&lt;/h2&gt;<br>        &lt;div class=&quot;list&quot;&gt;<br>          &lt;div<br>            v-for=&quot;todo in todos&quot;<br>            :class=&quot;&#x60;todo-item ${todo.done &amp;&amp; 'done'}&#x60;&quot;<br>          &gt;<br>            &lt;label&gt;<br>              &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot; /&gt;<br>            &lt;/label&gt;<br>            &lt;div class=&quot;todo-content&quot;&gt;<br>              &lt;input type=&quot;text&quot; v-model=&quot;todo.todo&quot; /&gt;<br>            &lt;/div&gt;<br>            &lt;div class=&quot;actions&quot;&gt;<br>              &lt;button class=&quot;delete&quot; @click=&quot;deleteTodo(todo)&quot;&gt;Delete&lt;/button&gt;<br>            &lt;/div&gt;<br>          &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/section&gt;<br>    &lt;/div&gt;<br><br>  &lt;/main&gt;<br>&lt;/template&gt;</pre><p>In the code block above, we‚Äôre looping through the ```todos``` array to display each todo and a checkbox to complete the task. We‚Äôre also calling the ```deleteTodo``` function to delete a particular todo from the list, and displacing a text if the ```todos``` array is empty.<p.new.line><p>With our progress in this article, we‚Äôve been able to achieve the results below:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The finalized todo Application." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/639739a651b100af490d477f_image1_8d4003f2c1646ff83e303abb8fa244d2.gif"><div.new.line><figure.new.line><h4 id="bv6lo">Resources<h4.new.line><p>Here is the link to the<a href="https://github.com/iamVictorSam/vue-todo-app/tree/final" target="_blank" rel="noopener noreferrer"> full source code on Github</a>.<p.new.line><h2 id="14jek">Conclusion<h2.new.line><p>In this article, we‚Äôve learned how to use the most popular Composition API hooks. We‚Äôve also used the Vue Composition API to conduct some basic operations ranging from creating, retrieving, and deleting data. Due to its hook-based simplicity, the Composition API will always be the best and most significant feature in Vue 3.<p.new.line><p>Visit the<a href="https://vuejs.org/api/composition-api-setup.html#basic-usage" target="_blank" rel="noopener noreferrer"> Official Documentation</a> for more information on other Vue's Composition A
The Composition API was a significant advancement in Vue 3. It consists of a group of APIs that let users use Vue's parts by importing functions rather than expressing options as they would when using the Options API.
In this article, we‚Äôll be building a task tracker with Vue 3 Composition API. Here is the link to the<a href="https://vue--todo-app.vercel.app/" target="_blank" rel="noopener noreferrer"> application demo</a>.
![](ssl.webflow.com/6143afec68f555387049efb3/639739a651b100af490d477f_image1_8d4003f2c1646ff83e303abb8fa244d2.g)
## What is the Composition API?
As an alternative to the Options API, a new way to create Vue apps was introduced in Vue 3. It is a functional-based API that enables developers to create Vue components without using declarative functions by employing imported functions.
### Why Use Composition API?
Due to the logical data distribution among numerous options, scaling a large Vue application that uses the Optional API can be highly frenetic and demanding. However, the Composition API corrects this by putting all the data that has been divided into options together, making them more flexible and easier to comprehend.
The Composition API comes with many custom hooks, some of which we‚Äôll be using in this article. Before hopping in, let's familiarize ourselves with the hooks and their uses:
- <strong><a href="https://vuejs.org/api/reactivity-core.html#ref" target="_blank" rel="noopener noreferrer">Ref</a>: </strong>The ref hook is used to create a local state.
- <strong><a href="https://vuejs.org/guide/essentials/watchers.html#basic-example" target="_blank" rel="noopener noreferrer">Watch</a>: </strong>The watch hook initiates an event as soon as a change in a reactive state is noticed.
- <strong><a href="https://vuejs.org/api/composition-api-lifecycle.html#onmounted" target="_blank" rel="noopener noreferrer">OnMounted</a></strong>:  The onMounted hook is a lifecycle hook that registers a callback immediately after the component is mounted.
To follow along with this tutorial, you‚Äôll need to first clone the<a href="https://github.com/iamVictorSam/vue-todo-app/tree/starter" target="_blank" rel="noopener noreferrer"> stater file from Github.</a>
## Setting Up Work Environments
After cloning the repo from Github, let‚Äôs navigate to the cloned project directory and run the command below in our terminal to initialize yarn for the project and also run the development server:
With our project initialized with yarn and running in the browser, we can start creating some basic functionalities.
### Initializing Global Variables
In this section, we‚Äôll be initializing some global variables that we‚Äôll use later in our application. First, let‚Äôs replace the entire ```App.vue``` with the code block below:
e>&lt;script setup&gt;<br>import {ref, onMounted, watch} from &quot;vue&quot;;<br><br>const todos = ref([]);<br>const text = ref(&quot;&quot;);<br><br>&lt;/script&gt;</pre><p>In the code block above, we're initializing our global variables. The setup attribute added to the ```&lt;script&gt;``` tag gives us access to use the Composition API and its hooks.
### Creating Todos
Next, let‚Äôs create a function that adds todos to our application. To do this, we‚Äôll copy and add the code block below into the ```script``` tag:
e>&lt;script setup&gt;<br>import {ref, onMounted, watch} from &quot;vue&quot;;<br><br>const todos = ref([]);<br>const text = ref(&quot;&quot;);<br><br>&lt;/script&gt;</pre><p>In the code block above, we‚Äôre pushing an object into the ```todos``` array containing a ```todo``` and ```done``` property whenever the user creates a todo. We‚Äôre also checking for empty inputs.
<em>The ```unshift``` method adds the current item to the beginning of the array.</em>
### Deleting Todos
Let‚Äôs give our users the ability to remove unwanted todos from their list. Next, we‚Äôll add the code below the ```addTodo``` function in the ```&lt;script&gt;``` tag:
e>function deleteTodo(todo) {<br>  todos.value = todos.value.filter((x) =&gt; x !== todo);<br>}</pre><p>In the code block above, we‚Äôre filtering through the todos array and returning a new array without the todo passed to it.
### Adding Todos to Browsers‚Äô Local Storage
We want to persist our user‚Äôs data to the browser‚Äôs local storage to avoid losing it on page refresh and reload. To achieve this, we‚Äôll add the code below the ```deleteTodo``` into the ```&lt;script&gt;``` tag:
e>watch(<br> todos,<br>  (newTodoValue) =&gt; {<br>    localStorage.setItem(&quot;todos&quot;, JSON.stringify(newTodoValue));<br>  },<br>  { deep: true }<br>);</pre><p>In the code block above, we‚Äôre adding a ```newTodoValue``` to the ```todos``` object in the browser‚Äôs local storage by listening to changes in the todos array.  We‚Äôre also setting the deep property to true to make our watch function listen further in the array for the slightest change.
### Retrieving Todos from Browsers‚Äô Local Storage
Finally, let‚Äôs retrieve our todos from the browser's local storage whenever our page is mounted. To achieve this, we‚Äôll copy and paste the function below into the ```&lt;script&gt;``` tag:
e>onMounted(() =&gt; {<br>  todos.value = JSON.parse(localStorage.getItem(&quot;todos&quot;)) || [];<br>});</pre><p>In the code block above, we‚Äôre getting the todos from the browser's local storage whenever the page is mounted, and returning an empty array if the local storage is empty.
## Building User Interface
In the previous section, we did a setup of logic and functionalities for our task tracker. Let‚Äôs put all those into our user interface.
### Handling Todo Input Event
In this section, we‚Äôll be using the logic created earlier to retrieve and store our user‚Äôs input data:
e>&lt;template&gt;<br>  &lt;main class=&quot;app&quot;&gt;<br>    &lt;section class=&quot;greeting&quot;&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;‚úçÔ∏èToDo Application&lt;/h3&gt;<br>    &lt;/section&gt;<br>    &lt;div class=&quot;input-section&quot;&gt;<br>      &lt;section class=&quot;create-todo&quot;&gt;<br>        &lt;form @submit.prevent=&quot;addTodo&quot;&gt;<br>          &lt;h3&gt;What do you plan on doingüôÇ?&lt;/h3&gt;<br>          &lt;input<br>            type=&quot;text&quot;<br>            placeholder=&quot;e.g. email your boss&quot;<br>            v-model=&quot;text&quot;<br>          /&gt;<br>          &lt;input type=&quot;submit&quot; value=&quot;Add todo&quot; /&gt;<br>        &lt;/form&gt;<br>      &lt;/section&gt;<br>    &lt;/div&gt;<br><br>  &lt;/main&gt;<br>&lt;/template&gt;</pre><p>In the code block above, we‚Äôre passing the user‚Äôs data from the input text into the ```addTodo``` function. The ```addTodo``` function adds this data to our todo array in our ```script``` tag.
### Displaying the Todo List
After adding the todo to our ```todos``` array, we should visualize it in our UI. To achieve this, we‚Äôll copy and paste the code below the ```create-task``` section:
e>&lt;template&gt;<br>  &lt;main class=&quot;app&quot;&gt;<br><br>  ...    &lt;!-- previous code block here --&gt;<br><br>    &lt;div class=&quot;todo-section&quot;&gt;<br>      &lt;section class=&quot;todo-list&quot;&gt;<br>        &lt;h2 v-show=&quot;todos.length === 0&quot;&gt;No Todos Hereüòû&lt;/h2&gt;<br>        &lt;div class=&quot;list&quot;&gt;<br>          &lt;div<br>            v-for=&quot;todo in todos&quot;<br>            :class=&quot;&#x60;todo-item ${todo.done &amp;&amp; 'done'}&#x60;&quot;<br>          &gt;<br>            &lt;label&gt;<br>              &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot; /&gt;<br>            &lt;/label&gt;<br>            &lt;div class=&quot;todo-content&quot;&gt;<br>              &lt;input type=&quot;text&quot; v-model=&quot;todo.todo&quot; /&gt;<br>            &lt;/div&gt;<br>            &lt;div class=&quot;actions&quot;&gt;<br>              &lt;button class=&quot;delete&quot; @click=&quot;deleteTodo(todo)&quot;&gt;Delete&lt;/button&gt;<br>            &lt;/div&gt;<br>          &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/section&gt;<br>    &lt;/div&gt;<br><br>  &lt;/main&gt;<br>&lt;/template&gt;</pre><p>In the code block above, we‚Äôre looping through the ```todos``` array to display each todo and a checkbox to complete the task. We‚Äôre also calling the ```deleteTodo``` function to delete a particular todo from the list, and displacing a text if the ```todos``` array is empty.
With our progress in this article, we‚Äôve been able to achieve the results below:
![](-ssl.webflow.com/6143afec68f555387049efb3/639739a651b100af490d477f_image1_8d4003f2c1646ff83e303abb8fa244d2.g)
Here is the link to the<a href="https://github.com/iamVictorSam/vue-todo-app/tree/final" target="_blank" rel="noopener noreferrer"> full source code on Github</a>.
## Conclusion
In this article, we‚Äôve learned how to use the most popular Composition API hooks. We‚Äôve also used the Vue Composition API to conduct some basic operations ranging from creating, retrieving, and deleting data. Due to its hook-based simplicity, the Composition API will always be the best and most significant feature in Vue 3.
