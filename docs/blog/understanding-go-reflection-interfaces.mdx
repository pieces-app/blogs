![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63e65f2417cf27ec0fd7d243_UnderstandingReflection_bf9055563e304293f1c6ebd838b6f31d_2000.jpeg)
"interface; go-a"
# Understanding Reflection and Interfaces in the Go Programming Language
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<p>Go is a statically-typed “minimalist” programming language with an execution approach based on the notion that programs are collections of instructions to be compiled and executed— procedural programming. As a result, it does well when writing server-side applications that are simple, fast and familiar to most programmers.<p.new.line><p>This article will look at the <strong>Reflection and Interface</strong> concepts that Go provides as part of its collection of features. <strong>Reflection</strong> gives us the flexibility to dynamically inspect and learn about the type of an arbitrary object along with information about its intrinsic structure. <strong>Interface </strong>on its own dynamics helps identify, abstract, and define behavioral patterns that different data types can share.<p.new.line><h2 id="893ve">What is Reflection in Go?<h2.new.line><p>Go uses static typing, meaning every variable has precisely one fixed type known at build time, known as its static type. With that well stated, there’s then a concern of how to deal and interact with data types that do not yet exist when you implement your code, but may exist in the future.<p.new.line><p>In its simplest form, reflection is the capacity of a program to examine/inspect its own values and variables during execution and determine their type. A familiar scenario where reflection allows us to inspect and manipulate unknown structures is decoding JSON data. Another scenario would be when working with data types that don't implement a common interface and thus have peculiar or unknown behaviors.<p.new.line><p>Reflection is built around three concepts: <strong>Types</strong>, <strong>Kinds</strong>, and <strong>Values</strong>. The <strong>Kind</strong> can be struct, int, string, slice, map, or any other Go primitive type. If you define a struct named Foo, the Kind is a <strong>struct,</strong> and the Type is <strong>Foo</strong>. The types and functions used to implement reflection in Go reside in the standard library's reflect package. Let’s look at some helpful functions defined within the reflect package:<p.new.line><pre><em>// go</em><br>package main<br><br>import (<br> &quot;fmt&quot;<br> &quot;reflect&quot;<br>)<br><br>type Foo struct {<br>  addr string<br>  dip  Dip<br>}<br><br>type Dip struct {<br>  name string<br>  age  int<br>}<br><br>var data = Foo{<br>  dip: Dip{name: &quot;Alice&quot;, age: 10},<br>  addr: &quot;alton street&quot;,<br>}<br><br>func main() {<br> <em>// Inspect the reflection Type of a variable</em><br>  rt := reflect.TypeOf(data)<br>  fmt.Println(rt)<br><br> <em>// Inspect the reflection Value of a variable</em><br>  rv := reflect.ValueOf(data)<br>  fmt.Println(rv)<br><br> <em>// Alternatively</em><br>  rt = rv.Type()<br>  fmt.Println(rt)<br><br> <em>// Inspect the reflection Kind of a variable</em><br>  rk := rv.Kind()<br>  fmt.Println(rk)<br><br> <em>// Inspect the reflection Name of a variable</em><br>  rn := rt.Name()<br>  fmt.Println(rn)<br><br> <em>// Traverse the fields of a struct.</em><br> if rt.Kind() == reflect.Struct {<br> for i := 0; i &lt; rt.NumField(); i++ {<br>      fv := rv.Field(i)<br>      fmt.Println(fv)<br>    }<br>  }<br><br> <em>// Inspect the underlying contained type in a variable</em><br>  rt = reflect.TypeOf([2]int {1, 2})<br>  ct = ct.Elem()<br>  fmt.Println(ct)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=e6a84ab2a6" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p><strong>Output:</strong><p.new.line><pre>// terminal<br>main.Foo<br>{alton street {Alice 10}}<br>main.Foo<br>struct<br>Foo<br>alton street<br>{Alice 10}<br>int</pre><p>In the above snippet, we defined two structs, ```Foo``` and ```Dip``` as our sample structures to use along with the ```reflection``` package. The ```reflect.TypeOf``` function returns ```reflect.Type```, which has methods defined on its type to provide other information about the type of the variable passed in. The ```reflect.ValueOf``` function returns ```reflect.Value```, which allows the reflection to read or write values.<p.new.line><p>In addition to reading, we can also use the ```reflection``` package to modify/write the value of a structure. To modify a value using the ```reflect.ValueOf``` function, we need to pass a pointer to the variable instead and call the ```Elem``` function, which will return the value at the pointer address.<p.new.line><pre><em>// go</em><br>package main<br><br>import (<br> &quot;fmt&quot;<br> &quot;reflect&quot;<br>)<br><br>type Pieces struct {<br>  Id int<br>  Content string<br>  Rating float64<br>}<br><br>func main() {<br>  data := Pieces{1, &quot;I come in peace, comrade!&quot;, 4.1}<br>  fmt.Printf(&quot;Original data: %+v\\n&quot;, data)<br>  mutData := reflect.ValueOf(&amp;data).Elem()<br><br> for i := 0; i &lt; mutData.NumField(); i++ {<br> if mutData.Field(i).Kind() == reflect.Int {<br>      mutData.Field(i).SetInt(12)<br>    } else if mutData.Field(i).Kind() == reflect.String {<br>      mutData.Field(i).SetString(&quot;No, I live for violence, comrade!&quot;)<br>    } else if mutData.Field(i).Kind() == reflect.Float64 {<br>      mutData.Field(i).SetFloat(5.5)<br>    }<br>  }<br><br>  fmt.Printf(&quot;Mutated data: %+v\\n&quot;, data)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=6e54499f8e" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p><strong>Output</strong>:<p.new.line><pre>// terminal<br>Original data: {Id:1 Content:I come in peace, comrade! Rating:4.1}<br>Mutated data: {Id:12 Content:No, I live for violence, comrade! Rating:5.5}</pre><p>In the above snippet, notice the use of the ```SetInt```, ```SetString```, and the ```SetFloat``` functions to write the new values of the structure.  The ```reflect``` package defined more of these functions for changing the value of primitive data types. Find more info about the <a href="https://pkg.go.dev/reflect" target="_blank" rel="noopener noreferrer">reflect package</a>. Note, it’s a safe practice always to check if the value of the structure can be changed using the ```reflect.Value.CanSet``` function.<p.new.line><h2 id="6goo0">Introduction to Type methods and Interface in Go<h2.new.line><h3 id="4qu98">Type methods<h3.new.line><p>When a function is attached to a specific data type, receiver argument, we consider this a type method in Go. The receiver argument gives the method the needed access to the underlying data type to either read it, write to it, or both.<p.new.line><p>We can define the type method using the following Go syntaxes:<p.new.line><pre><em>// A copy of the receiver argument</em><br>func (p Pieces) refChange() { } <em>// &lt;-- 1</em><br><br><em>// a pointer to the receiver argument</em><br>func (p *Pieces) refChange() { } <em>// &lt;-- 2</em></pre><p>Defining a type method with the first syntax means we’re passing a copy of the value of the receiver argument to the ```refChange``` function. In the second definition, we defined and passed the pointer to the receiver argument instead of passing a copy of the receiver argument. This definition gives us direct access to the receiver argument in the ```refChange``` function, meaning we can persist the changes made to the receiver argument.<p.new.line><p>Let’s implement a method on the ```Pieces``` struct to change the values of the struct using the ```reflect``` package:<p.new.line><pre><em>// go</em><br>...<br>func (p *Pieces) refChange(id int64, content string, rating float64) {<br>  mutData := reflect.ValueOf(p).Elem()<br> for i := 0; i &lt; mutData.NumField(); i++ {<br> if mutData.Field(i).Kind() == reflect.Int {<br>      mutData.Field(i).SetInt(id)<br>    } else if mutData.Field(i).Kind() == reflect.String {<br>      mutData.Field(i).SetString(content)<br>    } else if mutData.Field(i).Kind() == reflect.Float64 {<br>      mutData.Field(i).SetFloat(rating)<br>      mutData.Field(i).CanSet()<br>    }<br>  }<br>}<br><br>func main() {<br>  data := &amp;Pieces{1, &quot;I come in peace, comrade!&quot;, 4.1}<br>  fmt.Printf(&quot;Original data: %+v\\n&quot;, data)<br><br>  data.refChange(100, &quot;No, peace is not an option comrade!&quot;, 4.7)<br>  fmt.Printf(&quot;Mutated data: %+v\\n&quot;, data)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=38ef428609" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p><strong>Output</strong>:<p.new.line><pre>// terminal<br>Original data: {Id:1 Content:I come in peace, comrade! Rating:4.1}<br>Mutated data: {Id:100 Content:No, peace is not an option comrade! Rating:4.7}</pre><p>This is a simple introduction to the type method on structures in Go. <a href="https://go.dev/doc/effective_go#methods" target="_blank" rel="noopener noreferrer">Learn more about the type method in the Go documentation.</a><p.new.line><h3 id="flu7q">Interfaces<h3.new.line><p>In Go, an <strong>interface </strong>is a mechanism for defining behavior that is implemented using a set of method signatures. The interface type describes the behavioral expectation of other types by defining a set of type methods<em> </em>that need to be implemented by these other types before claiming to support the behavior. In essence, interface works with type methods associated with a given data type; although we can use any data type in Go, it’s usually struct. So, before a Go type satisfies an interface type, it would need to implement all of the type methods defined by the interface type.<p.new.line><pre>...<br>type Blog interface {<br>  ReadContent(string) (string, int)<br>  GetRating() (float64)<br>}<br>...</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=788340858c" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>The above snippet defines an interface type with two function signatures, ```ReadContent``` and ```GetRating```. For a type in Go to implement this interface means it has ```ReadContent``` and ```GetRating``` type methods defined. Let’s define these type methods for the ```Pieces``` struct:<p.new.line><pre>...<br>func (p *Pieces) ReadContent(input string) (string, int) {<br> if input != &quot;&quot; {<br>    p.Content = input<br>  }<br> return p.Content, utf8.RuneCountInString(p.Content)<br>}<br><br>func (p *Pieces) GetRating() (float64) {<br> return p.Rating<br>}<br>...</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=409e458def" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>In the above snippet, once we implemented the functions of an interface for the ```Pieces``` data type, that interface is satisfied automatically<strong> </strong>for that data type. To make some sense out of these, let’s say we want to publish any post on our blog, but we want the post to be readable and rate-able. With the help of interface type, we can place some sort of boundary on a ```Publish``` function:<p.new.line><pre>...<br>func Publish(post Blog) {<br> if r := post.GetRating(); r != 0 {<br>    c, rc := post.ReadContent(&quot;&quot;)<br>    fmt.Printf(&quot;New post: %s\\nWord count:%d\\tWith rating: %.1f\\n&quot;, c, rc, r)<br>  }<br>}<br>...</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=36de438801" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p><strong>Output:</strong><p.new.line><pre>// terminal<br>New post: No, peace is not an option comrade!<br>Word count:35   With rating: 4.7</pre><p>Interfaces are abstract types that outline a set of methods that must be implemented for another type before it can be regarded as an instance of the interface. In other words, an interface consists of both a type and a collection of methods.<p.new.line><p>An <strong>empty interface </strong>is defined as just ```interface{}```. Since an empty interface has no methods, it can and is already implemented by every data type. For example, a slice which defines its elements as a type of empty interface means it can store anything in itself.<p.new.line><pre>// go<br>s := []interface{}{4, &quot;string&quot;, 2.5, new(Pieces), true} <em>// [4 string 2.5 0x140000ae000 true]</em></pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=b93243aa67" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>It’s advised to sparingly make use of the empty interface, especially when storing sequences of data so as to avoid errors that are easily tracked down during compiling time.<p.new.line><p>Let’s briefly look at three commonly used interfaces from the standard library shipped with Go upon installation. The three interfaces are the ```sort.Interface```, the ```io.Writer```, and ```io.Reader``` interfaces. Let’s briefly explain each below:<p.new.line><ol type="1"><li>The ```sort.Interface```: The ```sort.Interface``` defines three necessary methods for custom implementation to sort a slice of custom data. The ```sort``` package contains the ```sort.Interface``` interface with the below definition:<li.new.line></ol><pre>// go<br>type Interface interface {<br>  Len() int<br>  Less(i, j int) bool<br>  Swap(i, j int)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=37e3449b16" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>Once we implement ```sort.Interface``` for our custom data stored in slices, the above three methods allow us to sort the slices according to our custom needs and data.<p.new.line><ul><li>The ```Len``` function returns the actual length of the slice being sorted.<li.new.line><li>The ```Less``` function contains the implementation of how the elements would be compared and sorted; this implementation would be custom to the needs of the developer but must return the boolean value of the comparison between the element at index ```i``` and ```j```.<li.new.line><li>The ```Swap``` does the actual swapping of elements within the slice based on the outcome of ```Less```. This is required for the sorting algorithm to work.<li.new.line><ul.new.line><p>     2 . The ```io.Writer```: This interface represents the writing part of the basis of file I/O in Go. The operation of writing to either a file, network or any writable process, involves the implementation of ```io.Writer``` for that writable object (data type). The interface definition is:<p.new.line><pre>// go<br>type Writer interface {<br>  Write(p []byte) (n int, err error)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=765343948b" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>The above interface definition needs only one function signature to satisfy the ```Writer``` interface. The ```Write``` function takes as its argument a byte slice containing the data we want to write to, either a file, network or any writable object, and returns two named values, ```n``` and ```err```. These values represent the number of bytes written and an ```error``` variable.<p.new.line><p>   3. The ```io.Reader```: This interface represents the reading part of the basis of file I/O in Go–the operation of reading from either a file, network or any readable process. The ```Reader``` interface defines only one function signature just like ```io.Writer```. Let’s look at the interface definition:<p.new.line><pre>// go<br>type Reader interface {<br>  Read(p []byte) (n int, err error)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=765343948b" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p>The above definition takes as its argument a byte slice which we will fill with data being read from a file, a network, or any readable object. We fill the byte slice with data up to its length. The return values represent the number of bytes read and an ```error``` variable.<p.new.line><h2 id="8pmij">Use cases of Go interface<h2.new.line><p>The concept of interfaces is predominantly used across different Go packages and executable programs to achieve flexibility without affecting the program's performance. The following example will explore the use of ```sort.Interface``` to sort the ```Pieces``` struct type:<p.new.line><pre>// go<br>...<br>type PSlice []Pieces<br><br>func (ps PSlice) Len() int {<br> return len(ps)<br>}<br><br>func (ps PSlice) Less(i, j int) bool {<br> return ps[i].Id &lt; ps[j].Id<br>}<br><br>func (ps PSlice) Swap(i, j int) {<br>  ps[i], ps[j] = ps[j], ps[i]<br>}<br><br>...<br><br>func main() {<br>  posts := []Pieces {<br>    {7, &quot;I come in peace, comrade!&quot;, 4.1},<br>    {100, &quot;No, peace is not an option comrade!&quot;, 4.7 },<br>    {13, &quot;I preach violence, comrade!&quot;, 4.5},<br>    {-1, &quot;I live for violence, comrade&quot;, 5.5},<br>  }<br>  fmt.Println(&quot;Original:&quot;, posts)<br>  sort.Sort(PSlice(posts))<br>  fmt.Println(&quot;Sorted:&quot;, posts)<br><br> // Reverse sorting automatically works<br>  sort.Sort(sort.Reverse(PSlice(posts)))<br>  fmt.Println(&quot;Reverse sort:&quot;, posts)<br>  ...<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=c21b4f8c07" target="_blank" rel="noopener noreferrer">Save this code</a><p.new.line><p><strong>Output</strong>:<p.new.line><pre>Original: [{7 I come in peace, comrade! 4.1} {100 No, peace is not an option comrade! 4.7} {13 I preach violence, comrade! 4.5} {-1 I live for violence, comrade 5.5}]<br><br>Sorted: [{-1 I live for violence, comrade 5.5} {7 I come in peace, comrade! 4.1} {13 I preach violence, comrade! 4.5} {100 No, peace is not an option comrade! 4.7}]<br><br>Reverse sort: [{100 No, peace is not an option comrade! 4.7} {13 I preach violence, comrade! 4.5} {7 I come in peace, comrade! 4.1} {-1 I live for violence, comrade 5.5}]</pre><p>That’s a long example, but only implemented the foundational concepts we shared earlier about the ```sort.Interface``` interface. We implemented ```Len```, ```Less``` and ```Swap``` for a type, ```PSlice```, which is basically a slice of ```Pieces```. With the type methods in place, we can now use the ```sort.Sort``` function to sort the slice, and also make use of the sort.Reverse function to perform reverse sorting on the slice. The ```PSlice(posts)``` expression will adapt the ```[]Pieces``` slice into the ```PSlice``` type with the methods ```Len```, ```Less``` and ```Swap```. This is possible because ```[]Pieces``` has the appropriate type signature with ```PSlice```.<p.new.line><h2 id="almlb">Conclusion<h2.new.line><p>In this tutorial, we covered what reflection and interfaces are in Go. For example, reflection provides a more elegant approach to scrubbing sensitive data before logging it. And as well, interfaces provide the flexibility to implement functionalities based on behaviors expected on a data type. We can now extend these concepts to build complex interfaces by combining one interface with another to form a new interface. The ```ReadCloser``` interface is a typical example of combining two interfaces, ```Reader``` and ```Closer```. The extensibility of these concepts are far beyond this tutorial, so I encourage you to explore more on these concepts. For more about when to use Go in general, check out <a href="https://code.pieces.app/blog/python-vs-golang" target="_blank" rel="noopener noreferrer">this comparison guide</a>.<p.new.line>\n\n
Go is a statically-typed “minimalist” programming language with an execution approach based on the notion that programs are collections of instructions to be compiled and executed— procedural programming. As a result, it does well when writing server-side applications that are simple, fast and familiar to most programmers.
This article will look at the <strong>Reflection and Interface</strong> concepts that Go provides as part of its collection of features. <strong>Reflection</strong> gives us the flexibility to dynamically inspect and learn about the type of an arbitrary object along with information about its intrinsic structure. <strong>Interface </strong>on its own dynamics helps identify, abstract, and define behavioral patterns that different data types can share.
## What is Reflection in Go?
Go uses static typing, meaning every variable has precisely one fixed type known at build time, known as its static type. With that well stated, there’s then a concern of how to deal and interact with data types that do not yet exist when you implement your code, but may exist in the future.
In its simplest form, reflection is the capacity of a program to examine/inspect its own values and variables during execution and determine their type. A familiar scenario where reflection allows us to inspect and manipulate unknown structures is decoding JSON data. Another scenario would be when working with data types that don't implement a common interface and thus have peculiar or unknown behaviors.
Reflection is built around three concepts: <strong>Types</strong>, <strong>Kinds</strong>, and <strong>Values</strong>. The <strong>Kind</strong> can be struct, int, string, slice, map, or any other Go primitive type. If you define a struct named Foo, the Kind is a <strong>struct,</strong> and the Type is <strong>Foo</strong>. The types and functions used to implement reflection in Go reside in the standard library's reflect package. Let’s look at some helpful functions defined within the reflect package:
e><em>// go</em><br>package main<br><br>import (<br> &quot;fmt&quot;<br> &quot;reflect&quot;<br>)<br><br>type Foo struct {<br>  addr string<br>  dip  Dip<br>}<br><br>type Dip struct {<br>  name string<br>  age  int<br>}<br><br>var data = Foo{<br>  dip: Dip{name: &quot;Alice&quot;, age: 10},<br>  addr: &quot;alton street&quot;,<br>}<br><br>func main() {<br> <em>// Inspect the reflection Type of a variable</em><br>  rt := reflect.TypeOf(data)<br>  fmt.Println(rt)<br><br> <em>// Inspect the reflection Value of a variable</em><br>  rv := reflect.ValueOf(data)<br>  fmt.Println(rv)<br><br> <em>// Alternatively</em><br>  rt = rv.Type()<br>  fmt.Println(rt)<br><br> <em>// Inspect the reflection Kind of a variable</em><br>  rk := rv.Kind()<br>  fmt.Println(rk)<br><br> <em>// Inspect the reflection Name of a variable</em><br>  rn := rt.Name()<br>  fmt.Println(rn)<br><br> <em>// Traverse the fields of a struct.</em><br> if rt.Kind() == reflect.Struct {<br> for i := 0; i &lt; rt.NumField(); i++ {<br>      fv := rv.Field(i)<br>      fmt.Println(fv)<br>    }<br>  }<br><br> <em>// Inspect the underlying contained type in a variable</em><br>  rt = reflect.TypeOf([2]int {1, 2})<br>  ct = ct.Elem()<br>  fmt.Println(ct)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=e6a84ab2a6" target="_blank" rel="noopener noreferrer">Save this code</a>
<strong>Output:</strong>
e>// terminal<br>main.Foo<br>{alton street {Alice 10}}<br>main.Foo<br>struct<br>Foo<br>alton street<br>{Alice 10}<br>int</pre><p>In the above snippet, we defined two structs, ```Foo``` and ```Dip``` as our sample structures to use along with the ```reflection``` package. The ```reflect.TypeOf``` function returns ```reflect.Type```, which has methods defined on its type to provide other information about the type of the variable passed in. The ```reflect.ValueOf``` function returns ```reflect.Value```, which allows the reflection to read or write values.
In addition to reading, we can also use the ```reflection``` package to modify/write the value of a structure. To modify a value using the ```reflect.ValueOf``` function, we need to pass a pointer to the variable instead and call the ```Elem``` function, which will return the value at the pointer address.
e><em>// go</em><br>package main<br><br>import (<br> &quot;fmt&quot;<br> &quot;reflect&quot;<br>)<br><br>type Pieces struct {<br>  Id int<br>  Content string<br>  Rating float64<br>}<br><br>func main() {<br>  data := Pieces{1, &quot;I come in peace, comrade!&quot;, 4.1}<br>  fmt.Printf(&quot;Original data: %+v\\n&quot;, data)<br>  mutData := reflect.ValueOf(&amp;data).Elem()<br><br> for i := 0; i &lt; mutData.NumField(); i++ {<br> if mutData.Field(i).Kind() == reflect.Int {<br>      mutData.Field(i).SetInt(12)<br>    } else if mutData.Field(i).Kind() == reflect.String {<br>      mutData.Field(i).SetString(&quot;No, I live for violence, comrade!&quot;)<br>    } else if mutData.Field(i).Kind() == reflect.Float64 {<br>      mutData.Field(i).SetFloat(5.5)<br>    }<br>  }<br><br>  fmt.Printf(&quot;Mutated data: %+v\\n&quot;, data)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=6e54499f8e" target="_blank" rel="noopener noreferrer">Save this code</a>
<strong>Output</strong>:
e>// terminal<br>Original data: {Id:1 Content:I come in peace, comrade! Rating:4.1}<br>Mutated data: {Id:12 Content:No, I live for violence, comrade! Rating:5.5}</pre><p>In the above snippet, notice the use of the ```SetInt```, ```SetString```, and the ```SetFloat``` functions to write the new values of the structure.  The ```reflect``` package defined more of these functions for changing the value of primitive data types. Find more info about the <a href="https://pkg.go.dev/reflect" target="_blank" rel="noopener noreferrer">reflect package</a>. Note, it’s a safe practice always to check if the value of the structure can be changed using the ```reflect.Value.CanSet``` function.
## Introduction to Type methods and Interface in Go
### Type methods
When a function is attached to a specific data type, receiver argument, we consider this a type method in Go. The receiver argument gives the method the needed access to the underlying data type to either read it, write to it, or both.
We can define the type method using the following Go syntaxes:
e><em>// A copy of the receiver argument</em><br>func (p Pieces) refChange() { } <em>// &lt;-- 1</em><br><br><em>// a pointer to the receiver argument</em><br>func (p *Pieces) refChange() { } <em>// &lt;-- 2</em></pre><p>Defining a type method with the first syntax means we’re passing a copy of the value of the receiver argument to the ```refChange``` function. In the second definition, we defined and passed the pointer to the receiver argument instead of passing a copy of the receiver argument. This definition gives us direct access to the receiver argument in the ```refChange``` function, meaning we can persist the changes made to the receiver argument.
Let’s implement a method on the ```Pieces``` struct to change the values of the struct using the ```reflect``` package:
e><em>// go</em><br>...<br>func (p *Pieces) refChange(id int64, content string, rating float64) {<br>  mutData := reflect.ValueOf(p).Elem()<br> for i := 0; i &lt; mutData.NumField(); i++ {<br> if mutData.Field(i).Kind() == reflect.Int {<br>      mutData.Field(i).SetInt(id)<br>    } else if mutData.Field(i).Kind() == reflect.String {<br>      mutData.Field(i).SetString(content)<br>    } else if mutData.Field(i).Kind() == reflect.Float64 {<br>      mutData.Field(i).SetFloat(rating)<br>      mutData.Field(i).CanSet()<br>    }<br>  }<br>}<br><br>func main() {<br>  data := &amp;Pieces{1, &quot;I come in peace, comrade!&quot;, 4.1}<br>  fmt.Printf(&quot;Original data: %+v\\n&quot;, data)<br><br>  data.refChange(100, &quot;No, peace is not an option comrade!&quot;, 4.7)<br>  fmt.Printf(&quot;Mutated data: %+v\\n&quot;, data)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=38ef428609" target="_blank" rel="noopener noreferrer">Save this code</a>
<strong>Output</strong>:
e>// terminal<br>Original data: {Id:1 Content:I come in peace, comrade! Rating:4.1}<br>Mutated data: {Id:100 Content:No, peace is not an option comrade! Rating:4.7}</pre><p>This is a simple introduction to the type method on structures in Go. <a href="https://go.dev/doc/effective_go#methods" target="_blank" rel="noopener noreferrer">Learn more about the type method in the Go documentation.</a>
### Interfaces
In Go, an <strong>interface </strong>is a mechanism for defining behavior that is implemented using a set of method signatures. The interface type describes the behavioral expectation of other types by defining a set of type methods<em> </em>that need to be implemented by these other types before claiming to support the behavior. In essence, interface works with type methods associated with a given data type; although we can use any data type in Go, it’s usually struct. So, before a Go type satisfies an interface type, it would need to implement all of the type methods defined by the interface type.
e>...<br>type Blog interface {<br>  ReadContent(string) (string, int)<br>  GetRating() (float64)<br>}<br>...</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=788340858c" target="_blank" rel="noopener noreferrer">Save this code</a>
The above snippet defines an interface type with two function signatures, ```ReadContent``` and ```GetRating```. For a type in Go to implement this interface means it has ```ReadContent``` and ```GetRating``` type methods defined. Let’s define these type methods for the ```Pieces``` struct:
e>...<br>func (p *Pieces) ReadContent(input string) (string, int) {<br> if input != &quot;&quot; {<br>    p.Content = input<br>  }<br> return p.Content, utf8.RuneCountInString(p.Content)<br>}<br><br>func (p *Pieces) GetRating() (float64) {<br> return p.Rating<br>}<br>...</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=409e458def" target="_blank" rel="noopener noreferrer">Save this code</a>
In the above snippet, once we implemented the functions of an interface for the ```Pieces``` data type, that interface is satisfied automatically<strong> </strong>for that data type. To make some sense out of these, let’s say we want to publish any post on our blog, but we want the post to be readable and rate-able. With the help of interface type, we can place some sort of boundary on a ```Publish``` function:
e>...<br>func Publish(post Blog) {<br> if r := post.GetRating(); r != 0 {<br>    c, rc := post.ReadContent(&quot;&quot;)<br>    fmt.Printf(&quot;New post: %s\\nWord count:%d\\tWith rating: %.1f\\n&quot;, c, rc, r)<br>  }<br>}<br>...</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=36de438801" target="_blank" rel="noopener noreferrer">Save this code</a>
<strong>Output:</strong>
e>// terminal<br>New post: No, peace is not an option comrade!<br>Word count:35   With rating: 4.7</pre><p>Interfaces are abstract types that outline a set of methods that must be implemented for another type before it can be regarded as an instance of the interface. In other words, an interface consists of both a type and a collection of methods.
An <strong>empty interface </strong>is defined as just ```interface{}```. Since an empty interface has no methods, it can and is already implemented by every data type. For example, a slice which defines its elements as a type of empty interface means it can store anything in itself.
e>// go<br>s := []interface{}{4, &quot;string&quot;, 2.5, new(Pieces), true} <em>// [4 string 2.5 0x140000ae000 true]</em></pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=b93243aa67" target="_blank" rel="noopener noreferrer">Save this code</a>
It’s advised to sparingly make use of the empty interface, especially when storing sequences of data so as to avoid errors that are easily tracked down during compiling time.
Let’s briefly look at three commonly used interfaces from the standard library shipped with Go upon installation. The three interfaces are the ```sort.Interface```, the ```io.Writer```, and ```io.Reader``` interfaces. Let’s briefly explain each below:
Once we implement ```sort.Interface``` for our custom data stored in slices, the above three methods allow us to sort the slices according to our custom needs and data.
- The ```Len``` function returns the actual length of the slice being sorted.
- The ```Less``` function contains the implementation of how the elements would be compared and sorted; this implementation would be custom to the needs of the developer but must return the boolean value of the comparison between the element at index ```i``` and ```j```.
- The ```Swap``` does the actual swapping of elements within the slice based on the outcome of ```Less```. This is required for the sorting algorithm to work.
     2 . The ```io.Writer```: This interface represents the writing part of the basis of file I/O in Go. The operation of writing to either a file, network or any writable process, involves the implementation of ```io.Writer``` for that writable object (data type). The interface definition is:
e>// go<br>type Writer interface {<br>  Write(p []byte) (n int, err error)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=765343948b" target="_blank" rel="noopener noreferrer">Save this code</a>
The above interface definition needs only one function signature to satisfy the ```Writer``` interface. The ```Write``` function takes as its argument a byte slice containing the data we want to write to, either a file, network or any writable object, and returns two named values, ```n``` and ```err```. These values represent the number of bytes written and an ```error``` variable.
   3. The ```io.Reader```: This interface represents the reading part of the basis of file I/O in Go–the operation of reading from either a file, network or any readable process. The ```Reader``` interface defines only one function signature just like ```io.Writer```. Let’s look at the interface definition:
e>// go<br>type Reader interface {<br>  Read(p []byte) (n int, err error)<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=765343948b" target="_blank" rel="noopener noreferrer">Save this code</a>
The above definition takes as its argument a byte slice which we will fill with data being read from a file, a network, or any readable object. We fill the byte slice with data up to its length. The return values represent the number of bytes read and an ```error``` variable.
## Use cases of Go interface
The concept of interfaces is predominantly used across different Go packages and executable programs to achieve flexibility without affecting the program's performance. The following example will explore the use of ```sort.Interface``` to sort the ```Pieces``` struct type:
e>// go<br>...<br>type PSlice []Pieces<br><br>func (ps PSlice) Len() int {<br> return len(ps)<br>}<br><br>func (ps PSlice) Less(i, j int) bool {<br> return ps[i].Id &lt; ps[j].Id<br>}<br><br>func (ps PSlice) Swap(i, j int) {<br>  ps[i], ps[j] = ps[j], ps[i]<br>}<br><br>...<br><br>func main() {<br>  posts := []Pieces {<br>    {7, &quot;I come in peace, comrade!&quot;, 4.1},<br>    {100, &quot;No, peace is not an option comrade!&quot;, 4.7 },<br>    {13, &quot;I preach violence, comrade!&quot;, 4.5},<br>    {-1, &quot;I live for violence, comrade&quot;, 5.5},<br>  }<br>  fmt.Println(&quot;Original:&quot;, posts)<br>  sort.Sort(PSlice(posts))<br>  fmt.Println(&quot;Sorted:&quot;, posts)<br><br> // Reverse sorting automatically works<br>  sort.Sort(sort.Reverse(PSlice(posts)))<br>  fmt.Println(&quot;Reverse sort:&quot;, posts)<br>  ...<br>}</pre><p><a href="https://ikehakinyemi.pieces.cloud/?p=c21b4f8c07" target="_blank" rel="noopener noreferrer">Save this code</a>
<strong>Output</strong>:
e>Original: [{7 I come in peace, comrade! 4.1} {100 No, peace is not an option comrade! 4.7} {13 I preach violence, comrade! 4.5} {-1 I live for violence, comrade 5.5}]<br><br>Sorted: [{-1 I live for violence, comrade 5.5} {7 I come in peace, comrade! 4.1} {13 I preach violence, comrade! 4.5} {100 No, peace is not an option comrade! 4.7}]<br><br>Reverse sort: [{100 No, peace is not an option comrade! 4.7} {13 I preach violence, comrade! 4.5} {7 I come in peace, comrade! 4.1} {-1 I live for violence, comrade 5.5}]</pre><p>That’s a long example, but only implemented the foundational concepts we shared earlier about the ```sort.Interface``` interface. We implemented ```Len```, ```Less``` and ```Swap``` for a type, ```PSlice```, which is basically a slice of ```Pieces```. With the type methods in place, we can now use the ```sort.Sort``` function to sort the slice, and also make use of the sort.Reverse function to perform reverse sorting on the slice. The ```PSlice(posts)``` expression will adapt the ```[]Pieces``` slice into the ```PSlice``` type with the methods ```Len```, ```Less``` and ```Swap```. This is possible because ```[]Pieces``` has the appropriate type signature with ```PSlice```.
## Conclusion
In this tutorial, we covered what reflection and interfaces are in Go. For example, reflection provides a more elegant approach to scrubbing sensitive data before logging it. And as well, interfaces provide the flexibility to implement functionalities based on behaviors expected on a data type. We can now extend these concepts to build complex interfaces by combining one interface with another to form a new interface. The ```ReadCloser``` interface is a typical example of combining two interfaces, ```Reader``` and ```Closer```. The extensibility of these concepts are far beyond this tutorial, so I encourage you to explore more on these concepts. For more about when to use Go in general, check out <a href="https://code.pieces.app/blog/python-vs-golang" target="_blank" rel="noopener noreferrer">this comparison guide</a>.
