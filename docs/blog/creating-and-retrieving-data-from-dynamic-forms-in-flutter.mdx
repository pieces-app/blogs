![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63d015ef567fcc7736fc6964_dynamicformsinflutter_1ad75d7ff8dd2e9e0ae006cfcfe7d983_2000.jpeg)
"dart-c; flutter-9"
# Creating and Retrieving Data from Dynamic Forms in Flutter
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<p>Forms are a major way to retrieve user data in most applications today. A form consists of many input fields together that take in a user’s response or request. Also, developers might want users to make certain decisions based on their interactions, and then save this data to a server. This form data can also be used later on in the application, thus calling for the creation of a more complex form that is referred to as a dynamic form.<p.new.line><p>In this article, we’ll be looking at how we can create our own dynamic form, and also retrieve its data.<p.new.line><h2 id="df4d">What is a Dynamic Form?<h2.new.line><p>Dynamic forms are auto-generated forms that are fully controlled by the user’s actions and decisions, thus giving a real-time experience to the user.<p.new.line><h3 id="dmq18">Differences Between Static and Dynamic Forms<h3.new.line><p>Static forms are forms with a fixed number of text fields in which updates are made only to the text input value. On the contrary, dynamic forms are forms that change the number of text fields dynamically based on the user’s actions. They help in decision-making, and they accumulate an indefinite list of data or input.<p.new.line><h2 id="44cf7">Why Choose Dynamic Forms?<h2.new.line><p>Making certain decisions for users based on their input might overcrowd the user interface and data based in a static form due to the creation of multiple forms. However, in most cases, multiple forms are not needed.<p.new.line><p>A dynamic form helps in organizing the user interface and database. It also helps in decision making for both users and developers, and gives us the flexibility to create an indefinite number of forms when retrieving a list of items from the user.<p.new.line><h3 id="4h6qd">Prerequisites<h3.new.line><p>To follow along with this tutorial, you’ll need a basic understanding of Dart and Flutter.<p.new.line><h2 id="5k5t6">Scaffolding Flutter Application<h2.new.line><p>First, let’s run the command below to scaffold a Flutter application:<p.new.line><pre>flutter create flutter_dynamic_forms</pre><h3 id="32p47">Building a Form Screen<h3.new.line><p>In this section, we’ll be building our form screen and its components.<p.new.line><p>Now, let’s create a ```home.dart``` file and paste the code block below into it:<p.new.line><pre>class HomeScreen extends StatefulWidget {<br>  const HomeScreen({super.key});<br> @override<br> State&lt;HomeScreen&gt; createState() =&gt; _HomeScreenState();<br>}<br><br>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br> @override<br> Widget build(BuildContext context) {<br> return Container();<br>  }<br>}</pre><p>In the code block above, we’re adding the Stateful Widget to our ```home.dart``` file.<p.new.line><p>Next, we’ll replace the entire code in the ```src/main.dart``` file with the code below:<p.new.line><pre>import 'package:flutter/material.dart';<br>import 'package:flutter_dynamic_forms/home.dart';<br><br>void main() {<br>  runApp(const MyApp());<br>}<br><br>class MyApp extends StatelessWidget {<br> const MyApp({super.key});<br>  @override<br>  Widget build(BuildContext context) {<br>  return MaterialApp(<br>      title: 'Flutter Dynamic Form',<br>      theme: ThemeData(<br>        primarySwatch: Colors.teal,<br>        useMaterial3: true,<br>        inputDecorationTheme: const InputDecorationTheme(<br>          contentPadding: EdgeInsets.symmetric(<br>            vertical: 15,<br>            horizontal: 20,<br>          ),<br>          border: OutlineInputBorder(<br>            gapPadding: 10,<br>          ),<br>        ),<br>      ),<br>      home: const HomeScreen(),<br>    );<br>  }<br>}</pre><p>The code block above is the entry code to our application. With this, we’re setting the initial route to our ```HomeScreen``` widget created earlier, and also customizing our input field.<p.new.line><h4 id="63f0k">Creating a Form Widget<h4.new.line><p>Let’s start developing our home screen by populating it with a dynamic form. To do this, let’s head over to the ```home.dart``` file and add the following private variables below to the  ```_HomeScreenState```:<p.new.line><pre>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br>  int _formCount = 0;                                  //add this<br>  final List&lt;Map&lt;String, dynamic&gt;&gt; _dataArray = [];    //add this<br>  String? _data = '';                                  //add this<br><br> @override<br> ...        // other code blocks here<br>}</pre><p>In the code block above, we’re initializing some private variables that will help manage our app state internally and store some state data.<p.new.line><p>Next, let’s build our form widget. We’ll add the code block below at the end of the override build widget before the   ```_HomeScreenState``` closing braces:<p.new.line><pre>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br><br>  . . .      // other code blocks here<br><br>  Widget form(int key) =&gt; Padding(<br>        padding: const EdgeInsets.only(bottom: 10.0),<br>        child: TextFormField(<br>          decoration: InputDecoration(hintText: 'Form ${key + 1}'),<br>        ),<br>      );<br><br>}   // closing curly braces for _HomeScreenState</pre><p>In the code block above, we’re creating our ```TextFormField``` widget with a ```hintText``` of one plus the key parameter to know the form’s number. We’re also giving our ```TextFormField``` some padding at the bottom.<p.new.line><h4 id="1rsna">Creating Buttons<h4.new.line><p>Let’s make our form dynamic by giving users the flexibility of adding and removing forms manually. To do this, we’ll copy and paste the code below directly under the ```form()``` created in the previous section:<p.new.line><pre>Widget buttonRow() =&gt; Row(<br> mainAxisAlignment: MainAxisAlignment.spaceBetween,<br>        crossAxisAlignment: CrossAxisAlignment.center,<br>        children: [<br>          Visibility(<br>            visible: _formCount &gt; 0,<br>            child: IconButton(<br>              onPressed: () {<br>                  if (_dataArray.isNotEmpty) {<br>                    _dataArray.removeAt(_dataArray.length - 1);<br>                  }<br>                  setState(() {<br>                    _data = _dataArray.toString();<br>                    _formCount--;<br>                  });<br>                },<br>                icon: const CircleAvatar(<br>                  backgroundColor: Colors.red,<br>                  child: Icon(<br>                    Icons.remove,<br>                  ),<br>                )),<br>          ),<br>          IconButton(<br>              onPressed: () {<br>                setState(() =&gt; _formCount++);<br>              },<br>              icon: const CircleAvatar(<br>                  backgroundColor: Colors.teal,<br>                child: Icon(<br>                  Icons.add,<br>                ),<br>              )),<br>        ],<br>      );</pre><p>Based on the code block above, we’ve created two icon buttons to add and remove the ```_formCount```. We’ve achieved this by incrementing the ```_formCount``` in the add button and decrementing it in the remove button. We’re also controlling the button’s visibility by checking and making sure it only displays when the ```_formCount``` is more than zero (0).<p.new.line><p>In the remove button, we’re also removing the last input object from the ```_dataArray``` whenever the remove button is clicked, and setting the remaining values of the ```_dataArray``` to the ```_data string```.<p.new.line><p>Lastly, let’s add all of our components together to see what we’ve achieved so far. We’ll update the build context with the code below:<p.new.line><pre>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br>  ...    // other code blocks here<br><br>  @override<br> Widget build(BuildContext context) {<br>    return Scaffold(<br>      appBar: AppBar(title: const Text('Home')),<br>      body: SingleChildScrollView(<br>      child: Padding(<br>          padding: const EdgeInsets.symmetric(horizontal: 25.0),<br>          child: Column(<br>          crossAxisAlignment: CrossAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>              const SizedBox(height: 19),<br>              const Text('Names of Programming Languages',<br>                style: TextStyle(<br>                fontWeight: FontWeight.bold,<br>                color: Colors.teal,<br>                fontSize: 22)),<br>              const SizedBox(height: 20),<br>              ...List.generate(_formCount, (index) =&gt; form(index)),<br>              buttonRow(),<br>              const SizedBox(height: 10),<br>              Visibility(visible: _dataArray.isNotEmpty, child: Text(_data!)),<br>              const SizedBox(height: 30),<br>            ],<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br><br>  ...   // other code blocks here<br>}</pre><p>In the code block above, we’re generating our ```form()``` widget using the number of ```_formCount```s we have. We’re also making our ```_data``` string only visible when the ```_dataArray``` has a value.<p.new.line><p>With our progress so far, we should be able to achieve the result below:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Adding names of programming language with buttons." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63d015f0567fcc94adfc6b4c_image2_3cd9670de9a941cb73c7471287012fca.gif"><div.new.line><figure.new.line><h2 id="cccug">Retrieving Data From Forms<h2.new.line><p>The trickiest part of creating a dynamic form is retrieving its real-time data. In this section, we’ll be creating our logic for retrieving real-time data from our dynamic form. Now, let’s add the function below to the base of the ```_HomeScreenState``` below the ```buttonRow()``` widget created earlier:<p.new.line><pre>void _onUpdate(int key, String val) {<br><br> void addData() {<br>      Map&lt;String, dynamic&gt; json = {'id': key, 'value': val};<br>      _dataArray.add(json);<br>      setState(() {<br>        _data = _dataArray.toString();<br>      });<br>    }<br><br> if (_dataArray.isEmpty) {<br>      addData();<br>    } else {<br>     for (var map in _dataArray) {<br>        if (map[&quot;id&quot;] == key) {<br>          _dataArray[key]['value'] = val;<br>          setState(() {<br>            _data = _dataArray.toString();<br>          });<br>        break;<br>        }<br>      }<br><br> for (var map in _dataArray) {<br> if (map[&quot;id&quot;] == key) {<br> return;<br>          }<br>        }<br>        addData();<br>      }<br>    }<br>  }</pre><p>In the code block above, we're adding our JSON object, which contains the key and value of our ```TextFormField``` to the ```_dataArray``` if it's empty. However, if the ```_dataArray``` isn't empty, we're updating the value of our object to the value from the ```TextFormField```. We're also doing a check by looping through our ```_dataArray``` to see if a particular key doesn't match an id, and then we're creating a new JSON object for it.<p.new.line><p>Lastly, let’s call the function in our ```TextFormForm```. We’ll add the code block below to the form’s ```TextFormField()``` widget:<p.new.line><pre>Widget form(int key) =&gt; Padding(<br> padding: const EdgeInsets.only(bottom: 10.0),<br>        child: TextFormField(<br>        decoration: InputDecoration(hintText: 'Form ${key + 1}'),<br>          onChanged: (val) =&gt; _onUpdate(key, val),       // add this<br>        ),<br>      );</pre><p>In the code block above, we’re passing the key (passed into the form widget) and the value from the ```onChanged``` property. The value contains the input typed into the ```TextFormField``` as we type.<p.new.line><p>Finally, let’s see our fully built dynamic form app:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The finished app, where you can add and edit with buttons." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63d015f0567fcc7b06fc6b4d_image1_92de8fdae2401a1dd55681dfd7fbda7f.gif"><div.new.line><figure.new.line><h2 id="a9b9t">Conclusion<h2.new.line><p>Dynamic forms are a very important tool in our development cycle. In this article, we’ve looked at the dynamic form, its uses, and why we should use it in our applications. We’ve also looked at how we can retrieve data from a real-time dynamic form.<p.new.line><p>Here is the full source code for the<a href="https://github.com/iamVictorSam/flutter-dynamic-forms" target="_blank" rel="noopener noreferrer"> completed project on Github.</a><p.new.line>\n\n    <fi
Forms are a major way to retrieve user data in most applications today. A form consists of many input fields together that take in a user’s response or request. Also, developers might want users to make certain decisions based on their interactions, and then save this data to a server. This form data can also be used later on in the application, thus calling for the creation of a more complex form that is referred to as a dynamic form.
In this article, we’ll be looking at how we can create our own dynamic form, and also retrieve its data.
## What is a Dynamic Form?
Dynamic forms are auto-generated forms that are fully controlled by the user’s actions and decisions, thus giving a real-time experience to the user.
### Differences Between Static and Dynamic Forms
Static forms are forms with a fixed number of text fields in which updates are made only to the text input value. On the contrary, dynamic forms are forms that change the number of text fields dynamically based on the user’s actions. They help in decision-making, and they accumulate an indefinite list of data or input.
## Why Choose Dynamic Forms?
Making certain decisions for users based on their input might overcrowd the user interface and data based in a static form due to the creation of multiple forms. However, in most cases, multiple forms are not needed.
A dynamic form helps in organizing the user interface and database. It also helps in decision making for both users and developers, and gives us the flexibility to create an indefinite number of forms when retrieving a list of items from the user.
### Prerequisites
To follow along with this tutorial, you’ll need a basic understanding of Dart and Flutter.
## Scaffolding Flutter Application
First, let’s run the command below to scaffold a Flutter application:
In this section, we’ll be building our form screen and its components.
Now, let’s create a ```home.dart``` file and paste the code block below into it:
e>class HomeScreen extends StatefulWidget {<br>  const HomeScreen({super.key});<br> @override<br> State&lt;HomeScreen&gt; createState() =&gt; _HomeScreenState();<br>}<br><br>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br> @override<br> Widget build(BuildContext context) {<br> return Container();<br>  }<br>}</pre><p>In the code block above, we’re adding the Stateful Widget to our ```home.dart``` file.
Next, we’ll replace the entire code in the ```src/main.dart``` file with the code below:
e>import 'package:flutter/material.dart';<br>import 'package:flutter_dynamic_forms/home.dart';<br><br>void main() {<br>  runApp(const MyApp());<br>}<br><br>class MyApp extends StatelessWidget {<br> const MyApp({super.key});<br>  @override<br>  Widget build(BuildContext context) {<br>  return MaterialApp(<br>      title: 'Flutter Dynamic Form',<br>      theme: ThemeData(<br>        primarySwatch: Colors.teal,<br>        useMaterial3: true,<br>        inputDecorationTheme: const InputDecorationTheme(<br>          contentPadding: EdgeInsets.symmetric(<br>            vertical: 15,<br>            horizontal: 20,<br>          ),<br>          border: OutlineInputBorder(<br>            gapPadding: 10,<br>          ),<br>        ),<br>      ),<br>      home: const HomeScreen(),<br>    );<br>  }<br>}</pre><p>The code block above is the entry code to our application. With this, we’re setting the initial route to our ```HomeScreen``` widget created earlier, and also customizing our input field.
Let’s start developing our home screen by populating it with a dynamic form. To do this, let’s head over to the ```home.dart``` file and add the following private variables below to the  ```_HomeScreenState```:
e>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br>  int _formCount = 0;                                  //add this<br>  final List&lt;Map&lt;String, dynamic&gt;&gt; _dataArray = [];    //add this<br>  String? _data = '';                                  //add this<br><br> @override<br> ...        // other code blocks here<br>}</pre><p>In the code block above, we’re initializing some private variables that will help manage our app state internally and store some state data.
Next, let’s build our form widget. We’ll add the code block below at the end of the override build widget before the   ```_HomeScreenState``` closing braces:
e>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br><br>  . . .      // other code blocks here<br><br>  Widget form(int key) =&gt; Padding(<br>        padding: const EdgeInsets.only(bottom: 10.0),<br>        child: TextFormField(<br>          decoration: InputDecoration(hintText: 'Form ${key + 1}'),<br>        ),<br>      );<br><br>}   // closing curly braces for _HomeScreenState</pre><p>In the code block above, we’re creating our ```TextFormField``` widget with a ```hintText``` of one plus the key parameter to know the form’s number. We’re also giving our ```TextFormField``` some padding at the bottom.
Let’s make our form dynamic by giving users the flexibility of adding and removing forms manually. To do this, we’ll copy and paste the code below directly under the ```form()``` created in the previous section:
e>Widget buttonRow() =&gt; Row(<br> mainAxisAlignment: MainAxisAlignment.spaceBetween,<br>        crossAxisAlignment: CrossAxisAlignment.center,<br>        children: [<br>          Visibility(<br>            visible: _formCount &gt; 0,<br>            child: IconButton(<br>              onPressed: () {<br>                  if (_dataArray.isNotEmpty) {<br>                    _dataArray.removeAt(_dataArray.length - 1);<br>                  }<br>                  setState(() {<br>                    _data = _dataArray.toString();<br>                    _formCount--;<br>                  });<br>                },<br>                icon: const CircleAvatar(<br>                  backgroundColor: Colors.red,<br>                  child: Icon(<br>                    Icons.remove,<br>                  ),<br>                )),<br>          ),<br>          IconButton(<br>              onPressed: () {<br>                setState(() =&gt; _formCount++);<br>              },<br>              icon: const CircleAvatar(<br>                  backgroundColor: Colors.teal,<br>                child: Icon(<br>                  Icons.add,<br>                ),<br>              )),<br>        ],<br>      );</pre><p>Based on the code block above, we’ve created two icon buttons to add and remove the ```_formCount```. We’ve achieved this by incrementing the ```_formCount``` in the add button and decrementing it in the remove button. We’re also controlling the button’s visibility by checking and making sure it only displays when the ```_formCount``` is more than zero (0).
In the remove button, we’re also removing the last input object from the ```_dataArray``` whenever the remove button is clicked, and setting the remaining values of the ```_dataArray``` to the ```_data string```.
Lastly, let’s add all of our components together to see what we’ve achieved so far. We’ll update the build context with the code below:
e>class _HomeScreenState extends State&lt;HomeScreen&gt; {<br>  ...    // other code blocks here<br><br>  @override<br> Widget build(BuildContext context) {<br>    return Scaffold(<br>      appBar: AppBar(title: const Text('Home')),<br>      body: SingleChildScrollView(<br>      child: Padding(<br>          padding: const EdgeInsets.symmetric(horizontal: 25.0),<br>          child: Column(<br>          crossAxisAlignment: CrossAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>              const SizedBox(height: 19),<br>              const Text('Names of Programming Languages',<br>                style: TextStyle(<br>                fontWeight: FontWeight.bold,<br>                color: Colors.teal,<br>                fontSize: 22)),<br>              const SizedBox(height: 20),<br>              ...List.generate(_formCount, (index) =&gt; form(index)),<br>              buttonRow(),<br>              const SizedBox(height: 10),<br>              Visibility(visible: _dataArray.isNotEmpty, child: Text(_data!)),<br>              const SizedBox(height: 30),<br>            ],<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br><br>  ...   // other code blocks here<br>}</pre><p>In the code block above, we’re generating our ```form()``` widget using the number of ```_formCount```s we have. We’re also making our ```_data``` string only visible when the ```_dataArray``` has a value.
With our progress so far, we should be able to achieve the result below:
![](rc="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63d015f0567fcc94adfc6b4c_image2_3cd9670de9a941cb73c7471287012fca.g)
## Retrieving Data From Forms
The trickiest part of creating a dynamic form is retrieving its real-time data. In this section, we’ll be creating our logic for retrieving real-time data from our dynamic form. Now, let’s add the function below to the base of the ```_HomeScreenState``` below the ```buttonRow()``` widget created earlier:
e>void _onUpdate(int key, String val) {<br><br> void addData() {<br>      Map&lt;String, dynamic&gt; json = {'id': key, 'value': val};<br>      _dataArray.add(json);<br>      setState(() {<br>        _data = _dataArray.toString();<br>      });<br>    }<br><br> if (_dataArray.isEmpty) {<br>      addData();<br>    } else {<br>     for (var map in _dataArray) {<br>        if (map[&quot;id&quot;] == key) {<br>          _dataArray[key]['value'] = val;<br>          setState(() {<br>            _data = _dataArray.toString();<br>          });<br>        break;<br>        }<br>      }<br><br> for (var map in _dataArray) {<br> if (map[&quot;id&quot;] == key) {<br> return;<br>          }<br>        }<br>        addData();<br>      }<br>    }<br>  }</pre><p>In the code block above, we're adding our JSON object, which contains the key and value of our ```TextFormField``` to the ```_dataArray``` if it's empty. However, if the ```_dataArray``` isn't empty, we're updating the value of our object to the value from the ```TextFormField```. We're also doing a check by looping through our ```_dataArray``` to see if a particular key doesn't match an id, and then we're creating a new JSON object for it.
Lastly, let’s call the function in our ```TextFormForm```. We’ll add the code block below to the form’s ```TextFormField()``` widget:
e>Widget form(int key) =&gt; Padding(<br> padding: const EdgeInsets.only(bottom: 10.0),<br>        child: TextFormField(<br>        decoration: InputDecoration(hintText: 'Form ${key + 1}'),<br>          onChanged: (val) =&gt; _onUpdate(key, val),       // add this<br>        ),<br>      );</pre><p>In the code block above, we’re passing the key (passed into the form widget) and the value from the ```onChanged``` property. The value contains the input typed into the ```TextFormField``` as we type.
Finally, let’s see our fully built dynamic form app:
![](tons." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63d015f0567fcc7b06fc6b4d_image1_92de8fdae2401a1dd55681dfd7fbda7f.g)
## Conclusion
Dynamic forms are a very important tool in our development cycle. In this article, we’ve looked at the dynamic form, its uses, and why we should use it in our applications. We’ve also looked at how we can retrieve data from a real-time dynamic form.
Here is the full source code for the<a href="https://github.com/iamVictorSam/flutter-dynamic-forms" target="_blank" rel="noopener noreferrer"> completed project on Github.</a>
